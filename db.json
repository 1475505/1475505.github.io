{"meta":{"version":1,"warehouse":"4.0.0"},"models":{"Asset":[{"_id":"source/emptyroom/emptyroom.txt","path":"emptyroom/emptyroom.txt","modified":0,"renderable":0},{"_id":"node_modules/hexo-theme-aurora/source/favicon.ico","path":"favicon.ico","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-aurora/source/icons/favicon-16x16.png","path":"icons/favicon-16x16.png","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-aurora/source/icons/favicon-32x32.png","path":"icons/favicon-32x32.png","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-aurora/source/static/js/404.00d640a8.js","path":"static/js/404.00d640a8.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-aurora/source/static/js/about.024aacd1.js","path":"static/js/about.024aacd1.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-aurora/source/static/js/app.6d2c358d.js","path":"static/js/app.6d2c358d.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-aurora/source/static/js/archives.574ac664.js","path":"static/js/archives.574ac664.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-aurora/source/static/js/categories.90aa5475.js","path":"static/js/categories.90aa5475.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-aurora/source/static/js/chunk-libs.dc6146cd.js","path":"static/js/chunk-libs.dc6146cd.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-aurora/source/static/js/result.39470350.js","path":"static/js/result.39470350.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-aurora/source/static/js/tags.2ad613f5.js","path":"static/js/tags.2ad613f5.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-aurora/source/static/js/page.a02618ad.js","path":"static/js/page.a02618ad.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-aurora/source/static/css/404.1a6cd5bd.css","path":"static/css/404.1a6cd5bd.css","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-aurora/source/static/css/app.0d31776f.css","path":"static/css/app.0d31776f.css","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-aurora/source/static/js/post.cebfbaa4.js","path":"static/js/post.cebfbaa4.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-aurora/source/static/css/about.32dfa3b0.css","path":"static/css/about.32dfa3b0.css","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-aurora/source/static/img/default-cover.df7c128c.jpg","path":"static/img/default-cover.df7c128c.jpg","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-aurora/source/static/css/archives.c0d49bd5.css","path":"static/css/archives.c0d49bd5.css","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-aurora/source/static/css/categories.10e2be12.css","path":"static/css/categories.10e2be12.css","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-aurora/source/static/css/chunk-libs.eebac533.css","path":"static/css/chunk-libs.eebac533.css","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-aurora/source/static/css/page.749ad047.css","path":"static/css/page.749ad047.css","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-aurora/source/static/css/post.9f951a60.css","path":"static/css/post.9f951a60.css","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-aurora/source/static/css/result.10e2be12.css","path":"static/css/result.10e2be12.css","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-aurora/source/static/css/tags.10e2be12.css","path":"static/css/tags.10e2be12.css","modified":0,"renderable":1}],"Cache":[{"_id":"source/categories/index.md","hash":"c4af81b63cd770559d1833c0467fc5f0c028c4f1","modified":1631348525170},{"_id":"source/emptyroom/index.md","hash":"8d48fe0b4e0f6b8f8412d4a70a34980e62782fc8","modified":1632063540532},{"_id":"source/emptyroom/emptyroom.txt","hash":"dc4f6344ae4d39fe64ae01f6d7fc5e46cab64c88","modified":1635217512033},{"_id":"source/_posts/0.模板.md","hash":"23f0eb68038558c6c345366d16a2d384a3ecf3a6","modified":1632126246980},{"_id":"source/_posts/C中多维数组的处理.md","hash":"7b76227efe51d0f28b9efad42fb6bca3140210f3","modified":1638198497177},{"_id":"source/_posts/0.参数.txt","hash":"b1b2bf0f9efca7d69f90a8f513620bdb9598639e","modified":1632125643161},{"_id":"source/_posts/C++STL的使用.md","hash":"7fd0e3e3bacefdbbd86f4644e5cb37502bea44f7","modified":1643880639678},{"_id":"source/_posts/动态规划优化.md","hash":"17ec4864d7f8b90d3ec9eb01c486d1c23f0f032c","modified":1628322469093},{"_id":"source/_posts/数学之美摘抄.md","hash":"c5455ffeb994ee7784b17071149a696ffd49f163","modified":1633349374453},{"_id":"source/_posts/从C进步到C++——特性.md","hash":"88cf14178a8baa7befbb27cc891326dc760c7862","modified":1641125293849},{"_id":"source/about/index.md","hash":"234771e1bf4fe5f0f3f3135575baeb41f0248aa0","modified":1631450492937},{"_id":"source/message-board/index.md","hash":"ca60e77419b47932720d8fba953864eaf667e6b5","modified":1631374753054},{"_id":"source/search/index.md","hash":"794e7c1cfc866be7e2faef10439a88583a1e5290","modified":1631348609233},{"_id":"source/tags/index.md","hash":"c28dac6cb08ab8f8662a51b35c32a2344b8da619","modified":1631348537904},{"_id":"source/_posts/动态规划初步.md","hash":"8904b56cc264c15c86bc8062be96b149e2c3a58e","modified":1637739112238},{"_id":"source/_posts/算法模板.md","hash":"aa1928e08441ecc5559765f6466b210a5537d934","modified":1637739435894},{"_id":"source/_posts/谈谈我对艺术的理解.md","hash":"0ae8fe7930f28ed975ab2444430f1471ec0485bb","modified":1637739464189},{"_id":"source/_posts/贴图/20210806dp1.png","hash":"fc076b944120d090a710e3db79e2131f58d5069f","modified":1628243193784},{"_id":"node_modules/hexo-theme-aurora/CHANGELOG.md","hash":"e68f3af8af17d326a48e1b317e01d7429193217e","modified":499162500000},{"_id":"node_modules/hexo-theme-aurora/.browserslistrc","hash":"db215b841182d2af3259a1c1d6e1957bca333970","modified":499162500000},{"_id":"node_modules/hexo-theme-aurora/package.json","hash":"6da4a379af3c78ae99c5a092c83355116f45d4cb","modified":1631349084179},{"_id":"node_modules/hexo-theme-aurora/jest.config.js","hash":"425f08cb718a56630ce61ae0686f35c55ef565df","modified":499162500000},{"_id":"node_modules/hexo-theme-aurora/LICENSE","hash":"21cf269018b0cf04e1126b6b9b1a5e6af7c5e61f","modified":499162500000},{"_id":"node_modules/hexo-theme-aurora/CHANGELOG_CN.md","hash":"5d13c251e8b77fd86870da50f3be98f8822edc66","modified":499162500000},{"_id":"node_modules/hexo-theme-aurora/.circleci/config.yml","hash":"534051be311581f69aa8287120275a04539290e4","modified":499162500000},{"_id":"node_modules/hexo-theme-aurora/scripts/index.js","hash":"2a3c62a860581ee6813ca4bcaa7c952f614e818c","modified":499162500000},{"_id":"node_modules/hexo-theme-aurora/_config.yml","hash":"e6b2335cb393444b8a1fc1ad65331f4a30bc8915","modified":499162500000},{"_id":"node_modules/hexo-theme-aurora/data/cn.yml","hash":"4f5dcc1e2953df7a8e4e683c1a9115f6e0041f5e","modified":499162500000},{"_id":"node_modules/hexo-theme-aurora/_config.aurora.yml","hash":"e6b2335cb393444b8a1fc1ad65331f4a30bc8915","modified":499162500000},{"_id":"node_modules/hexo-theme-aurora/layout/index.ejs","hash":"94732830a65b718d2fa506b8598df44f14399fd8","modified":499162500000},{"_id":"node_modules/hexo-theme-aurora/data/en.yml","hash":"7bbd6c0da0ae2f93f8a786a3be77fbe4e95a787e","modified":499162500000},{"_id":"node_modules/hexo-theme-aurora/README.md","hash":"c50f58b08b75780990c18ab85761e3e24aac0d90","modified":499162500000},{"_id":"node_modules/hexo-theme-aurora/scripts/lib/generators/category.js","hash":"0ae21ffcf6e471ebfb72ac62a833991fae86ec8a","modified":499162500000},{"_id":"node_modules/hexo-theme-aurora/scripts/lib/filters/index.js","hash":"5eacff9446dd6c9a7eb0a0c84be9187055440454","modified":499162500000},{"_id":"node_modules/hexo-theme-aurora/scripts/lib/generators/index.js","hash":"dfbb0fdbf990bd67684ed891a4aaa1fd8dcd23f2","modified":499162500000},{"_id":"node_modules/hexo-theme-aurora/scripts/lib/generators/post.js","hash":"76c3268e8b6887fb1fd11c4d71004aad9dc215fc","modified":499162500000},{"_id":"node_modules/hexo-theme-aurora/scripts/lib/generators/search.js","hash":"a2a636e1df76efdcaca37226b490afa539ce766b","modified":499162500000},{"_id":"node_modules/hexo-theme-aurora/scripts/lib/generators/page.js","hash":"1be54ea9cdf8e293e67bf457075fcdd8a72b8779","modified":499162500000},{"_id":"node_modules/hexo-theme-aurora/scripts/lib/generators/statistic.js","hash":"1c641956e15cec96490de16a88ccc7bec0c9d5c4","modified":499162500000},{"_id":"node_modules/hexo-theme-aurora/scripts/lib/generators/site.js","hash":"b5f5ce813b4b0b322eceb11b036dc65201604256","modified":499162500000},{"_id":"node_modules/hexo-theme-aurora/scripts/lib/generators/tag.js","hash":"975e79e73d2503a33dbc63655b948100cc46d44f","modified":499162500000},{"_id":"node_modules/hexo-theme-aurora/scripts/lib/helpers/mapper.js","hash":"7a99508d910321b90b4afa0df02ad90f62336901","modified":499162500000},{"_id":"node_modules/hexo-theme-aurora/scripts/lib/helpers/symbols-count-time.js","hash":"d1a81e31b2988edcdf4b4761cec7326a980f097a","modified":499162500000},{"_id":"node_modules/hexo-theme-aurora/scripts/lib/helpers/utils.js","hash":"93ff75f0e35a1dc40d5406cc097f5988dd820600","modified":499162500000},{"_id":"node_modules/hexo-theme-aurora/scripts/lib/injector/index.js","hash":"7ca562ea3af3068ee925b5a8afdce0eaa1e15e64","modified":499162500000},{"_id":"node_modules/hexo-theme-aurora/scripts/lib/helpers/toc.js","hash":"5c7348c550ef7f164d492847801a360cdefc60a2","modified":499162500000},{"_id":"node_modules/hexo-theme-aurora/scripts/lib/helpers/truncate-html.js","hash":"49d4832af027eabe5b8383a24e66dceae761533e","modified":499162500000},{"_id":"node_modules/hexo-theme-aurora/source/favicon.ico","hash":"c39d3ad80489cffed0d3df82c8cb05a049ab39a3","modified":499162500000},{"_id":"node_modules/hexo-theme-aurora/source/static/js/404.00d640a8.js","hash":"74f1da9e0f953e73e4fe1a6554433f56fdcdf54d","modified":499162500000},{"_id":"node_modules/hexo-theme-aurora/source/icons/favicon-16x16.png","hash":"849cad2a5ae49fa54c20372f7a21ae95192bafcf","modified":499162500000},{"_id":"node_modules/hexo-theme-aurora/source/icons/favicon-32x32.png","hash":"9dbabf6f4d825da99dcb2e91583755ae8d3b3ff4","modified":499162500000},{"_id":"node_modules/hexo-theme-aurora/source/static/js/about.024aacd1.js","hash":"7ce2b3f7d232dd3b3930ac993bb841452e2cde89","modified":499162500000},{"_id":"node_modules/hexo-theme-aurora/source/static/js/archives.574ac664.js","hash":"fbb094fb4f7a01bffd6975aca27142935bfdca73","modified":499162500000},{"_id":"node_modules/hexo-theme-aurora/source/static/js/categories.90aa5475.js","hash":"0dde3d731fc665962a4c330338a2c663c330be26","modified":499162500000},{"_id":"node_modules/hexo-theme-aurora/source/static/js/result.39470350.js","hash":"f6f5ab2ca7274dad169ec600a419d1a2aeb2347c","modified":499162500000},{"_id":"node_modules/hexo-theme-aurora/source/static/js/tags.2ad613f5.js","hash":"4f49139e435788710115fc884dc26a5b1e0d4833","modified":499162500000},{"_id":"node_modules/hexo-theme-aurora/source/static/js/page.a02618ad.js","hash":"db775fbfbaa1cf8bbf4cc4f2b0a869519d508e3a","modified":499162500000},{"_id":"node_modules/hexo-theme-aurora/source/static/css/404.1a6cd5bd.css","hash":"a7a4d83756520d8f6c410ac0ffe9a45d63868113","modified":499162500000},{"_id":"node_modules/hexo-theme-aurora/source/static/css/about.32dfa3b0.css","hash":"614ef7c4e52877c76ffddb26192bf8fffddcb8d8","modified":499162500000},{"_id":"node_modules/hexo-theme-aurora/source/static/css/categories.10e2be12.css","hash":"e0f686c442936311dd85f11a06f3937007758b90","modified":499162500000},{"_id":"node_modules/hexo-theme-aurora/source/static/js/post.cebfbaa4.js","hash":"53586f9dab5886a366e9397eb17088e74af5cde1","modified":499162500000},{"_id":"node_modules/hexo-theme-aurora/source/static/img/default-cover.df7c128c.jpg","hash":"1934ace0c6f2397d15729f9b08cc4d42e45bf437","modified":499162500000},{"_id":"node_modules/hexo-theme-aurora/source/static/css/archives.c0d49bd5.css","hash":"c56213315c57254d0a6e6301ef24c2186fef4d2b","modified":499162500000},{"_id":"node_modules/hexo-theme-aurora/source/static/css/result.10e2be12.css","hash":"e0f686c442936311dd85f11a06f3937007758b90","modified":499162500000},{"_id":"node_modules/hexo-theme-aurora/source/static/css/tags.10e2be12.css","hash":"e0f686c442936311dd85f11a06f3937007758b90","modified":499162500000},{"_id":"node_modules/hexo-theme-aurora/source/static/css/chunk-libs.eebac533.css","hash":"41226b6c29aadcc6190fe7c2c4c37464855b8453","modified":499162500000},{"_id":"node_modules/hexo-theme-aurora/source/static/css/page.749ad047.css","hash":"6fcf0e6f3c628954c5f8105791e0e7f3e6512da6","modified":499162500000},{"_id":"node_modules/hexo-theme-aurora/source/static/css/post.9f951a60.css","hash":"8e360582d745d6483fdfc18c46f75897b44721a6","modified":499162500000},{"_id":"node_modules/hexo-theme-aurora/source/static/css/app.0d31776f.css","hash":"43b43acd76bd8dc22f34cc49c7e026c45c3a5004","modified":499162500000},{"_id":"node_modules/hexo-theme-aurora/source/static/js/app.6d2c358d.js","hash":"e176c20c22ce36e38935f463977e9b89b281c715","modified":499162500000},{"_id":"node_modules/hexo-theme-aurora/source/static/js/chunk-libs.dc6146cd.js","hash":"534266637d09abf39278f4d3a21bd36728740105","modified":499162500000},{"_id":"public/search.xml","hash":"c7440b3daf09e1be466f94051a9122c196a0d3e4","modified":1643892317455},{"_id":"public/api/posts/1.json","hash":"1a45e87170915b24e94c83b5c075e8eb013fe2c7","modified":1643892317455},{"_id":"public/api/articles/谈谈我对艺术的理解.json","hash":"ed01c5f1c421491c8826f0abbed24725763b5e06","modified":1643892317455},{"_id":"public/api/articles/数学之美摘抄.json","hash":"d2becc15ee952ff81e8c7ef6dc3b735fe1ca6aa8","modified":1643892317455},{"_id":"public/api/articles/从C进步到C++——特性.json","hash":"08bdd13b7eaf5937dde5c1481689230df3a0f002","modified":1643892317455},{"_id":"public/api/articles/C中多维数组的处理.json","hash":"03a887a095a8e6a03384425889e5a57ff93c9af9","modified":1643892317455},{"_id":"public/api/articles/算法模板.json","hash":"fbc13bcc5faf28501fca4fcbe0af44ce44927c3f","modified":1643892317455},{"_id":"public/api/articles/C++STL的使用.json","hash":"c0fc12fea15f456b90e0d91e26c29374090bef53","modified":1643892317455},{"_id":"public/api/articles/动态规划优化.json","hash":"f0ae2bf704abfded6ab3e93caf7cc3ac80e45cae","modified":1643892317455},{"_id":"public/api/articles/动态规划初步.json","hash":"76e10bbee5921da22df81f41bce80426bc54f427","modified":1643892317455},{"_id":"public/api/features.json","hash":"d20115b13d8892401cbb59779c48897e20995f65","modified":1643892317455},{"_id":"public/api/authors/blog-author.json","hash":"30422b04a51894c7280d1929bad9d7a7dde006f9","modified":1643892317455},{"_id":"public/api/site.json","hash":"956f60dac7996889aa5b21bea94d16759062df59","modified":1643892317455},{"_id":"public/api/categories/语言基础.json","hash":"425b93ccfe659eedda9b35dfe07f0b98916055d6","modified":1643892317455},{"_id":"public/api/categories.json","hash":"3bbd26e9175c2abd32185055655b09cdb3fa23ad","modified":1635217546927},{"_id":"public/api/categories/算法进阶.json","hash":"f5cfad942244ac5e33e7d5c2b61519c807c4b340","modified":1635217546927},{"_id":"public/api/categories/算法基础.json","hash":"92de29dd120a90824fe4cee59c3800f6949aaf20","modified":1643892317455},{"_id":"public/api/tags.json","hash":"c9994fafc853bc475551d8c43825ee0cec93be50","modified":1635217546927},{"_id":"public/api/tags/C-语法.json","hash":"3f2adaba67650160c08d31ee2a58a4c958de5941","modified":1643892317455},{"_id":"public/api/tags/dp.json","hash":"3f7b38d5a1de4f34ea9cd5bffd80f5e20457c6f2","modified":1643892317455},{"_id":"public/api/pages/about/index.json","hash":"8c6267d0d5a8e963eadccd65dc18126f2653b1e3","modified":1635217546927},{"_id":"public/api/pages/categories/index.json","hash":"5868725223705a606cd941c527b9e98a7b8737b3","modified":1635217546927},{"_id":"public/api/pages/tags/index.json","hash":"f8ebce845842bd781a917ab8bd217f7089c2c6b6","modified":1635217546927},{"_id":"public/api/pages/emptyroom/index.json","hash":"2eda7d68df165a95ee323cd06c78726c5e063e88","modified":1635217546927},{"_id":"public/api/pages/search/index.json","hash":"f5f53a0cd7e749a15a84abe81deda3cd996c2637","modified":1635217546927},{"_id":"public/api/pages/message-board/index.json","hash":"8244055ba24f9849269c1db73c3aca679ca68a7b","modified":1635217546927},{"_id":"public/api/statistic.json","hash":"60ce07f87a10acddd4f6faa90b382c84b575ae56","modified":1643892317455},{"_id":"public/api/search.json","hash":"b715068cd73ad67c042ccddd438dafd4ef33660d","modified":1643892317455},{"_id":"public/post/数学之美摘抄.html","hash":"69bcb58902fafb42c192033c6494164e09bca2cf","modified":1635217546927},{"_id":"public/post/谈谈我对艺术的理解.html","hash":"69bcb58902fafb42c192033c6494164e09bca2cf","modified":1635217546927},{"_id":"public/post/C中多维数组的处理.html","hash":"69bcb58902fafb42c192033c6494164e09bca2cf","modified":1635217546927},{"_id":"public/post/算法模板.html","hash":"69bcb58902fafb42c192033c6494164e09bca2cf","modified":1635217546927},{"_id":"public/post/从C进步到C++——特性.html","hash":"69bcb58902fafb42c192033c6494164e09bca2cf","modified":1635217546927},{"_id":"public/post/C++STL的使用.html","hash":"69bcb58902fafb42c192033c6494164e09bca2cf","modified":1635217546927},{"_id":"public/index.html","hash":"69bcb58902fafb42c192033c6494164e09bca2cf","modified":1635217546927},{"_id":"public/post/动态规划优化.html","hash":"69bcb58902fafb42c192033c6494164e09bca2cf","modified":1635217546927},{"_id":"public/https://oi-wiki.org/dp/knapsack/index.html","hash":"69bcb58902fafb42c192033c6494164e09bca2cf","modified":1643892317455},{"_id":"public/tags/index.html","hash":"69bcb58902fafb42c192033c6494164e09bca2cf","modified":1635217546927},{"_id":"public/archives/index.html","hash":"69bcb58902fafb42c192033c6494164e09bca2cf","modified":1635217546927},{"_id":"public/page/about/index.html","hash":"69bcb58902fafb42c192033c6494164e09bca2cf","modified":1635217546927},{"_id":"public/page/categories/index.html","hash":"69bcb58902fafb42c192033c6494164e09bca2cf","modified":1635217546927},{"_id":"public/page/tags/index.html","hash":"69bcb58902fafb42c192033c6494164e09bca2cf","modified":1635217546927},{"_id":"public/page/emptyroom/index.html","hash":"69bcb58902fafb42c192033c6494164e09bca2cf","modified":1635217546927},{"_id":"public/page/search/index.html","hash":"69bcb58902fafb42c192033c6494164e09bca2cf","modified":1635217546927},{"_id":"public/page/message-board/index.html","hash":"69bcb58902fafb42c192033c6494164e09bca2cf","modified":1635217546927},{"_id":"public/tags/search/index.html","hash":"69bcb58902fafb42c192033c6494164e09bca2cf","modified":1635217546927},{"_id":"public/favicon.ico","hash":"c39d3ad80489cffed0d3df82c8cb05a049ab39a3","modified":1635217546927},{"_id":"public/emptyroom/emptyroom.txt","hash":"dc4f6344ae4d39fe64ae01f6d7fc5e46cab64c88","modified":1635217546927},{"_id":"public/icons/favicon-32x32.png","hash":"9dbabf6f4d825da99dcb2e91583755ae8d3b3ff4","modified":1635217546927},{"_id":"public/icons/favicon-16x16.png","hash":"849cad2a5ae49fa54c20372f7a21ae95192bafcf","modified":1635217546927},{"_id":"public/static/img/default-cover.df7c128c.jpg","hash":"1934ace0c6f2397d15729f9b08cc4d42e45bf437","modified":1635217546927},{"_id":"public/static/js/about.024aacd1.js","hash":"7ce2b3f7d232dd3b3930ac993bb841452e2cde89","modified":1635217546927},{"_id":"public/static/js/404.00d640a8.js","hash":"74f1da9e0f953e73e4fe1a6554433f56fdcdf54d","modified":1635217546927},{"_id":"public/static/js/categories.90aa5475.js","hash":"0dde3d731fc665962a4c330338a2c663c330be26","modified":1635217546927},{"_id":"public/static/js/archives.574ac664.js","hash":"fbb094fb4f7a01bffd6975aca27142935bfdca73","modified":1635217546927},{"_id":"public/static/js/tags.2ad613f5.js","hash":"4f49139e435788710115fc884dc26a5b1e0d4833","modified":1635217546927},{"_id":"public/static/css/404.1a6cd5bd.css","hash":"a7a4d83756520d8f6c410ac0ffe9a45d63868113","modified":1635217546927},{"_id":"public/static/js/page.a02618ad.js","hash":"db775fbfbaa1cf8bbf4cc4f2b0a869519d508e3a","modified":1635217546927},{"_id":"public/static/js/result.39470350.js","hash":"f6f5ab2ca7274dad169ec600a419d1a2aeb2347c","modified":1635217546927},{"_id":"public/static/css/about.32dfa3b0.css","hash":"614ef7c4e52877c76ffddb26192bf8fffddcb8d8","modified":1635217546927},{"_id":"public/static/js/post.cebfbaa4.js","hash":"53586f9dab5886a366e9397eb17088e74af5cde1","modified":1635217546927},{"_id":"public/static/css/archives.c0d49bd5.css","hash":"c56213315c57254d0a6e6301ef24c2186fef4d2b","modified":1635217546927},{"_id":"public/static/css/chunk-libs.eebac533.css","hash":"41226b6c29aadcc6190fe7c2c4c37464855b8453","modified":1635217546927},{"_id":"public/static/css/categories.10e2be12.css","hash":"e0f686c442936311dd85f11a06f3937007758b90","modified":1635217546927},{"_id":"public/static/css/result.10e2be12.css","hash":"e0f686c442936311dd85f11a06f3937007758b90","modified":1635217546927},{"_id":"public/static/css/page.749ad047.css","hash":"6fcf0e6f3c628954c5f8105791e0e7f3e6512da6","modified":1635217546927},{"_id":"public/static/css/tags.10e2be12.css","hash":"e0f686c442936311dd85f11a06f3937007758b90","modified":1635217546927},{"_id":"public/static/css/post.9f951a60.css","hash":"8e360582d745d6483fdfc18c46f75897b44721a6","modified":1635217546927},{"_id":"source/_posts/函数式编程导论.md","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1637890026727},{"_id":"source/_posts/贴图/image-20211212231236713.png","hash":"a14bfcd5b6bc343a3ede80c5083d20c80ac72653","modified":1639321956726},{"_id":"source/_posts/数据结构笔记——考试中的非主流玩法.md","hash":"6ae25bc8f9c2a2729f785c3d566c44ad9374322e","modified":1640616981539},{"_id":"source/_posts/贴图/image-20211123171532586.png","hash":"de539efadf4e18e2abb84d2a8f22eed44dc3bdeb","modified":1637658932607},{"_id":"source/_posts/贴图/350.png","hash":"f0b8101e057a05ead6ca7400e6f4d1bb15fa1920","modified":1637661786499},{"_id":"source/_posts/贴图/0d1ecb613aa2984f0576f70f86650b7c2a132538.svg+xml","hash":"940fadc082c78169afa57b7f68b7f16d4d162919","modified":1638722418753},{"_id":"source/_posts/贴图/img.png","hash":"c881c9c1683783d205d52b0c044cc4e4426a6727","modified":1638412901582},{"_id":"source/_posts/贴图/5bdc4bd3696e03991d2f202c282b791cad32973d.svg+xml","hash":"c1727864365f3bc4170c1e833f4a5f70ac927608","modified":1638722418752},{"_id":"source/_posts/贴图/原神抽卡概率分布图.png","hash":"5c294b27353784ec75d1885646c842fcd9bf78e5","modified":1638790018157},{"_id":"source/_posts/贴图/原神四星武器f抽卡概率分布图.png","hash":"f6d30dd003cdad44ca86a47fce3083bfee099e73","modified":1639210131634},{"_id":"source/_posts/贴图/webp.webp","hash":"472cde408bf651cf767c1a5b2d4e0f912c80883e","modified":1640612138751},{"_id":"source/_posts/贴图/原神4星0命抽数概率分布图.png","hash":"6c0ca11c52af0bb5164ad9693199417bbab4693a","modified":1639159895768},{"_id":"source/_posts/贴图/原神命座抽数概率分布图.png","hash":"86051461f3d14ebd5d206305e92559715d630f58","modified":1638599073084},{"_id":"source/_posts/贴图/原神抽卡2次五星概率分布图.1png.png","hash":"ea6416a6c5d408304cbed2f811d77a8da0eb0f54","modified":1639154160000},{"_id":"source/_posts/贴图/原神四星角色pdfcdf.png","hash":"3494a6185737085419a501ee750447655e9877b5","modified":1639158145698},{"_id":"source/_posts/贴图/原神武器m且n抽卡概率分布图.png","hash":"3515217bf24dbe9a708400b74e808e008328cf22","modified":1639278977562},{"_id":"source/_posts/贴图/原神抽卡2次五星概率分布图.png","hash":"2b712850631116a7aaad8ba86afa661ae9429401","modified":1638791126436},{"_id":"source/_posts/贴图/原神武器m抽卡概率分布图.png","hash":"6bc0a7f7429b419f87a97bc2e970b6e0f3a7da7e","modified":1639154575468},{"_id":"source/_posts/贴图/原神武器抽卡概率分布图.png","hash":"f36757dfe67135579024bb05b7be36b09f2f24d0","modified":1639072202497},{"_id":"source/_posts/贴图/均匀1.6原神抽卡一命概率分布图.png","hash":"ebda1881c19d3ce9dbfda8264c61f3968ba0ba5b","modified":1638855723702},{"_id":"source/_posts/贴图/原神武器n抽卡概率分布图.png","hash":"18f78c9597a2193ed2009b29a2e89dc09056d195","modified":1639156026309},{"_id":"source/_posts/贴图/均匀1.6原神抽卡2次五星概率分布图.png","hash":"83e0a11aba6ec71f8cd0b12ece36281d46ef1771","modified":1638855649977},{"_id":"source/_posts/贴图/均匀1.6原神抽卡概率分布图.png","hash":"e02f36359a3b7bb315ef5a479b19a2216999ceae","modified":1638855573103},{"_id":"source/_posts/贴图/魔改1.6原神抽卡2次五星概率分布图.png","hash":"2de7155dc1d256fd351044d45b8a61e6f32f27ce","modified":1638857067053},{"_id":"source/_posts/贴图/原神武器m不定轨抽卡概率分布图.png","hash":"a149ed47662ee17eaa1f2f6a45a489ff45226a50","modified":1639210788599},{"_id":"source/_posts/贴图/魔改1.6原神抽卡概率分布图.png","hash":"03a17ea6a08d9929d335d02b33832a6cbf2c1198","modified":1638856984655},{"_id":"source/_posts/贴图/魔改1.6原神抽卡一命概率分布图.png","hash":"c693c6e96868b827964c9865ad5f4bfec99ad437","modified":1638857135781},{"_id":"public/api/articles/数据结构笔记——考试中的非主流玩法.json","hash":"7dbe4deed10311a1570f02cd50503af6602cb0de","modified":1643892317455},{"_id":"public/api/articles/函数式编程导论.json","hash":"b8b8fdd17a39316737fbf2671ec5fafcc141bc09","modified":1643892317455},{"_id":"public/post/函数式编程导论.html","hash":"69bcb58902fafb42c192033c6494164e09bca2cf","modified":1643892317455},{"_id":"public/post/数据结构笔记——考试中的非主流玩法.html","hash":"69bcb58902fafb42c192033c6494164e09bca2cf","modified":1643892317455},{"_id":"source/_drafts/贴图/0d1ecb613aa2984f0576f70f86650b7c2a132538.svg+xml","hash":"940fadc082c78169afa57b7f68b7f16d4d162919","modified":1638722418753}],"Category":[{"name":"语言基础","_id":"ckv7ib2ra0006r8vv8gioalfw"},{"name":"算法进阶","_id":"ckv7ib2rg000er8vvf0is796b"},{"name":"算法基础","_id":"ckv7ib2rl000mr8vv23wv5z01"}],"Data":[],"Page":[{"title":"About me","date":"2021-09-11T08:23:29.000Z","_content":"\nQQ ： 725230880\n\nWeChat：m1475505\n\nEmail ： liul2566@163.com\n","source":"about/index.md","raw":"---\ntitle: About me\ndate: 2021-09-11 16:23:29\n---\n\nQQ ： 725230880\n\nWeChat：m1475505\n\nEmail ： liul2566@163.com\n","updated":"2021-09-12T12:41:32.937Z","path":"about/index.html","comments":1,"layout":"page","_id":"ckv7ib2qx0000r8vv09cpcng8","content":"<p>QQ ： 725230880</p>\n<p>WeChat：m1475505</p>\n<p>Email ： <a href=\"mailto:&#108;&#x69;&#117;&#108;&#50;&#53;&#x36;&#x36;&#64;&#x31;&#x36;&#51;&#x2e;&#99;&#111;&#109;\">&#108;&#x69;&#117;&#108;&#50;&#53;&#x36;&#x36;&#64;&#x31;&#x36;&#51;&#x2e;&#99;&#111;&#109;</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>QQ ： 725230880</p>\n<p>WeChat：m1475505</p>\n<p>Email ： <a href=\"mailto:&#108;&#x69;&#117;&#108;&#50;&#53;&#x36;&#x36;&#64;&#x31;&#x36;&#51;&#x2e;&#99;&#111;&#109;\">&#108;&#x69;&#117;&#108;&#50;&#53;&#x36;&#x36;&#64;&#x31;&#x36;&#51;&#x2e;&#99;&#111;&#109;</a></p>\n"},{"title":"categories","date":"2021-09-11T08:22:05.000Z","_content":"","source":"categories/index.md","raw":"---\ntitle: categories\ndate: 2021-09-11 16:22:05\n---\n","updated":"2021-09-11T08:22:05.170Z","path":"categories/index.html","comments":1,"layout":"page","_id":"ckv7ib2r60002r8vvfkin7jp1","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"tags","date":"2021-09-11T08:22:17.000Z","_content":"","source":"tags/index.md","raw":"---\ntitle: tags\ndate: 2021-09-11 16:22:17\n---\n","updated":"2021-09-11T08:22:17.904Z","path":"tags/index.html","comments":1,"layout":"page","_id":"ckv7ib2r80004r8vv58idf74y","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"emptyroom","date":"2021-09-19T14:59:00.000Z","_content":"","source":"emptyroom/index.md","raw":"---\ntitle: emptyroom\ndate: 2021-09-19 22:59:00\n---\n","updated":"2021-09-19T14:59:00.532Z","path":"emptyroom/index.html","comments":1,"layout":"page","_id":"ckv7ib2rc0008r8vv8xw32m1z","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"search","date":"2021-09-11T08:23:29.000Z","_content":"","source":"search/index.md","raw":"---\ntitle: search\ndate: 2021-09-11 16:23:29\n---\n","updated":"2021-09-11T08:23:29.233Z","path":"search/index.html","comments":1,"layout":"page","_id":"ckv7ib2rd000ar8vv3ospdveo","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"message-board","date":"2021-09-11T15:39:13.000Z","_content":"","source":"message-board/index.md","raw":"---\ntitle: message-board\ndate: 2021-09-11 23:39:13\n---\n","updated":"2021-09-11T15:39:13.054Z","path":"message-board/index.html","comments":1,"layout":"page","_id":"ckv7ib2re000cr8vvh7egg7ru","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"_content":"title:\t\tC++ STL使用手册\ntags:\t\tC++,语法\ncategories:\t语言基础\nfeature: true\n\n#C++ STL的使用手册\n\n[toc]\n\n![img](https://oi-wiki.org/lang/csl/images/container1.png)\n\n### 共有函数\n\n`=`：有赋值运算符以及复制构造函数。\n\n`begin()`：返回指向开头元素的迭代器。\n\n`end()`：返回指向末尾的下一个元素的迭代器。`end()` **不指向某个元素**，它是末尾元素的后继。\n\n`size()`：返回容器内的元素个数。\n\n`max_size()`：返回容器 **理论上** 能存储的最大元素个数。依容器类型和所存储变量的类型而变。\n\n`empty()`：返回容器是否为空的一个 `bool` 值，即 `begin() == end()`，`true` 为空，`false` 为非空。\n\n`swap()`：交换两个容器。\n\n`clear()`：清空容器。\n\n`==`/`!=`/`<`/`>`/`<=`/`>=`：按 **字典序** 比较两个容器的大小。（比较元素大小时 `map` 的每个元素相当于 `set<pair<key, value> >`，`pair` 按 first 到 second 的顺序比较。无序容器不支持 `<`/`>`/`<=`/`>=`\n\n## 序列式容器\n\n### vector\n\n**元素访问**\n\n1. `at()`\n\n   `v.at(pos)` 返回容器中下标为 `pos` 的引用。如果数组越界抛出 `std::out_of_range` 类型的异常。\n\n2. `operator[]`\n\n   `v[pos]` 返回容器中下标为 `pos` 的引用。不执行越界检查。\n\n3. `front()`\n\n   `v.front()` 返回首元素的引用。\n\n4. `back()`\n\n   `v.back()` 返回末尾元素的引用。\n\n**迭代器**\n\n   1. `begin()/cbegin()`\n\n      返回指向首元素的迭代器，其中 `*begin = front`。\n\n   2. `end()/cend()`\n\n      返回指向数组尾端占位符的迭代器，注意是没有元素的。\n      \n\n 可以认为，`v[i]`与`*(v.begin()+i)`等价。但，**除`vector` `string`外**，其他STL容器不支持后者的形式。\n\n\n- `size()` 返回容器长度（元素数量），即 `std::distance(v.begin(), v.end())`。\n\n- `insert()` 支持在某个迭代器位置插入元素、可以插入多个。**复杂度与 `pos` 距离末尾长度成线性而非常数**\n\n- `erase()` 删除某个**迭代器或者区间的元素**，返回最后被删除的迭代器。复杂度与 `insert` 一致。\n\n- `push_back(x)` 在末尾插入一个元素x，均摊复杂度：常数，最坏为线性复杂度。\n\n- `pop_back()` 删除末尾元素，常数复杂度。\n\n  \n\n### deque\n\n能够提供线性复杂度的插入和删除，以及常数复杂度的随机访问。操作大同`vector`。\n\n- `push_front()` 在头部插入一个元素。\n\n- `pop_front()` 删除头部元素。\n\n- `push_back()` 在末尾插入一个元素。\n\n- `pop_back()` 删除末尾元素。\n\n  \n\n### list\n\n与`deque`大致相同，但是由于 `list` 的实现是链表，因此不提供随机访问的接口。若需要访问中间元素，则需要使用迭代器。\n\n- `front()` 返回首元素的引用。\n\n- `back()` 返回末尾元素的引用。\n\n  \n\n### array(C++11)\n\n| 成员函数    | 作用                                      | 示例         |\n| :---------- | :---------------------------------------- | ------------ |\n| `operator=` | `array2` 的每个元素重写 `array1` 对应元素 |              |\n| `max_size`  | 返回可容纳的最大元素数                    |              |\n| `fill`      | 以指定值填充容器                          | arr.fill(1); |\n| `swap`      | 交换，交换array的复杂度为：O(size)        |              |\n\n| 非成员函数   | 作用                          |\n| :----------- | :---------------------------- |\n| `operator==` | 按照字典序比较 `array` 中的值 |\n| `std::get`   | 访问 `array` 的一个元素       |\n\n## 关联式容器\n\n### 统一共有函数\n\n- `find(x)`: 若容器内存在键为 x 的元素，会返回该元素的迭代器；否则返回 `end()`。\n\n  ![image-20211015124758889](C:\\Users\\ll\\AppData\\Roaming\\Typora\\typora-user-images\\image-20211015124758889.png)\n\n- `erase(pos)` 删除迭代器为 pos 的元素，可结合`find`函数使用。\n\n- `erase(first,last)` 删除迭代器在 [first,last)范围内的所有元素。\n\n- `count(x)`: 返回容器内键为 x 的元素数量。\n\n- `lower_bound(x)`: 返回指向首个**不小于** 给定**键**的元素的迭代器。\n\n- `upper_bound(x)`: 返回指向首个**大于 **给定键的元素的迭代器。若容器内所有元素均小于或等于给定键，返回 `end()`。\n\n- `size()`: 返回容器内元素个数。\n\n### set\n\n`set` 内部采用红黑树实现。平衡二叉树的特性使得 `set` 非常适合处理需要同时兼顾查找、插入与删除的情况。\n\n- `insert(x)` 将元素 x 插入到 `set` 中。自动排序和去重。\n- `erase(x)` 删除值为 x 的 **所有** 元素，返回删除元素的个数。\n- `erase(first,last)` 删除迭代器在 [first,last)范围内的所有元素。\n\n### map\n\n`map` 重载了 `operator[]`，可以用任意定义了 `operator <` 的类型作为下标（在 `map` 中叫做 `key`，也就是索引）。\n\n- 可以直接通过下标访问来进行查询或插入操作。例： `mp[\"Alan\"]=100`。利用下标访问 时，如果 `map` 中不存在相应键的元素，会自动在 `map` 中插入一个新元素，并将其值设置为默认值（对于整数，值为零；对于有默认构造函数的类型，会调用默认构造函数进行初始化）\n- 通过向 `map` 中插入一个类型为 `pair<Key, T>` 的值可以达到插入元素的目的，例如 `mp.insert(pair<string,int>(\"Alan\",100));`\n- `erase(key)` 函数会删除键为 `key` 的 **所有** 元素。返回值为删除元素的数量。\n\n## 哈希适配容器\n\n四种基于哈希实现的无序关联式容器：`unordered_set`，`unordered_multiset`，`unordered_map`，`unordered_multimap`。\n\n其操作与关联式容器类似。\n\n## 容器适配器\n\n为什么称为容器适配器呢，是因为其内部的实现是基于`vector`  `deque ` 等等，其原理可以参考《STL源码剖析》。\n\n### 后进先出的stack\n\n仅支持查询或删除最后一个加入的元素（栈顶元素），不支持随机访问。\n\n- `top()` 访问栈顶元素（如果栈为空，此处会出错）\n- `push(x)` 向栈中插入元素 x\n- `pop()` 删除栈顶元素\n\n### 先进先出的queue\n\n- `front()` 访问队首元素（如果队列为空，此处会出错）\n- `push(x)` 向队列中插入元素 x\n- `pop()` 删除队首元素\n\n### 优先队列\n\n- `top()` 访问堆顶元素（此时优先队列不能为空）\n\n- `push(x)` 插入元素，并对底层容器排序\n\n- `pop()` 删除堆顶元素（此时优先队列不能为空）\n\n以上`pop`方法，返回已删除元素的值。\n\n- 优先级的定义：\n\n  对于数字，一般是值大者优先。即默认为：\n\n  `priority_queue<int,vector<int>,less<int> > pq;`\n\n  第二个参数是内部实现方式；第三个参数  **less表示数字大的优先级越大。如果是`greater<int>`，则为数字小者优先级大。**优先级大者，位于`top`。\n\n  结构体也可以定义优先级，可以通过`cmp`函数或者重载`<`运算符实现。这种思路也适用于其他关联式容器。\n\n### pair的常见用法\n\n头文件：`<utility>`\n\n按照正常的结构体访问（first，second…）。\n\n### string的常见用法\n\n`string`的实现形式类似于字符型`vector`，支持`push_back`、直接赋值（注意使用**双引号**）和下标访问。只支持`cin` `cout`，不支持`printf`等。\n\n- 可以通过加减运算符实现字符串拼接和删减、比较运算符进行字典序比较。\n\n- `substr(pos,len)`方法截取子串。时间复杂度是O（len）。\n\n- `find(x,pos)`指定了开始寻找的位置为下标`pos`\n\n- 上面的共有函数（`erase` `find`等）也是支持的。复杂度都是O(n)\n\n  ```cpp\n  string s1 = \"Hello\";\n  string s2 = \"world\";\n  s1.insert(3,s2);//Helworldlo\n  ```\n  \n  \n\n### STL算法\n\n在《特性》篇也介绍有一些用法。\n\n- `find_end`：逆序查找。`find_end(v.begin(), v.end(), value)`。\n- `nth_element`：按指定范围进行分类，即找出序列中第 *n* 大的元素，使其左边均为小于它的数，右边均为大于它的数。`nth_element(v.begin(), v.begin() + mid, v.end(), cmp)` 或 `nth_element(a + begin, a + begin + mid, a + end, cmp)`\n- `next_permutation`：将当前排列更改为 **全排列中的下一个排列**。如果当前排列已经是 **全排列中的最后一个排列**（元素完全从大到小排列），函数返回 `false` 并将排列更改为 **全排列中的第一个排列**（元素完全从小到大排列）；否则，函数返回 `true`。`next_permutation(v.begin(), v.end())` 或 `next_permutation(v + begin, v + end)`。\n\n### bitset\n\n通过固定的优化，使得一个字节的八个比特能分别储存 8 位的 `0/1`。\n\n头文件：`<bitset>`\n\n- `bitset()`: 每一位都是 `false`。\n- `bitset(int val)`: 设为 `val` 的二进制形式。\n- `bitset(const string& str)`: 设为 01 串 `str`。\n\n```cpp\nbitset<4> bitset1;　　//无初始化下，默认每一位均为0\nbitset<8> bitset2(16);　//保存长度为8的16的二进制表示：[00010000]\nstring s = \"10010\";\nbitset<8> bitset3(s);　　//长度为10，前补0。[00010010]\n```\n\n- `operator []`: 访问其特定的一位。\n- `operator ==/!=`: 比较两个 `bitset` 内容是否完全一样。\n- `operator &/&=/|/| =/^/^=/~`: 进行按位与/或/异或/取反操作。**`bitset` 只能与 `bitset` 进行位运算**，若要和整型进行位运算，要先将整型转换为 `bitset`。\n- `operator <>/<<=/>>=`: 进行二进制左移/右移。\n- `operator <>`: 流运算符，这意味着你可以通过 `cin/cout` 进行输入输出。\n- `count()`: 返回 `true` 的数量。\n- `size()`: 返回 `bitset` 的大小。\n- `test(pos)`: 它和 `vector` 中的 `at()` 的作用是一样的，和 `[]` 运算符的区别就是越界检查。\n- `to_string()`: 返回转换成的字符串表达。\n- `to_ulong()`: 返回转换成的 `unsigned long` 表达 (`long` 在 NT 及 32 位 POSIX 系统下与 `int` 一样，在 64 位 POSIX 下与 `long long` 一样）。\n- `to_ullong()`:*C++11*，返回转换成的 `unsigned long long` 表达。\n- `any()`: 若存在某一位是 `true` 则返回 `true`，否则返回 `false`。\n- `none()`: 若所有位都是 `false` 则返回 `true`，否则返回 `false`。\n- `all()`:*C++11*，若所有位都是 `true` 则返回 `true`，否则返回 `false`。\n- `set()`: 将整个 `bitset` 设置成 `true`。\n\n  `set(pos, val = true)`: 将某一位设置成 `true`/`false`。\n- `reset()`: 将整个 `bitset` 设置成 `false`。\n\n  `reset(pos)`: 将某一位设置成 `false`。相当于 `set(pos, false)`。\n- `flip()`: 翻转每一位。（01互换，相当于异或一个全是1 的 `bitset`）\n\n  `flip(pos)`: 翻转某一位。\n\n- `_Find_first()`: 返回 `bitset` 第一个 `true` 的下标，若没有 `true` 则返回 `bitset` 的大小。\n\n- `_Find_next(pos)`: 返回 `pos` 后面（下标严格大于 `pos` 的位置）第一个 `true` 的下标，若 `pos` 后面没有 `true` 则返回 `bitset` 的大小。\n\n  \n\n参考资料：\n\nOI-wiki\n\n《算法笔记》","source":"_drafts/C++STL的使用.md","raw":"title:\t\tC++ STL使用手册\ntags:\t\tC++,语法\ncategories:\t语言基础\nfeature: true\n\n#C++ STL的使用手册\n\n[toc]\n\n![img](https://oi-wiki.org/lang/csl/images/container1.png)\n\n### 共有函数\n\n`=`：有赋值运算符以及复制构造函数。\n\n`begin()`：返回指向开头元素的迭代器。\n\n`end()`：返回指向末尾的下一个元素的迭代器。`end()` **不指向某个元素**，它是末尾元素的后继。\n\n`size()`：返回容器内的元素个数。\n\n`max_size()`：返回容器 **理论上** 能存储的最大元素个数。依容器类型和所存储变量的类型而变。\n\n`empty()`：返回容器是否为空的一个 `bool` 值，即 `begin() == end()`，`true` 为空，`false` 为非空。\n\n`swap()`：交换两个容器。\n\n`clear()`：清空容器。\n\n`==`/`!=`/`<`/`>`/`<=`/`>=`：按 **字典序** 比较两个容器的大小。（比较元素大小时 `map` 的每个元素相当于 `set<pair<key, value> >`，`pair` 按 first 到 second 的顺序比较。无序容器不支持 `<`/`>`/`<=`/`>=`\n\n## 序列式容器\n\n### vector\n\n**元素访问**\n\n1. `at()`\n\n   `v.at(pos)` 返回容器中下标为 `pos` 的引用。如果数组越界抛出 `std::out_of_range` 类型的异常。\n\n2. `operator[]`\n\n   `v[pos]` 返回容器中下标为 `pos` 的引用。不执行越界检查。\n\n3. `front()`\n\n   `v.front()` 返回首元素的引用。\n\n4. `back()`\n\n   `v.back()` 返回末尾元素的引用。\n\n**迭代器**\n\n   1. `begin()/cbegin()`\n\n      返回指向首元素的迭代器，其中 `*begin = front`。\n\n   2. `end()/cend()`\n\n      返回指向数组尾端占位符的迭代器，注意是没有元素的。\n      \n\n 可以认为，`v[i]`与`*(v.begin()+i)`等价。但，**除`vector` `string`外**，其他STL容器不支持后者的形式。\n\n\n- `size()` 返回容器长度（元素数量），即 `std::distance(v.begin(), v.end())`。\n\n- `insert()` 支持在某个迭代器位置插入元素、可以插入多个。**复杂度与 `pos` 距离末尾长度成线性而非常数**\n\n- `erase()` 删除某个**迭代器或者区间的元素**，返回最后被删除的迭代器。复杂度与 `insert` 一致。\n\n- `push_back(x)` 在末尾插入一个元素x，均摊复杂度：常数，最坏为线性复杂度。\n\n- `pop_back()` 删除末尾元素，常数复杂度。\n\n  \n\n### deque\n\n能够提供线性复杂度的插入和删除，以及常数复杂度的随机访问。操作大同`vector`。\n\n- `push_front()` 在头部插入一个元素。\n\n- `pop_front()` 删除头部元素。\n\n- `push_back()` 在末尾插入一个元素。\n\n- `pop_back()` 删除末尾元素。\n\n  \n\n### list\n\n与`deque`大致相同，但是由于 `list` 的实现是链表，因此不提供随机访问的接口。若需要访问中间元素，则需要使用迭代器。\n\n- `front()` 返回首元素的引用。\n\n- `back()` 返回末尾元素的引用。\n\n  \n\n### array(C++11)\n\n| 成员函数    | 作用                                      | 示例         |\n| :---------- | :---------------------------------------- | ------------ |\n| `operator=` | `array2` 的每个元素重写 `array1` 对应元素 |              |\n| `max_size`  | 返回可容纳的最大元素数                    |              |\n| `fill`      | 以指定值填充容器                          | arr.fill(1); |\n| `swap`      | 交换，交换array的复杂度为：O(size)        |              |\n\n| 非成员函数   | 作用                          |\n| :----------- | :---------------------------- |\n| `operator==` | 按照字典序比较 `array` 中的值 |\n| `std::get`   | 访问 `array` 的一个元素       |\n\n## 关联式容器\n\n### 统一共有函数\n\n- `find(x)`: 若容器内存在键为 x 的元素，会返回该元素的迭代器；否则返回 `end()`。\n\n  ![image-20211015124758889](C:\\Users\\ll\\AppData\\Roaming\\Typora\\typora-user-images\\image-20211015124758889.png)\n\n- `erase(pos)` 删除迭代器为 pos 的元素，可结合`find`函数使用。\n\n- `erase(first,last)` 删除迭代器在 [first,last)范围内的所有元素。\n\n- `count(x)`: 返回容器内键为 x 的元素数量。\n\n- `lower_bound(x)`: 返回指向首个**不小于** 给定**键**的元素的迭代器。\n\n- `upper_bound(x)`: 返回指向首个**大于 **给定键的元素的迭代器。若容器内所有元素均小于或等于给定键，返回 `end()`。\n\n- `size()`: 返回容器内元素个数。\n\n### set\n\n`set` 内部采用红黑树实现。平衡二叉树的特性使得 `set` 非常适合处理需要同时兼顾查找、插入与删除的情况。\n\n- `insert(x)` 将元素 x 插入到 `set` 中。自动排序和去重。\n- `erase(x)` 删除值为 x 的 **所有** 元素，返回删除元素的个数。\n- `erase(first,last)` 删除迭代器在 [first,last)范围内的所有元素。\n\n### map\n\n`map` 重载了 `operator[]`，可以用任意定义了 `operator <` 的类型作为下标（在 `map` 中叫做 `key`，也就是索引）。\n\n- 可以直接通过下标访问来进行查询或插入操作。例： `mp[\"Alan\"]=100`。利用下标访问 时，如果 `map` 中不存在相应键的元素，会自动在 `map` 中插入一个新元素，并将其值设置为默认值（对于整数，值为零；对于有默认构造函数的类型，会调用默认构造函数进行初始化）\n- 通过向 `map` 中插入一个类型为 `pair<Key, T>` 的值可以达到插入元素的目的，例如 `mp.insert(pair<string,int>(\"Alan\",100));`\n- `erase(key)` 函数会删除键为 `key` 的 **所有** 元素。返回值为删除元素的数量。\n\n## 哈希适配容器\n\n四种基于哈希实现的无序关联式容器：`unordered_set`，`unordered_multiset`，`unordered_map`，`unordered_multimap`。\n\n其操作与关联式容器类似。\n\n## 容器适配器\n\n为什么称为容器适配器呢，是因为其内部的实现是基于`vector`  `deque ` 等等，其原理可以参考《STL源码剖析》。\n\n### 后进先出的stack\n\n仅支持查询或删除最后一个加入的元素（栈顶元素），不支持随机访问。\n\n- `top()` 访问栈顶元素（如果栈为空，此处会出错）\n- `push(x)` 向栈中插入元素 x\n- `pop()` 删除栈顶元素\n\n### 先进先出的queue\n\n- `front()` 访问队首元素（如果队列为空，此处会出错）\n- `push(x)` 向队列中插入元素 x\n- `pop()` 删除队首元素\n\n### 优先队列\n\n- `top()` 访问堆顶元素（此时优先队列不能为空）\n\n- `push(x)` 插入元素，并对底层容器排序\n\n- `pop()` 删除堆顶元素（此时优先队列不能为空）\n\n以上`pop`方法，返回已删除元素的值。\n\n- 优先级的定义：\n\n  对于数字，一般是值大者优先。即默认为：\n\n  `priority_queue<int,vector<int>,less<int> > pq;`\n\n  第二个参数是内部实现方式；第三个参数  **less表示数字大的优先级越大。如果是`greater<int>`，则为数字小者优先级大。**优先级大者，位于`top`。\n\n  结构体也可以定义优先级，可以通过`cmp`函数或者重载`<`运算符实现。这种思路也适用于其他关联式容器。\n\n### pair的常见用法\n\n头文件：`<utility>`\n\n按照正常的结构体访问（first，second…）。\n\n### string的常见用法\n\n`string`的实现形式类似于字符型`vector`，支持`push_back`、直接赋值（注意使用**双引号**）和下标访问。只支持`cin` `cout`，不支持`printf`等。\n\n- 可以通过加减运算符实现字符串拼接和删减、比较运算符进行字典序比较。\n\n- `substr(pos,len)`方法截取子串。时间复杂度是O（len）。\n\n- `find(x,pos)`指定了开始寻找的位置为下标`pos`\n\n- 上面的共有函数（`erase` `find`等）也是支持的。复杂度都是O(n)\n\n  ```cpp\n  string s1 = \"Hello\";\n  string s2 = \"world\";\n  s1.insert(3,s2);//Helworldlo\n  ```\n  \n  \n\n### STL算法\n\n在《特性》篇也介绍有一些用法。\n\n- `find_end`：逆序查找。`find_end(v.begin(), v.end(), value)`。\n- `nth_element`：按指定范围进行分类，即找出序列中第 *n* 大的元素，使其左边均为小于它的数，右边均为大于它的数。`nth_element(v.begin(), v.begin() + mid, v.end(), cmp)` 或 `nth_element(a + begin, a + begin + mid, a + end, cmp)`\n- `next_permutation`：将当前排列更改为 **全排列中的下一个排列**。如果当前排列已经是 **全排列中的最后一个排列**（元素完全从大到小排列），函数返回 `false` 并将排列更改为 **全排列中的第一个排列**（元素完全从小到大排列）；否则，函数返回 `true`。`next_permutation(v.begin(), v.end())` 或 `next_permutation(v + begin, v + end)`。\n\n### bitset\n\n通过固定的优化，使得一个字节的八个比特能分别储存 8 位的 `0/1`。\n\n头文件：`<bitset>`\n\n- `bitset()`: 每一位都是 `false`。\n- `bitset(int val)`: 设为 `val` 的二进制形式。\n- `bitset(const string& str)`: 设为 01 串 `str`。\n\n```cpp\nbitset<4> bitset1;　　//无初始化下，默认每一位均为0\nbitset<8> bitset2(16);　//保存长度为8的16的二进制表示：[00010000]\nstring s = \"10010\";\nbitset<8> bitset3(s);　　//长度为10，前补0。[00010010]\n```\n\n- `operator []`: 访问其特定的一位。\n- `operator ==/!=`: 比较两个 `bitset` 内容是否完全一样。\n- `operator &/&=/|/| =/^/^=/~`: 进行按位与/或/异或/取反操作。**`bitset` 只能与 `bitset` 进行位运算**，若要和整型进行位运算，要先将整型转换为 `bitset`。\n- `operator <>/<<=/>>=`: 进行二进制左移/右移。\n- `operator <>`: 流运算符，这意味着你可以通过 `cin/cout` 进行输入输出。\n- `count()`: 返回 `true` 的数量。\n- `size()`: 返回 `bitset` 的大小。\n- `test(pos)`: 它和 `vector` 中的 `at()` 的作用是一样的，和 `[]` 运算符的区别就是越界检查。\n- `to_string()`: 返回转换成的字符串表达。\n- `to_ulong()`: 返回转换成的 `unsigned long` 表达 (`long` 在 NT 及 32 位 POSIX 系统下与 `int` 一样，在 64 位 POSIX 下与 `long long` 一样）。\n- `to_ullong()`:*C++11*，返回转换成的 `unsigned long long` 表达。\n- `any()`: 若存在某一位是 `true` 则返回 `true`，否则返回 `false`。\n- `none()`: 若所有位都是 `false` 则返回 `true`，否则返回 `false`。\n- `all()`:*C++11*，若所有位都是 `true` 则返回 `true`，否则返回 `false`。\n- `set()`: 将整个 `bitset` 设置成 `true`。\n\n  `set(pos, val = true)`: 将某一位设置成 `true`/`false`。\n- `reset()`: 将整个 `bitset` 设置成 `false`。\n\n  `reset(pos)`: 将某一位设置成 `false`。相当于 `set(pos, false)`。\n- `flip()`: 翻转每一位。（01互换，相当于异或一个全是1 的 `bitset`）\n\n  `flip(pos)`: 翻转某一位。\n\n- `_Find_first()`: 返回 `bitset` 第一个 `true` 的下标，若没有 `true` 则返回 `bitset` 的大小。\n\n- `_Find_next(pos)`: 返回 `pos` 后面（下标严格大于 `pos` 的位置）第一个 `true` 的下标，若 `pos` 后面没有 `true` 则返回 `bitset` 的大小。\n\n  \n\n参考资料：\n\nOI-wiki\n\n《算法笔记》","slug":"C++STL的使用","published":0,"date":"2022-02-03T12:48:31.987Z","updated":"2022-02-03T09:30:39.678Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"ckz6z5ofb0000fovvaplo82g0","content":"<p>title:        C++ STL使用手册<br>tags:        C++,语法<br>categories:    语言基础<br>feature: true</p>\n<p>#C++ STL的使用手册</p>\n<p>[toc]</p>\n<p><img src=\"https://oi-wiki.org/lang/csl/images/container1.png\" alt=\"img\"></p>\n<h3 id=\"共有函数\"><a href=\"#共有函数\" class=\"headerlink\" title=\"共有函数\"></a>共有函数</h3><p><code>=</code>：有赋值运算符以及复制构造函数。</p>\n<p><code>begin()</code>：返回指向开头元素的迭代器。</p>\n<p><code>end()</code>：返回指向末尾的下一个元素的迭代器。<code>end()</code> <strong>不指向某个元素</strong>，它是末尾元素的后继。</p>\n<p><code>size()</code>：返回容器内的元素个数。</p>\n<p><code>max_size()</code>：返回容器 <strong>理论上</strong> 能存储的最大元素个数。依容器类型和所存储变量的类型而变。</p>\n<p><code>empty()</code>：返回容器是否为空的一个 <code>bool</code> 值，即 <code>begin() == end()</code>，<code>true</code> 为空，<code>false</code> 为非空。</p>\n<p><code>swap()</code>：交换两个容器。</p>\n<p><code>clear()</code>：清空容器。</p>\n<p><code>==</code>/<code>!=</code>/<code>&lt;</code>/<code>&gt;</code>/<code>&lt;=</code>/<code>&gt;=</code>：按 <strong>字典序</strong> 比较两个容器的大小。（比较元素大小时 <code>map</code> 的每个元素相当于 <code>set&lt;pair&lt;key, value&gt; &gt;</code>，<code>pair</code> 按 first 到 second 的顺序比较。无序容器不支持 <code>&lt;</code>/<code>&gt;</code>/<code>&lt;=</code>/<code>&gt;=</code></p>\n<h2 id=\"序列式容器\"><a href=\"#序列式容器\" class=\"headerlink\" title=\"序列式容器\"></a>序列式容器</h2><h3 id=\"vector\"><a href=\"#vector\" class=\"headerlink\" title=\"vector\"></a>vector</h3><p><strong>元素访问</strong></p>\n<ol>\n<li><p><code>at()</code></p>\n<p><code>v.at(pos)</code> 返回容器中下标为 <code>pos</code> 的引用。如果数组越界抛出 <code>std::out_of_range</code> 类型的异常。</p>\n</li>\n<li><p><code>operator[]</code></p>\n<p><code>v[pos]</code> 返回容器中下标为 <code>pos</code> 的引用。不执行越界检查。</p>\n</li>\n<li><p><code>front()</code></p>\n<p><code>v.front()</code> 返回首元素的引用。</p>\n</li>\n<li><p><code>back()</code></p>\n<p><code>v.back()</code> 返回末尾元素的引用。</p>\n</li>\n</ol>\n<p><strong>迭代器</strong></p>\n<ol>\n<li><p><code>begin()/cbegin()</code></p>\n<p>返回指向首元素的迭代器，其中 <code>*begin = front</code>。</p>\n</li>\n<li><p><code>end()/cend()</code></p>\n<p>返回指向数组尾端占位符的迭代器，注意是没有元素的。</p>\n</li>\n</ol>\n<p> 可以认为，<code>v[i]</code>与<code>*(v.begin()+i)</code>等价。但，<strong>除<code>vector</code> <code>string</code>外</strong>，其他STL容器不支持后者的形式。</p>\n<ul>\n<li><p><code>size()</code> 返回容器长度（元素数量），即 <code>std::distance(v.begin(), v.end())</code>。</p>\n</li>\n<li><p><code>insert()</code> 支持在某个迭代器位置插入元素、可以插入多个。<strong>复杂度与 <code>pos</code> 距离末尾长度成线性而非常数</strong></p>\n</li>\n<li><p><code>erase()</code> 删除某个<strong>迭代器或者区间的元素</strong>，返回最后被删除的迭代器。复杂度与 <code>insert</code> 一致。</p>\n</li>\n<li><p><code>push_back(x)</code> 在末尾插入一个元素x，均摊复杂度：常数，最坏为线性复杂度。</p>\n</li>\n<li><p><code>pop_back()</code> 删除末尾元素，常数复杂度。</p>\n</li>\n</ul>\n<h3 id=\"deque\"><a href=\"#deque\" class=\"headerlink\" title=\"deque\"></a>deque</h3><p>能够提供线性复杂度的插入和删除，以及常数复杂度的随机访问。操作大同<code>vector</code>。</p>\n<ul>\n<li><p><code>push_front()</code> 在头部插入一个元素。</p>\n</li>\n<li><p><code>pop_front()</code> 删除头部元素。</p>\n</li>\n<li><p><code>push_back()</code> 在末尾插入一个元素。</p>\n</li>\n<li><p><code>pop_back()</code> 删除末尾元素。</p>\n</li>\n</ul>\n<h3 id=\"list\"><a href=\"#list\" class=\"headerlink\" title=\"list\"></a>list</h3><p>与<code>deque</code>大致相同，但是由于 <code>list</code> 的实现是链表，因此不提供随机访问的接口。若需要访问中间元素，则需要使用迭代器。</p>\n<ul>\n<li><p><code>front()</code> 返回首元素的引用。</p>\n</li>\n<li><p><code>back()</code> 返回末尾元素的引用。</p>\n</li>\n</ul>\n<h3 id=\"array-C-11\"><a href=\"#array-C-11\" class=\"headerlink\" title=\"array(C++11)\"></a>array(C++11)</h3><table>\n<thead>\n<tr>\n<th align=\"left\">成员函数</th>\n<th align=\"left\">作用</th>\n<th>示例</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><code>operator=</code></td>\n<td align=\"left\"><code>array2</code> 的每个元素重写 <code>array1</code> 对应元素</td>\n<td></td>\n</tr>\n<tr>\n<td align=\"left\"><code>max_size</code></td>\n<td align=\"left\">返回可容纳的最大元素数</td>\n<td></td>\n</tr>\n<tr>\n<td align=\"left\"><code>fill</code></td>\n<td align=\"left\">以指定值填充容器</td>\n<td>arr.fill(1);</td>\n</tr>\n<tr>\n<td align=\"left\"><code>swap</code></td>\n<td align=\"left\">交换，交换array的复杂度为：O(size)</td>\n<td></td>\n</tr>\n</tbody></table>\n<table>\n<thead>\n<tr>\n<th align=\"left\">非成员函数</th>\n<th align=\"left\">作用</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><code>operator==</code></td>\n<td align=\"left\">按照字典序比较 <code>array</code> 中的值</td>\n</tr>\n<tr>\n<td align=\"left\"><code>std::get</code></td>\n<td align=\"left\">访问 <code>array</code> 的一个元素</td>\n</tr>\n</tbody></table>\n<h2 id=\"关联式容器\"><a href=\"#关联式容器\" class=\"headerlink\" title=\"关联式容器\"></a>关联式容器</h2><h3 id=\"统一共有函数\"><a href=\"#统一共有函数\" class=\"headerlink\" title=\"统一共有函数\"></a>统一共有函数</h3><ul>\n<li><p><code>find(x)</code>: 若容器内存在键为 x 的元素，会返回该元素的迭代器；否则返回 <code>end()</code>。</p>\n<p><img src=\"C:\\Users\\ll\\AppData\\Roaming\\Typora\\typora-user-images\\image-20211015124758889.png\" alt=\"image-20211015124758889\"></p>\n</li>\n<li><p><code>erase(pos)</code> 删除迭代器为 pos 的元素，可结合<code>find</code>函数使用。</p>\n</li>\n<li><p><code>erase(first,last)</code> 删除迭代器在 [first,last)范围内的所有元素。</p>\n</li>\n<li><p><code>count(x)</code>: 返回容器内键为 x 的元素数量。</p>\n</li>\n<li><p><code>lower_bound(x)</code>: 返回指向首个<strong>不小于</strong> 给定<strong>键</strong>的元素的迭代器。</p>\n</li>\n<li><p><code>upper_bound(x)</code>: 返回指向首个**大于 **给定键的元素的迭代器。若容器内所有元素均小于或等于给定键，返回 <code>end()</code>。</p>\n</li>\n<li><p><code>size()</code>: 返回容器内元素个数。</p>\n</li>\n</ul>\n<h3 id=\"set\"><a href=\"#set\" class=\"headerlink\" title=\"set\"></a>set</h3><p><code>set</code> 内部采用红黑树实现。平衡二叉树的特性使得 <code>set</code> 非常适合处理需要同时兼顾查找、插入与删除的情况。</p>\n<ul>\n<li><code>insert(x)</code> 将元素 x 插入到 <code>set</code> 中。自动排序和去重。</li>\n<li><code>erase(x)</code> 删除值为 x 的 <strong>所有</strong> 元素，返回删除元素的个数。</li>\n<li><code>erase(first,last)</code> 删除迭代器在 [first,last)范围内的所有元素。</li>\n</ul>\n<h3 id=\"map\"><a href=\"#map\" class=\"headerlink\" title=\"map\"></a>map</h3><p><code>map</code> 重载了 <code>operator[]</code>，可以用任意定义了 <code>operator &lt;</code> 的类型作为下标（在 <code>map</code> 中叫做 <code>key</code>，也就是索引）。</p>\n<ul>\n<li>可以直接通过下标访问来进行查询或插入操作。例： <code>mp[&quot;Alan&quot;]=100</code>。利用下标访问 时，如果 <code>map</code> 中不存在相应键的元素，会自动在 <code>map</code> 中插入一个新元素，并将其值设置为默认值（对于整数，值为零；对于有默认构造函数的类型，会调用默认构造函数进行初始化）</li>\n<li>通过向 <code>map</code> 中插入一个类型为 <code>pair&lt;Key, T&gt;</code> 的值可以达到插入元素的目的，例如 <code>mp.insert(pair&lt;string,int&gt;(&quot;Alan&quot;,100));</code></li>\n<li><code>erase(key)</code> 函数会删除键为 <code>key</code> 的 <strong>所有</strong> 元素。返回值为删除元素的数量。</li>\n</ul>\n<h2 id=\"哈希适配容器\"><a href=\"#哈希适配容器\" class=\"headerlink\" title=\"哈希适配容器\"></a>哈希适配容器</h2><p>四种基于哈希实现的无序关联式容器：<code>unordered_set</code>，<code>unordered_multiset</code>，<code>unordered_map</code>，<code>unordered_multimap</code>。</p>\n<p>其操作与关联式容器类似。</p>\n<h2 id=\"容器适配器\"><a href=\"#容器适配器\" class=\"headerlink\" title=\"容器适配器\"></a>容器适配器</h2><p>为什么称为容器适配器呢，是因为其内部的实现是基于<code>vector</code>  <code>deque </code> 等等，其原理可以参考《STL源码剖析》。</p>\n<h3 id=\"后进先出的stack\"><a href=\"#后进先出的stack\" class=\"headerlink\" title=\"后进先出的stack\"></a>后进先出的stack</h3><p>仅支持查询或删除最后一个加入的元素（栈顶元素），不支持随机访问。</p>\n<ul>\n<li><code>top()</code> 访问栈顶元素（如果栈为空，此处会出错）</li>\n<li><code>push(x)</code> 向栈中插入元素 x</li>\n<li><code>pop()</code> 删除栈顶元素</li>\n</ul>\n<h3 id=\"先进先出的queue\"><a href=\"#先进先出的queue\" class=\"headerlink\" title=\"先进先出的queue\"></a>先进先出的queue</h3><ul>\n<li><code>front()</code> 访问队首元素（如果队列为空，此处会出错）</li>\n<li><code>push(x)</code> 向队列中插入元素 x</li>\n<li><code>pop()</code> 删除队首元素</li>\n</ul>\n<h3 id=\"优先队列\"><a href=\"#优先队列\" class=\"headerlink\" title=\"优先队列\"></a>优先队列</h3><ul>\n<li><p><code>top()</code> 访问堆顶元素（此时优先队列不能为空）</p>\n</li>\n<li><p><code>push(x)</code> 插入元素，并对底层容器排序</p>\n</li>\n<li><p><code>pop()</code> 删除堆顶元素（此时优先队列不能为空）</p>\n</li>\n</ul>\n<p>以上<code>pop</code>方法，返回已删除元素的值。</p>\n<ul>\n<li><p>优先级的定义：</p>\n<p>对于数字，一般是值大者优先。即默认为：</p>\n<p><code>priority_queue&lt;int,vector&lt;int&gt;,less&lt;int&gt; &gt; pq;</code></p>\n<p>第二个参数是内部实现方式；第三个参数  <strong>less表示数字大的优先级越大。如果是<code>greater&lt;int&gt;</code>，则为数字小者优先级大。</strong>优先级大者，位于<code>top</code>。</p>\n<p>结构体也可以定义优先级，可以通过<code>cmp</code>函数或者重载<code>&lt;</code>运算符实现。这种思路也适用于其他关联式容器。</p>\n</li>\n</ul>\n<h3 id=\"pair的常见用法\"><a href=\"#pair的常见用法\" class=\"headerlink\" title=\"pair的常见用法\"></a>pair的常见用法</h3><p>头文件：<code>&lt;utility&gt;</code></p>\n<p>按照正常的结构体访问（first，second…）。</p>\n<h3 id=\"string的常见用法\"><a href=\"#string的常见用法\" class=\"headerlink\" title=\"string的常见用法\"></a>string的常见用法</h3><p><code>string</code>的实现形式类似于字符型<code>vector</code>，支持<code>push_back</code>、直接赋值（注意使用<strong>双引号</strong>）和下标访问。只支持<code>cin</code> <code>cout</code>，不支持<code>printf</code>等。</p>\n<ul>\n<li><p>可以通过加减运算符实现字符串拼接和删减、比较运算符进行字典序比较。</p>\n</li>\n<li><p><code>substr(pos,len)</code>方法截取子串。时间复杂度是O（len）。</p>\n</li>\n<li><p><code>find(x,pos)</code>指定了开始寻找的位置为下标<code>pos</code></p>\n</li>\n<li><p>上面的共有函数（<code>erase</code> <code>find</code>等）也是支持的。复杂度都是O(n)</p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">string s1 &#x3D; &quot;Hello&quot;;\nstring s2 &#x3D; &quot;world&quot;;\ns1.insert(3,s2);&#x2F;&#x2F;Helworldlo</code></pre></li>\n</ul>\n<h3 id=\"STL算法\"><a href=\"#STL算法\" class=\"headerlink\" title=\"STL算法\"></a>STL算法</h3><p>在《特性》篇也介绍有一些用法。</p>\n<ul>\n<li><code>find_end</code>：逆序查找。<code>find_end(v.begin(), v.end(), value)</code>。</li>\n<li><code>nth_element</code>：按指定范围进行分类，即找出序列中第 <em>n</em> 大的元素，使其左边均为小于它的数，右边均为大于它的数。<code>nth_element(v.begin(), v.begin() + mid, v.end(), cmp)</code> 或 <code>nth_element(a + begin, a + begin + mid, a + end, cmp)</code></li>\n<li><code>next_permutation</code>：将当前排列更改为 <strong>全排列中的下一个排列</strong>。如果当前排列已经是 <strong>全排列中的最后一个排列</strong>（元素完全从大到小排列），函数返回 <code>false</code> 并将排列更改为 <strong>全排列中的第一个排列</strong>（元素完全从小到大排列）；否则，函数返回 <code>true</code>。<code>next_permutation(v.begin(), v.end())</code> 或 <code>next_permutation(v + begin, v + end)</code>。</li>\n</ul>\n<h3 id=\"bitset\"><a href=\"#bitset\" class=\"headerlink\" title=\"bitset\"></a>bitset</h3><p>通过固定的优化，使得一个字节的八个比特能分别储存 8 位的 <code>0/1</code>。</p>\n<p>头文件：<code>&lt;bitset&gt;</code></p>\n<ul>\n<li><code>bitset()</code>: 每一位都是 <code>false</code>。</li>\n<li><code>bitset(int val)</code>: 设为 <code>val</code> 的二进制形式。</li>\n<li><code>bitset(const string&amp; str)</code>: 设为 01 串 <code>str</code>。</li>\n</ul>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">bitset&lt;4&gt; bitset1;　　&#x2F;&#x2F;无初始化下，默认每一位均为0\nbitset&lt;8&gt; bitset2(16);　&#x2F;&#x2F;保存长度为8的16的二进制表示：[00010000]\nstring s &#x3D; &quot;10010&quot;;\nbitset&lt;8&gt; bitset3(s);　　&#x2F;&#x2F;长度为10，前补0。[00010010]</code></pre>\n\n<ul>\n<li><p><code>operator []</code>: 访问其特定的一位。</p>\n</li>\n<li><p><code>operator ==/!=</code>: 比较两个 <code>bitset</code> 内容是否完全一样。</p>\n</li>\n<li><p><code>operator &amp;/&amp;=/|/| =/^/^=/~</code>: 进行按位与/或/异或/取反操作。**<code>bitset</code> 只能与 <code>bitset</code> 进行位运算**，若要和整型进行位运算，要先将整型转换为 <code>bitset</code>。</p>\n</li>\n<li><p><code>operator &lt;&gt;/&lt;&lt;=/&gt;&gt;=</code>: 进行二进制左移/右移。</p>\n</li>\n<li><p><code>operator &lt;&gt;</code>: 流运算符，这意味着你可以通过 <code>cin/cout</code> 进行输入输出。</p>\n</li>\n<li><p><code>count()</code>: 返回 <code>true</code> 的数量。</p>\n</li>\n<li><p><code>size()</code>: 返回 <code>bitset</code> 的大小。</p>\n</li>\n<li><p><code>test(pos)</code>: 它和 <code>vector</code> 中的 <code>at()</code> 的作用是一样的，和 <code>[]</code> 运算符的区别就是越界检查。</p>\n</li>\n<li><p><code>to_string()</code>: 返回转换成的字符串表达。</p>\n</li>\n<li><p><code>to_ulong()</code>: 返回转换成的 <code>unsigned long</code> 表达 (<code>long</code> 在 NT 及 32 位 POSIX 系统下与 <code>int</code> 一样，在 64 位 POSIX 下与 <code>long long</code> 一样）。</p>\n</li>\n<li><p><code>to_ullong()</code>:<em>C++11</em>，返回转换成的 <code>unsigned long long</code> 表达。</p>\n</li>\n<li><p><code>any()</code>: 若存在某一位是 <code>true</code> 则返回 <code>true</code>，否则返回 <code>false</code>。</p>\n</li>\n<li><p><code>none()</code>: 若所有位都是 <code>false</code> 则返回 <code>true</code>，否则返回 <code>false</code>。</p>\n</li>\n<li><p><code>all()</code>:<em>C++11</em>，若所有位都是 <code>true</code> 则返回 <code>true</code>，否则返回 <code>false</code>。</p>\n</li>\n<li><p><code>set()</code>: 将整个 <code>bitset</code> 设置成 <code>true</code>。</p>\n<p><code>set(pos, val = true)</code>: 将某一位设置成 <code>true</code>/<code>false</code>。</p>\n</li>\n<li><p><code>reset()</code>: 将整个 <code>bitset</code> 设置成 <code>false</code>。</p>\n<p><code>reset(pos)</code>: 将某一位设置成 <code>false</code>。相当于 <code>set(pos, false)</code>。</p>\n</li>\n<li><p><code>flip()</code>: 翻转每一位。（01互换，相当于异或一个全是1 的 <code>bitset</code>）</p>\n<p><code>flip(pos)</code>: 翻转某一位。</p>\n</li>\n<li><p><code>_Find_first()</code>: 返回 <code>bitset</code> 第一个 <code>true</code> 的下标，若没有 <code>true</code> 则返回 <code>bitset</code> 的大小。</p>\n</li>\n<li><p><code>_Find_next(pos)</code>: 返回 <code>pos</code> 后面（下标严格大于 <code>pos</code> 的位置）第一个 <code>true</code> 的下标，若 <code>pos</code> 后面没有 <code>true</code> 则返回 <code>bitset</code> 的大小。</p>\n</li>\n</ul>\n<p>参考资料：</p>\n<p>OI-wiki</p>\n<p>《算法笔记》</p>\n","site":{"data":{}},"excerpt":"","more":"<p>title:        C++ STL使用手册<br>tags:        C++,语法<br>categories:    语言基础<br>feature: true</p>\n<p>#C++ STL的使用手册</p>\n<p>[toc]</p>\n<p><img src=\"https://oi-wiki.org/lang/csl/images/container1.png\" alt=\"img\"></p>\n<h3 id=\"共有函数\"><a href=\"#共有函数\" class=\"headerlink\" title=\"共有函数\"></a>共有函数</h3><p><code>=</code>：有赋值运算符以及复制构造函数。</p>\n<p><code>begin()</code>：返回指向开头元素的迭代器。</p>\n<p><code>end()</code>：返回指向末尾的下一个元素的迭代器。<code>end()</code> <strong>不指向某个元素</strong>，它是末尾元素的后继。</p>\n<p><code>size()</code>：返回容器内的元素个数。</p>\n<p><code>max_size()</code>：返回容器 <strong>理论上</strong> 能存储的最大元素个数。依容器类型和所存储变量的类型而变。</p>\n<p><code>empty()</code>：返回容器是否为空的一个 <code>bool</code> 值，即 <code>begin() == end()</code>，<code>true</code> 为空，<code>false</code> 为非空。</p>\n<p><code>swap()</code>：交换两个容器。</p>\n<p><code>clear()</code>：清空容器。</p>\n<p><code>==</code>/<code>!=</code>/<code>&lt;</code>/<code>&gt;</code>/<code>&lt;=</code>/<code>&gt;=</code>：按 <strong>字典序</strong> 比较两个容器的大小。（比较元素大小时 <code>map</code> 的每个元素相当于 <code>set&lt;pair&lt;key, value&gt; &gt;</code>，<code>pair</code> 按 first 到 second 的顺序比较。无序容器不支持 <code>&lt;</code>/<code>&gt;</code>/<code>&lt;=</code>/<code>&gt;=</code></p>\n<h2 id=\"序列式容器\"><a href=\"#序列式容器\" class=\"headerlink\" title=\"序列式容器\"></a>序列式容器</h2><h3 id=\"vector\"><a href=\"#vector\" class=\"headerlink\" title=\"vector\"></a>vector</h3><p><strong>元素访问</strong></p>\n<ol>\n<li><p><code>at()</code></p>\n<p><code>v.at(pos)</code> 返回容器中下标为 <code>pos</code> 的引用。如果数组越界抛出 <code>std::out_of_range</code> 类型的异常。</p>\n</li>\n<li><p><code>operator[]</code></p>\n<p><code>v[pos]</code> 返回容器中下标为 <code>pos</code> 的引用。不执行越界检查。</p>\n</li>\n<li><p><code>front()</code></p>\n<p><code>v.front()</code> 返回首元素的引用。</p>\n</li>\n<li><p><code>back()</code></p>\n<p><code>v.back()</code> 返回末尾元素的引用。</p>\n</li>\n</ol>\n<p><strong>迭代器</strong></p>\n<ol>\n<li><p><code>begin()/cbegin()</code></p>\n<p>返回指向首元素的迭代器，其中 <code>*begin = front</code>。</p>\n</li>\n<li><p><code>end()/cend()</code></p>\n<p>返回指向数组尾端占位符的迭代器，注意是没有元素的。</p>\n</li>\n</ol>\n<p> 可以认为，<code>v[i]</code>与<code>*(v.begin()+i)</code>等价。但，<strong>除<code>vector</code> <code>string</code>外</strong>，其他STL容器不支持后者的形式。</p>\n<ul>\n<li><p><code>size()</code> 返回容器长度（元素数量），即 <code>std::distance(v.begin(), v.end())</code>。</p>\n</li>\n<li><p><code>insert()</code> 支持在某个迭代器位置插入元素、可以插入多个。<strong>复杂度与 <code>pos</code> 距离末尾长度成线性而非常数</strong></p>\n</li>\n<li><p><code>erase()</code> 删除某个<strong>迭代器或者区间的元素</strong>，返回最后被删除的迭代器。复杂度与 <code>insert</code> 一致。</p>\n</li>\n<li><p><code>push_back(x)</code> 在末尾插入一个元素x，均摊复杂度：常数，最坏为线性复杂度。</p>\n</li>\n<li><p><code>pop_back()</code> 删除末尾元素，常数复杂度。</p>\n</li>\n</ul>\n<h3 id=\"deque\"><a href=\"#deque\" class=\"headerlink\" title=\"deque\"></a>deque</h3><p>能够提供线性复杂度的插入和删除，以及常数复杂度的随机访问。操作大同<code>vector</code>。</p>\n<ul>\n<li><p><code>push_front()</code> 在头部插入一个元素。</p>\n</li>\n<li><p><code>pop_front()</code> 删除头部元素。</p>\n</li>\n<li><p><code>push_back()</code> 在末尾插入一个元素。</p>\n</li>\n<li><p><code>pop_back()</code> 删除末尾元素。</p>\n</li>\n</ul>\n<h3 id=\"list\"><a href=\"#list\" class=\"headerlink\" title=\"list\"></a>list</h3><p>与<code>deque</code>大致相同，但是由于 <code>list</code> 的实现是链表，因此不提供随机访问的接口。若需要访问中间元素，则需要使用迭代器。</p>\n<ul>\n<li><p><code>front()</code> 返回首元素的引用。</p>\n</li>\n<li><p><code>back()</code> 返回末尾元素的引用。</p>\n</li>\n</ul>\n<h3 id=\"array-C-11\"><a href=\"#array-C-11\" class=\"headerlink\" title=\"array(C++11)\"></a>array(C++11)</h3><table>\n<thead>\n<tr>\n<th align=\"left\">成员函数</th>\n<th align=\"left\">作用</th>\n<th>示例</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><code>operator=</code></td>\n<td align=\"left\"><code>array2</code> 的每个元素重写 <code>array1</code> 对应元素</td>\n<td></td>\n</tr>\n<tr>\n<td align=\"left\"><code>max_size</code></td>\n<td align=\"left\">返回可容纳的最大元素数</td>\n<td></td>\n</tr>\n<tr>\n<td align=\"left\"><code>fill</code></td>\n<td align=\"left\">以指定值填充容器</td>\n<td>arr.fill(1);</td>\n</tr>\n<tr>\n<td align=\"left\"><code>swap</code></td>\n<td align=\"left\">交换，交换array的复杂度为：O(size)</td>\n<td></td>\n</tr>\n</tbody></table>\n<table>\n<thead>\n<tr>\n<th align=\"left\">非成员函数</th>\n<th align=\"left\">作用</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><code>operator==</code></td>\n<td align=\"left\">按照字典序比较 <code>array</code> 中的值</td>\n</tr>\n<tr>\n<td align=\"left\"><code>std::get</code></td>\n<td align=\"left\">访问 <code>array</code> 的一个元素</td>\n</tr>\n</tbody></table>\n<h2 id=\"关联式容器\"><a href=\"#关联式容器\" class=\"headerlink\" title=\"关联式容器\"></a>关联式容器</h2><h3 id=\"统一共有函数\"><a href=\"#统一共有函数\" class=\"headerlink\" title=\"统一共有函数\"></a>统一共有函数</h3><ul>\n<li><p><code>find(x)</code>: 若容器内存在键为 x 的元素，会返回该元素的迭代器；否则返回 <code>end()</code>。</p>\n<p><img src=\"C:\\Users\\ll\\AppData\\Roaming\\Typora\\typora-user-images\\image-20211015124758889.png\" alt=\"image-20211015124758889\"></p>\n</li>\n<li><p><code>erase(pos)</code> 删除迭代器为 pos 的元素，可结合<code>find</code>函数使用。</p>\n</li>\n<li><p><code>erase(first,last)</code> 删除迭代器在 [first,last)范围内的所有元素。</p>\n</li>\n<li><p><code>count(x)</code>: 返回容器内键为 x 的元素数量。</p>\n</li>\n<li><p><code>lower_bound(x)</code>: 返回指向首个<strong>不小于</strong> 给定<strong>键</strong>的元素的迭代器。</p>\n</li>\n<li><p><code>upper_bound(x)</code>: 返回指向首个**大于 **给定键的元素的迭代器。若容器内所有元素均小于或等于给定键，返回 <code>end()</code>。</p>\n</li>\n<li><p><code>size()</code>: 返回容器内元素个数。</p>\n</li>\n</ul>\n<h3 id=\"set\"><a href=\"#set\" class=\"headerlink\" title=\"set\"></a>set</h3><p><code>set</code> 内部采用红黑树实现。平衡二叉树的特性使得 <code>set</code> 非常适合处理需要同时兼顾查找、插入与删除的情况。</p>\n<ul>\n<li><code>insert(x)</code> 将元素 x 插入到 <code>set</code> 中。自动排序和去重。</li>\n<li><code>erase(x)</code> 删除值为 x 的 <strong>所有</strong> 元素，返回删除元素的个数。</li>\n<li><code>erase(first,last)</code> 删除迭代器在 [first,last)范围内的所有元素。</li>\n</ul>\n<h3 id=\"map\"><a href=\"#map\" class=\"headerlink\" title=\"map\"></a>map</h3><p><code>map</code> 重载了 <code>operator[]</code>，可以用任意定义了 <code>operator &lt;</code> 的类型作为下标（在 <code>map</code> 中叫做 <code>key</code>，也就是索引）。</p>\n<ul>\n<li>可以直接通过下标访问来进行查询或插入操作。例： <code>mp[&quot;Alan&quot;]=100</code>。利用下标访问 时，如果 <code>map</code> 中不存在相应键的元素，会自动在 <code>map</code> 中插入一个新元素，并将其值设置为默认值（对于整数，值为零；对于有默认构造函数的类型，会调用默认构造函数进行初始化）</li>\n<li>通过向 <code>map</code> 中插入一个类型为 <code>pair&lt;Key, T&gt;</code> 的值可以达到插入元素的目的，例如 <code>mp.insert(pair&lt;string,int&gt;(&quot;Alan&quot;,100));</code></li>\n<li><code>erase(key)</code> 函数会删除键为 <code>key</code> 的 <strong>所有</strong> 元素。返回值为删除元素的数量。</li>\n</ul>\n<h2 id=\"哈希适配容器\"><a href=\"#哈希适配容器\" class=\"headerlink\" title=\"哈希适配容器\"></a>哈希适配容器</h2><p>四种基于哈希实现的无序关联式容器：<code>unordered_set</code>，<code>unordered_multiset</code>，<code>unordered_map</code>，<code>unordered_multimap</code>。</p>\n<p>其操作与关联式容器类似。</p>\n<h2 id=\"容器适配器\"><a href=\"#容器适配器\" class=\"headerlink\" title=\"容器适配器\"></a>容器适配器</h2><p>为什么称为容器适配器呢，是因为其内部的实现是基于<code>vector</code>  <code>deque </code> 等等，其原理可以参考《STL源码剖析》。</p>\n<h3 id=\"后进先出的stack\"><a href=\"#后进先出的stack\" class=\"headerlink\" title=\"后进先出的stack\"></a>后进先出的stack</h3><p>仅支持查询或删除最后一个加入的元素（栈顶元素），不支持随机访问。</p>\n<ul>\n<li><code>top()</code> 访问栈顶元素（如果栈为空，此处会出错）</li>\n<li><code>push(x)</code> 向栈中插入元素 x</li>\n<li><code>pop()</code> 删除栈顶元素</li>\n</ul>\n<h3 id=\"先进先出的queue\"><a href=\"#先进先出的queue\" class=\"headerlink\" title=\"先进先出的queue\"></a>先进先出的queue</h3><ul>\n<li><code>front()</code> 访问队首元素（如果队列为空，此处会出错）</li>\n<li><code>push(x)</code> 向队列中插入元素 x</li>\n<li><code>pop()</code> 删除队首元素</li>\n</ul>\n<h3 id=\"优先队列\"><a href=\"#优先队列\" class=\"headerlink\" title=\"优先队列\"></a>优先队列</h3><ul>\n<li><p><code>top()</code> 访问堆顶元素（此时优先队列不能为空）</p>\n</li>\n<li><p><code>push(x)</code> 插入元素，并对底层容器排序</p>\n</li>\n<li><p><code>pop()</code> 删除堆顶元素（此时优先队列不能为空）</p>\n</li>\n</ul>\n<p>以上<code>pop</code>方法，返回已删除元素的值。</p>\n<ul>\n<li><p>优先级的定义：</p>\n<p>对于数字，一般是值大者优先。即默认为：</p>\n<p><code>priority_queue&lt;int,vector&lt;int&gt;,less&lt;int&gt; &gt; pq;</code></p>\n<p>第二个参数是内部实现方式；第三个参数  <strong>less表示数字大的优先级越大。如果是<code>greater&lt;int&gt;</code>，则为数字小者优先级大。</strong>优先级大者，位于<code>top</code>。</p>\n<p>结构体也可以定义优先级，可以通过<code>cmp</code>函数或者重载<code>&lt;</code>运算符实现。这种思路也适用于其他关联式容器。</p>\n</li>\n</ul>\n<h3 id=\"pair的常见用法\"><a href=\"#pair的常见用法\" class=\"headerlink\" title=\"pair的常见用法\"></a>pair的常见用法</h3><p>头文件：<code>&lt;utility&gt;</code></p>\n<p>按照正常的结构体访问（first，second…）。</p>\n<h3 id=\"string的常见用法\"><a href=\"#string的常见用法\" class=\"headerlink\" title=\"string的常见用法\"></a>string的常见用法</h3><p><code>string</code>的实现形式类似于字符型<code>vector</code>，支持<code>push_back</code>、直接赋值（注意使用<strong>双引号</strong>）和下标访问。只支持<code>cin</code> <code>cout</code>，不支持<code>printf</code>等。</p>\n<ul>\n<li><p>可以通过加减运算符实现字符串拼接和删减、比较运算符进行字典序比较。</p>\n</li>\n<li><p><code>substr(pos,len)</code>方法截取子串。时间复杂度是O（len）。</p>\n</li>\n<li><p><code>find(x,pos)</code>指定了开始寻找的位置为下标<code>pos</code></p>\n</li>\n<li><p>上面的共有函数（<code>erase</code> <code>find</code>等）也是支持的。复杂度都是O(n)</p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">string s1 &#x3D; &quot;Hello&quot;;\nstring s2 &#x3D; &quot;world&quot;;\ns1.insert(3,s2);&#x2F;&#x2F;Helworldlo</code></pre></li>\n</ul>\n<h3 id=\"STL算法\"><a href=\"#STL算法\" class=\"headerlink\" title=\"STL算法\"></a>STL算法</h3><p>在《特性》篇也介绍有一些用法。</p>\n<ul>\n<li><code>find_end</code>：逆序查找。<code>find_end(v.begin(), v.end(), value)</code>。</li>\n<li><code>nth_element</code>：按指定范围进行分类，即找出序列中第 <em>n</em> 大的元素，使其左边均为小于它的数，右边均为大于它的数。<code>nth_element(v.begin(), v.begin() + mid, v.end(), cmp)</code> 或 <code>nth_element(a + begin, a + begin + mid, a + end, cmp)</code></li>\n<li><code>next_permutation</code>：将当前排列更改为 <strong>全排列中的下一个排列</strong>。如果当前排列已经是 <strong>全排列中的最后一个排列</strong>（元素完全从大到小排列），函数返回 <code>false</code> 并将排列更改为 <strong>全排列中的第一个排列</strong>（元素完全从小到大排列）；否则，函数返回 <code>true</code>。<code>next_permutation(v.begin(), v.end())</code> 或 <code>next_permutation(v + begin, v + end)</code>。</li>\n</ul>\n<h3 id=\"bitset\"><a href=\"#bitset\" class=\"headerlink\" title=\"bitset\"></a>bitset</h3><p>通过固定的优化，使得一个字节的八个比特能分别储存 8 位的 <code>0/1</code>。</p>\n<p>头文件：<code>&lt;bitset&gt;</code></p>\n<ul>\n<li><code>bitset()</code>: 每一位都是 <code>false</code>。</li>\n<li><code>bitset(int val)</code>: 设为 <code>val</code> 的二进制形式。</li>\n<li><code>bitset(const string&amp; str)</code>: 设为 01 串 <code>str</code>。</li>\n</ul>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">bitset&lt;4&gt; bitset1;　　&#x2F;&#x2F;无初始化下，默认每一位均为0\nbitset&lt;8&gt; bitset2(16);　&#x2F;&#x2F;保存长度为8的16的二进制表示：[00010000]\nstring s &#x3D; &quot;10010&quot;;\nbitset&lt;8&gt; bitset3(s);　　&#x2F;&#x2F;长度为10，前补0。[00010010]</code></pre>\n\n<ul>\n<li><p><code>operator []</code>: 访问其特定的一位。</p>\n</li>\n<li><p><code>operator ==/!=</code>: 比较两个 <code>bitset</code> 内容是否完全一样。</p>\n</li>\n<li><p><code>operator &amp;/&amp;=/|/| =/^/^=/~</code>: 进行按位与/或/异或/取反操作。**<code>bitset</code> 只能与 <code>bitset</code> 进行位运算**，若要和整型进行位运算，要先将整型转换为 <code>bitset</code>。</p>\n</li>\n<li><p><code>operator &lt;&gt;/&lt;&lt;=/&gt;&gt;=</code>: 进行二进制左移/右移。</p>\n</li>\n<li><p><code>operator &lt;&gt;</code>: 流运算符，这意味着你可以通过 <code>cin/cout</code> 进行输入输出。</p>\n</li>\n<li><p><code>count()</code>: 返回 <code>true</code> 的数量。</p>\n</li>\n<li><p><code>size()</code>: 返回 <code>bitset</code> 的大小。</p>\n</li>\n<li><p><code>test(pos)</code>: 它和 <code>vector</code> 中的 <code>at()</code> 的作用是一样的，和 <code>[]</code> 运算符的区别就是越界检查。</p>\n</li>\n<li><p><code>to_string()</code>: 返回转换成的字符串表达。</p>\n</li>\n<li><p><code>to_ulong()</code>: 返回转换成的 <code>unsigned long</code> 表达 (<code>long</code> 在 NT 及 32 位 POSIX 系统下与 <code>int</code> 一样，在 64 位 POSIX 下与 <code>long long</code> 一样）。</p>\n</li>\n<li><p><code>to_ullong()</code>:<em>C++11</em>，返回转换成的 <code>unsigned long long</code> 表达。</p>\n</li>\n<li><p><code>any()</code>: 若存在某一位是 <code>true</code> 则返回 <code>true</code>，否则返回 <code>false</code>。</p>\n</li>\n<li><p><code>none()</code>: 若所有位都是 <code>false</code> 则返回 <code>true</code>，否则返回 <code>false</code>。</p>\n</li>\n<li><p><code>all()</code>:<em>C++11</em>，若所有位都是 <code>true</code> 则返回 <code>true</code>，否则返回 <code>false</code>。</p>\n</li>\n<li><p><code>set()</code>: 将整个 <code>bitset</code> 设置成 <code>true</code>。</p>\n<p><code>set(pos, val = true)</code>: 将某一位设置成 <code>true</code>/<code>false</code>。</p>\n</li>\n<li><p><code>reset()</code>: 将整个 <code>bitset</code> 设置成 <code>false</code>。</p>\n<p><code>reset(pos)</code>: 将某一位设置成 <code>false</code>。相当于 <code>set(pos, false)</code>。</p>\n</li>\n<li><p><code>flip()</code>: 翻转每一位。（01互换，相当于异或一个全是1 的 <code>bitset</code>）</p>\n<p><code>flip(pos)</code>: 翻转某一位。</p>\n</li>\n<li><p><code>_Find_first()</code>: 返回 <code>bitset</code> 第一个 <code>true</code> 的下标，若没有 <code>true</code> 则返回 <code>bitset</code> 的大小。</p>\n</li>\n<li><p><code>_Find_next(pos)</code>: 返回 <code>pos</code> 后面（下标严格大于 <code>pos</code> 的位置）第一个 <code>true</code> 的下标，若 <code>pos</code> 后面没有 <code>true</code> 则返回 <code>bitset</code> 的大小。</p>\n</li>\n</ul>\n<p>参考资料：</p>\n<p>OI-wiki</p>\n<p>《算法笔记》</p>\n"},{"title":"C++ 特性","feature":true,"_content":"\n\n\n# 从C进步到C++——特性\n\n[TOC]\n\n## 结构体初始化构造\n\n定义结构体时，加入以下语句，可以方便地进行初始化。\n\n```c++\nstruct student{\n\tint id;\n\tchar gender;\n\t\n\tstudent(){}  //系统默认，用于未经初始化定义结构体\n\t\n\tstudent (int _id, char _gender ){\n\t\tid = _id;\n\t\tgender = _gender;\n\t}//用于初始化id和gender。注意：减少参数 可以达到只使用部分元素构造的效果\n}\n```\n\n构造函数可以简化为一行，并且可以进行默认赋值，如此调用时可以省略对应参数。如：\n\n```cpp\nPoint (int x=0 , int y = 0):x(x),y(y) {};\n//Point();\n```\n\n\n\n这是一个二叉树节点的定义示例：\n\n```c++\nstruct TreeNode {\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n    TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n};\n```\n\n\n\n## auto声明推断\n\n使用STL容器时的迭代器声明等等往往比较复杂，此时使用 `auto` 可简单很多：\n\n```c++\nvector<int> vec;\nauto pvec = vec.begin();//vector<int>::iterator\n```\n\n\n\n## 容器类for-range循环\n\n对数组或容器执行循环操作可写成：\n\n```c++\ndouble prices[5] = {1.1 , 2.2 , 3.3 , 4.4 , 5.5}\nfor ( double x : prices){//只读\n\tcout<<x<<endl;\n}\nfor ( double &x : prices){//写需要使用指针\n\tx = x / 2;\n}\n```\n\n\n\n结合上面的auto 部分循环可以写成：\n\n```\nfor ( auto x : vec )\n```\n\n\n\n## string类的类型转换函数\n\n```cpp\nint i = 43;\nstring s = to_string(i);\ndouble d = stod(s);//43.000000\n//对应的有：stoi , stoll , stof\n```\n\n**注意不要传入空串！**\n\n\n\n## rotate/copy/fill函数\n\nrotate函数可以“平移”。直接看例子吧：\n\n```cpp\nvector<int> a{1,2,3,4,5,6,7,8,9};\nrotate(a.begin() , a.begin()+2 , a.end());\n//a:[3,4,5,6,7,8,9,1,2]\n```\n\n相当于得到：[mid:end] + [begin:mid)\n\n\n\ncopy函数将一个目标（容器、数组）里面的元素复制至另一个目标。\n\n**注：使用前 `newvector.resize(7) `这行代码为`newvector`分配空间，防止程序崩溃**。\n\n此外，通过`vector<int>  dp ( 7 , 0 )`也可以达到初始化`dp`为[0,0,0,0,0,0,0].\n\n\n\nfill函数可以为数组和vector赋初始值。头文件：`<algorithm>`\n\n```c++\nint v[10];\nfill(v,v+10,-1);//相当于 memset(v,-1,sizeof v);\nint s[10][10];\nfill(s[0],s[0]+10*10,-1);\n```\n\n\n\n## sort/lower_bound/upper_bound/unique函数\n\nsort函数可用于 `vector `、 数组 和 `deque` 的排序。如：\n\n```cpp\nsort(b,b+n,greater<int>());//将b降序排列\n```\n\n在**已排好升序**的情况下：\n\n1.可使用lower_bound函数（`startptr`，`endptr` ，`num`）得到第一个不小于`num`的值的指针。（二分查找）。如下代码返回下标：\n\n```cpp\nint a[10];//......\nint b = upper_bound(a , a+10 , 3) - a;\n```\n\n2.可使用unique函数返回最后一个非重复元素的指针，如下代码进行**去重**。\n\n```cpp\nvec.erase( unique(vec.begin(),vec.end()) , vec.end() );\n```\n\n拓展排序：partial_sort 方法\n\n\n\n##  局部排序`partiai_sort`\n\n可以提供一定区间的排序获得。原理似乎是堆排序。\n\n```cpp\nfor(i=10;i>=1;i--)\tvec.push_back(i);\npartial_sort(vec.begin(),vec.begin()+3,vec.end());\n//[1,2,3,10,9,8,7,6,5,4]\n\nrep(i,1,10) a.push_back(i);\npartial_sort(vec.begin(),vec.begin()+3,vec.end(),greater<int>());\n//[10,9,8,1,2,3,4,5,6,7]\n```\n\n应用：班上有10个学生，我想知道分数最低的5名是哪些人。如果没有partial_sort，你就需要用sort把所有人排好序，然后再取前5个。现在你只需要对分数最低5名排序。\n\n## 一些可能有用的数学函数\n\n**指对运算**\n\n以下函数：接收x为`float`\t`double`类型，返回传入类型。\n\n`exp2(x)`  - 快速返回2的x次幂。\n\n`log2(x)` - 得到以2为底x的对数。\n\n`log10(x)` - 得到以10为底x的对数。\n\n`log(x)`  - 得到x的自然对数。\n\n`expm(x)` - 返回e的x次幂-1。\n\n`exp(x)` - 得到e的x次幂。x支持complex类型。\n\n**取整函数**\n\n以下函数的传入传出同上。\n\n`floor(x)` - 向下取整。\n\n`ceil(x)` - 向上取整。 \n\n`round(x)` - 四舍五入，基本类似于`floor(x+0.5)`。**但是中点情况下向远离0的方向舍入**。\n\n`trunc(x)` - 将x向0方向舍入。\n\n\n\n## 数组生成- iota/shuffle\n\n递增数组：与 `golang `可对比：\n\n```cpp\niota(arr,arr+n,0);//[0,1,2,3,4,...];\n```\n\n随机打乱数组：\n\n```cpp\nsrand(time(NULL));\nrandom_shuffle(a+1,a+n+1);\n```\n\n`random_shuffle` 自 C++14 起被弃用，C++17 起被移除。可以使用 `shuffle` 函数代替：\n\n`shuffle(v.begin(),v.end(),rand)`（最后一个参数传入的是使用的随机数生成器，一般情况下传入 `rand` 即可）。\n\n使用时需要设置随机数种子，配合`iota`可以实现类似于“洗牌”的效果。同时可进行随机的多次模拟，为了时间种子的不同，可能需要每次模拟间设置`sleep`间隔。\n\n\n\n参考资料：\n\n《C++ Primer》 目录\n\n《C++ Primer Plus》  18.1\n\n《算法竞赛入门经典习题解答》第一章\n\nhttp://www.cppblog.com/mzty/archive/2005/12/15/1770.aspx\n\n\n\n","source":"_drafts/从C进步到C++——特性.md","raw":"---\ntitle:\t\tC++ 特性\ntags:\t\tC++,语法\ncategories:\t语言基础\nfeature: true\n---\n\n\n\n# 从C进步到C++——特性\n\n[TOC]\n\n## 结构体初始化构造\n\n定义结构体时，加入以下语句，可以方便地进行初始化。\n\n```c++\nstruct student{\n\tint id;\n\tchar gender;\n\t\n\tstudent(){}  //系统默认，用于未经初始化定义结构体\n\t\n\tstudent (int _id, char _gender ){\n\t\tid = _id;\n\t\tgender = _gender;\n\t}//用于初始化id和gender。注意：减少参数 可以达到只使用部分元素构造的效果\n}\n```\n\n构造函数可以简化为一行，并且可以进行默认赋值，如此调用时可以省略对应参数。如：\n\n```cpp\nPoint (int x=0 , int y = 0):x(x),y(y) {};\n//Point();\n```\n\n\n\n这是一个二叉树节点的定义示例：\n\n```c++\nstruct TreeNode {\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n    TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n};\n```\n\n\n\n## auto声明推断\n\n使用STL容器时的迭代器声明等等往往比较复杂，此时使用 `auto` 可简单很多：\n\n```c++\nvector<int> vec;\nauto pvec = vec.begin();//vector<int>::iterator\n```\n\n\n\n## 容器类for-range循环\n\n对数组或容器执行循环操作可写成：\n\n```c++\ndouble prices[5] = {1.1 , 2.2 , 3.3 , 4.4 , 5.5}\nfor ( double x : prices){//只读\n\tcout<<x<<endl;\n}\nfor ( double &x : prices){//写需要使用指针\n\tx = x / 2;\n}\n```\n\n\n\n结合上面的auto 部分循环可以写成：\n\n```\nfor ( auto x : vec )\n```\n\n\n\n## string类的类型转换函数\n\n```cpp\nint i = 43;\nstring s = to_string(i);\ndouble d = stod(s);//43.000000\n//对应的有：stoi , stoll , stof\n```\n\n**注意不要传入空串！**\n\n\n\n## rotate/copy/fill函数\n\nrotate函数可以“平移”。直接看例子吧：\n\n```cpp\nvector<int> a{1,2,3,4,5,6,7,8,9};\nrotate(a.begin() , a.begin()+2 , a.end());\n//a:[3,4,5,6,7,8,9,1,2]\n```\n\n相当于得到：[mid:end] + [begin:mid)\n\n\n\ncopy函数将一个目标（容器、数组）里面的元素复制至另一个目标。\n\n**注：使用前 `newvector.resize(7) `这行代码为`newvector`分配空间，防止程序崩溃**。\n\n此外，通过`vector<int>  dp ( 7 , 0 )`也可以达到初始化`dp`为[0,0,0,0,0,0,0].\n\n\n\nfill函数可以为数组和vector赋初始值。头文件：`<algorithm>`\n\n```c++\nint v[10];\nfill(v,v+10,-1);//相当于 memset(v,-1,sizeof v);\nint s[10][10];\nfill(s[0],s[0]+10*10,-1);\n```\n\n\n\n## sort/lower_bound/upper_bound/unique函数\n\nsort函数可用于 `vector `、 数组 和 `deque` 的排序。如：\n\n```cpp\nsort(b,b+n,greater<int>());//将b降序排列\n```\n\n在**已排好升序**的情况下：\n\n1.可使用lower_bound函数（`startptr`，`endptr` ，`num`）得到第一个不小于`num`的值的指针。（二分查找）。如下代码返回下标：\n\n```cpp\nint a[10];//......\nint b = upper_bound(a , a+10 , 3) - a;\n```\n\n2.可使用unique函数返回最后一个非重复元素的指针，如下代码进行**去重**。\n\n```cpp\nvec.erase( unique(vec.begin(),vec.end()) , vec.end() );\n```\n\n拓展排序：partial_sort 方法\n\n\n\n##  局部排序`partiai_sort`\n\n可以提供一定区间的排序获得。原理似乎是堆排序。\n\n```cpp\nfor(i=10;i>=1;i--)\tvec.push_back(i);\npartial_sort(vec.begin(),vec.begin()+3,vec.end());\n//[1,2,3,10,9,8,7,6,5,4]\n\nrep(i,1,10) a.push_back(i);\npartial_sort(vec.begin(),vec.begin()+3,vec.end(),greater<int>());\n//[10,9,8,1,2,3,4,5,6,7]\n```\n\n应用：班上有10个学生，我想知道分数最低的5名是哪些人。如果没有partial_sort，你就需要用sort把所有人排好序，然后再取前5个。现在你只需要对分数最低5名排序。\n\n## 一些可能有用的数学函数\n\n**指对运算**\n\n以下函数：接收x为`float`\t`double`类型，返回传入类型。\n\n`exp2(x)`  - 快速返回2的x次幂。\n\n`log2(x)` - 得到以2为底x的对数。\n\n`log10(x)` - 得到以10为底x的对数。\n\n`log(x)`  - 得到x的自然对数。\n\n`expm(x)` - 返回e的x次幂-1。\n\n`exp(x)` - 得到e的x次幂。x支持complex类型。\n\n**取整函数**\n\n以下函数的传入传出同上。\n\n`floor(x)` - 向下取整。\n\n`ceil(x)` - 向上取整。 \n\n`round(x)` - 四舍五入，基本类似于`floor(x+0.5)`。**但是中点情况下向远离0的方向舍入**。\n\n`trunc(x)` - 将x向0方向舍入。\n\n\n\n## 数组生成- iota/shuffle\n\n递增数组：与 `golang `可对比：\n\n```cpp\niota(arr,arr+n,0);//[0,1,2,3,4,...];\n```\n\n随机打乱数组：\n\n```cpp\nsrand(time(NULL));\nrandom_shuffle(a+1,a+n+1);\n```\n\n`random_shuffle` 自 C++14 起被弃用，C++17 起被移除。可以使用 `shuffle` 函数代替：\n\n`shuffle(v.begin(),v.end(),rand)`（最后一个参数传入的是使用的随机数生成器，一般情况下传入 `rand` 即可）。\n\n使用时需要设置随机数种子，配合`iota`可以实现类似于“洗牌”的效果。同时可进行随机的多次模拟，为了时间种子的不同，可能需要每次模拟间设置`sleep`间隔。\n\n\n\n参考资料：\n\n《C++ Primer》 目录\n\n《C++ Primer Plus》  18.1\n\n《算法竞赛入门经典习题解答》第一章\n\nhttp://www.cppblog.com/mzty/archive/2005/12/15/1770.aspx\n\n\n\n","slug":"从C进步到C++——特性","published":0,"date":"2022-02-03T12:48:31.994Z","updated":"2022-01-02T12:08:13.849Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckz6z5ofc0001fovv3vg150xd","content":"<h1 id=\"从C进步到C-——特性\"><a href=\"#从C进步到C-——特性\" class=\"headerlink\" title=\"从C进步到C++——特性\"></a>从C进步到C++——特性</h1><p>[TOC]</p>\n<h2 id=\"结构体初始化构造\"><a href=\"#结构体初始化构造\" class=\"headerlink\" title=\"结构体初始化构造\"></a>结构体初始化构造</h2><p>定义结构体时，加入以下语句，可以方便地进行初始化。</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">struct student&#123;\n\tint id;\n\tchar gender;\n\t\n\tstudent()&#123;&#125;  &#x2F;&#x2F;系统默认，用于未经初始化定义结构体\n\t\n\tstudent (int _id, char _gender )&#123;\n\t\tid &#x3D; _id;\n\t\tgender &#x3D; _gender;\n\t&#125;&#x2F;&#x2F;用于初始化id和gender。注意：减少参数 可以达到只使用部分元素构造的效果\n&#125;</code></pre>\n\n<p>构造函数可以简化为一行，并且可以进行默认赋值，如此调用时可以省略对应参数。如：</p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">Point (int x&#x3D;0 , int y &#x3D; 0):x(x),y(y) &#123;&#125;;\n&#x2F;&#x2F;Point();</code></pre>\n\n\n\n<p>这是一个二叉树节点的定义示例：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">struct TreeNode &#123;\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n    TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;\n&#125;;</code></pre>\n\n\n\n<h2 id=\"auto声明推断\"><a href=\"#auto声明推断\" class=\"headerlink\" title=\"auto声明推断\"></a>auto声明推断</h2><p>使用STL容器时的迭代器声明等等往往比较复杂，此时使用 <code>auto</code> 可简单很多：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">vector&lt;int&gt; vec;\nauto pvec &#x3D; vec.begin();&#x2F;&#x2F;vector&lt;int&gt;::iterator</code></pre>\n\n\n\n<h2 id=\"容器类for-range循环\"><a href=\"#容器类for-range循环\" class=\"headerlink\" title=\"容器类for-range循环\"></a>容器类for-range循环</h2><p>对数组或容器执行循环操作可写成：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">double prices[5] &#x3D; &#123;1.1 , 2.2 , 3.3 , 4.4 , 5.5&#125;\nfor ( double x : prices)&#123;&#x2F;&#x2F;只读\n\tcout&lt;&lt;x&lt;&lt;endl;\n&#125;\nfor ( double &amp;x : prices)&#123;&#x2F;&#x2F;写需要使用指针\n\tx &#x3D; x &#x2F; 2;\n&#125;</code></pre>\n\n\n\n<p>结合上面的auto 部分循环可以写成：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">for ( auto x : vec )</code></pre>\n\n\n\n<h2 id=\"string类的类型转换函数\"><a href=\"#string类的类型转换函数\" class=\"headerlink\" title=\"string类的类型转换函数\"></a>string类的类型转换函数</h2><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">int i &#x3D; 43;\nstring s &#x3D; to_string(i);\ndouble d &#x3D; stod(s);&#x2F;&#x2F;43.000000\n&#x2F;&#x2F;对应的有：stoi , stoll , stof</code></pre>\n\n<p><strong>注意不要传入空串！</strong></p>\n<h2 id=\"rotate-copy-fill函数\"><a href=\"#rotate-copy-fill函数\" class=\"headerlink\" title=\"rotate/copy/fill函数\"></a>rotate/copy/fill函数</h2><p>rotate函数可以“平移”。直接看例子吧：</p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">vector&lt;int&gt; a&#123;1,2,3,4,5,6,7,8,9&#125;;\nrotate(a.begin() , a.begin()+2 , a.end());\n&#x2F;&#x2F;a:[3,4,5,6,7,8,9,1,2]</code></pre>\n\n<p>相当于得到：[mid:end] + [begin:mid)</p>\n<p>copy函数将一个目标（容器、数组）里面的元素复制至另一个目标。</p>\n<p><strong>注：使用前 <code>newvector.resize(7) </code>这行代码为<code>newvector</code>分配空间，防止程序崩溃</strong>。</p>\n<p>此外，通过<code>vector&lt;int&gt;  dp ( 7 , 0 )</code>也可以达到初始化<code>dp</code>为[0,0,0,0,0,0,0].</p>\n<p>fill函数可以为数组和vector赋初始值。头文件：<code>&lt;algorithm&gt;</code></p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">int v[10];\nfill(v,v+10,-1);&#x2F;&#x2F;相当于 memset(v,-1,sizeof v);\nint s[10][10];\nfill(s[0],s[0]+10*10,-1);</code></pre>\n\n\n\n<h2 id=\"sort-lower-bound-upper-bound-unique函数\"><a href=\"#sort-lower-bound-upper-bound-unique函数\" class=\"headerlink\" title=\"sort/lower_bound/upper_bound/unique函数\"></a>sort/lower_bound/upper_bound/unique函数</h2><p>sort函数可用于 <code>vector </code>、 数组 和 <code>deque</code> 的排序。如：</p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">sort(b,b+n,greater&lt;int&gt;());&#x2F;&#x2F;将b降序排列</code></pre>\n\n<p>在<strong>已排好升序</strong>的情况下：</p>\n<p>1.可使用lower_bound函数（<code>startptr</code>，<code>endptr</code> ，<code>num</code>）得到第一个不小于<code>num</code>的值的指针。（二分查找）。如下代码返回下标：</p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">int a[10];&#x2F;&#x2F;......\nint b &#x3D; upper_bound(a , a+10 , 3) - a;</code></pre>\n\n<p>2.可使用unique函数返回最后一个非重复元素的指针，如下代码进行<strong>去重</strong>。</p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">vec.erase( unique(vec.begin(),vec.end()) , vec.end() );</code></pre>\n\n<p>拓展排序：partial_sort 方法</p>\n<h2 id=\"局部排序partiai-sort\"><a href=\"#局部排序partiai-sort\" class=\"headerlink\" title=\"局部排序partiai_sort\"></a>局部排序<code>partiai_sort</code></h2><p>可以提供一定区间的排序获得。原理似乎是堆排序。</p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">for(i&#x3D;10;i&gt;&#x3D;1;i--)\tvec.push_back(i);\npartial_sort(vec.begin(),vec.begin()+3,vec.end());\n&#x2F;&#x2F;[1,2,3,10,9,8,7,6,5,4]\n\nrep(i,1,10) a.push_back(i);\npartial_sort(vec.begin(),vec.begin()+3,vec.end(),greater&lt;int&gt;());\n&#x2F;&#x2F;[10,9,8,1,2,3,4,5,6,7]</code></pre>\n\n<p>应用：班上有10个学生，我想知道分数最低的5名是哪些人。如果没有partial_sort，你就需要用sort把所有人排好序，然后再取前5个。现在你只需要对分数最低5名排序。</p>\n<h2 id=\"一些可能有用的数学函数\"><a href=\"#一些可能有用的数学函数\" class=\"headerlink\" title=\"一些可能有用的数学函数\"></a>一些可能有用的数学函数</h2><p><strong>指对运算</strong></p>\n<p>以下函数：接收x为<code>float</code>    <code>double</code>类型，返回传入类型。</p>\n<p><code>exp2(x)</code>  - 快速返回2的x次幂。</p>\n<p><code>log2(x)</code> - 得到以2为底x的对数。</p>\n<p><code>log10(x)</code> - 得到以10为底x的对数。</p>\n<p><code>log(x)</code>  - 得到x的自然对数。</p>\n<p><code>expm(x)</code> - 返回e的x次幂-1。</p>\n<p><code>exp(x)</code> - 得到e的x次幂。x支持complex类型。</p>\n<p><strong>取整函数</strong></p>\n<p>以下函数的传入传出同上。</p>\n<p><code>floor(x)</code> - 向下取整。</p>\n<p><code>ceil(x)</code> - 向上取整。 </p>\n<p><code>round(x)</code> - 四舍五入，基本类似于<code>floor(x+0.5)</code>。<strong>但是中点情况下向远离0的方向舍入</strong>。</p>\n<p><code>trunc(x)</code> - 将x向0方向舍入。</p>\n<h2 id=\"数组生成-iota-shuffle\"><a href=\"#数组生成-iota-shuffle\" class=\"headerlink\" title=\"数组生成- iota/shuffle\"></a>数组生成- iota/shuffle</h2><p>递增数组：与 <code>golang </code>可对比：</p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">iota(arr,arr+n,0);&#x2F;&#x2F;[0,1,2,3,4,...];</code></pre>\n\n<p>随机打乱数组：</p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">srand(time(NULL));\nrandom_shuffle(a+1,a+n+1);</code></pre>\n\n<p><code>random_shuffle</code> 自 C++14 起被弃用，C++17 起被移除。可以使用 <code>shuffle</code> 函数代替：</p>\n<p><code>shuffle(v.begin(),v.end(),rand)</code>（最后一个参数传入的是使用的随机数生成器，一般情况下传入 <code>rand</code> 即可）。</p>\n<p>使用时需要设置随机数种子，配合<code>iota</code>可以实现类似于“洗牌”的效果。同时可进行随机的多次模拟，为了时间种子的不同，可能需要每次模拟间设置<code>sleep</code>间隔。</p>\n<p>参考资料：</p>\n<p>《C++ Primer》 目录</p>\n<p>《C++ Primer Plus》  18.1</p>\n<p>《算法竞赛入门经典习题解答》第一章</p>\n<p><a href=\"http://www.cppblog.com/mzty/archive/2005/12/15/1770.aspx\">http://www.cppblog.com/mzty/archive/2005/12/15/1770.aspx</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"从C进步到C-——特性\"><a href=\"#从C进步到C-——特性\" class=\"headerlink\" title=\"从C进步到C++——特性\"></a>从C进步到C++——特性</h1><p>[TOC]</p>\n<h2 id=\"结构体初始化构造\"><a href=\"#结构体初始化构造\" class=\"headerlink\" title=\"结构体初始化构造\"></a>结构体初始化构造</h2><p>定义结构体时，加入以下语句，可以方便地进行初始化。</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">struct student&#123;\n\tint id;\n\tchar gender;\n\t\n\tstudent()&#123;&#125;  &#x2F;&#x2F;系统默认，用于未经初始化定义结构体\n\t\n\tstudent (int _id, char _gender )&#123;\n\t\tid &#x3D; _id;\n\t\tgender &#x3D; _gender;\n\t&#125;&#x2F;&#x2F;用于初始化id和gender。注意：减少参数 可以达到只使用部分元素构造的效果\n&#125;</code></pre>\n\n<p>构造函数可以简化为一行，并且可以进行默认赋值，如此调用时可以省略对应参数。如：</p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">Point (int x&#x3D;0 , int y &#x3D; 0):x(x),y(y) &#123;&#125;;\n&#x2F;&#x2F;Point();</code></pre>\n\n\n\n<p>这是一个二叉树节点的定义示例：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">struct TreeNode &#123;\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n    TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;\n&#125;;</code></pre>\n\n\n\n<h2 id=\"auto声明推断\"><a href=\"#auto声明推断\" class=\"headerlink\" title=\"auto声明推断\"></a>auto声明推断</h2><p>使用STL容器时的迭代器声明等等往往比较复杂，此时使用 <code>auto</code> 可简单很多：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">vector&lt;int&gt; vec;\nauto pvec &#x3D; vec.begin();&#x2F;&#x2F;vector&lt;int&gt;::iterator</code></pre>\n\n\n\n<h2 id=\"容器类for-range循环\"><a href=\"#容器类for-range循环\" class=\"headerlink\" title=\"容器类for-range循环\"></a>容器类for-range循环</h2><p>对数组或容器执行循环操作可写成：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">double prices[5] &#x3D; &#123;1.1 , 2.2 , 3.3 , 4.4 , 5.5&#125;\nfor ( double x : prices)&#123;&#x2F;&#x2F;只读\n\tcout&lt;&lt;x&lt;&lt;endl;\n&#125;\nfor ( double &amp;x : prices)&#123;&#x2F;&#x2F;写需要使用指针\n\tx &#x3D; x &#x2F; 2;\n&#125;</code></pre>\n\n\n\n<p>结合上面的auto 部分循环可以写成：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">for ( auto x : vec )</code></pre>\n\n\n\n<h2 id=\"string类的类型转换函数\"><a href=\"#string类的类型转换函数\" class=\"headerlink\" title=\"string类的类型转换函数\"></a>string类的类型转换函数</h2><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">int i &#x3D; 43;\nstring s &#x3D; to_string(i);\ndouble d &#x3D; stod(s);&#x2F;&#x2F;43.000000\n&#x2F;&#x2F;对应的有：stoi , stoll , stof</code></pre>\n\n<p><strong>注意不要传入空串！</strong></p>\n<h2 id=\"rotate-copy-fill函数\"><a href=\"#rotate-copy-fill函数\" class=\"headerlink\" title=\"rotate/copy/fill函数\"></a>rotate/copy/fill函数</h2><p>rotate函数可以“平移”。直接看例子吧：</p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">vector&lt;int&gt; a&#123;1,2,3,4,5,6,7,8,9&#125;;\nrotate(a.begin() , a.begin()+2 , a.end());\n&#x2F;&#x2F;a:[3,4,5,6,7,8,9,1,2]</code></pre>\n\n<p>相当于得到：[mid:end] + [begin:mid)</p>\n<p>copy函数将一个目标（容器、数组）里面的元素复制至另一个目标。</p>\n<p><strong>注：使用前 <code>newvector.resize(7) </code>这行代码为<code>newvector</code>分配空间，防止程序崩溃</strong>。</p>\n<p>此外，通过<code>vector&lt;int&gt;  dp ( 7 , 0 )</code>也可以达到初始化<code>dp</code>为[0,0,0,0,0,0,0].</p>\n<p>fill函数可以为数组和vector赋初始值。头文件：<code>&lt;algorithm&gt;</code></p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">int v[10];\nfill(v,v+10,-1);&#x2F;&#x2F;相当于 memset(v,-1,sizeof v);\nint s[10][10];\nfill(s[0],s[0]+10*10,-1);</code></pre>\n\n\n\n<h2 id=\"sort-lower-bound-upper-bound-unique函数\"><a href=\"#sort-lower-bound-upper-bound-unique函数\" class=\"headerlink\" title=\"sort/lower_bound/upper_bound/unique函数\"></a>sort/lower_bound/upper_bound/unique函数</h2><p>sort函数可用于 <code>vector </code>、 数组 和 <code>deque</code> 的排序。如：</p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">sort(b,b+n,greater&lt;int&gt;());&#x2F;&#x2F;将b降序排列</code></pre>\n\n<p>在<strong>已排好升序</strong>的情况下：</p>\n<p>1.可使用lower_bound函数（<code>startptr</code>，<code>endptr</code> ，<code>num</code>）得到第一个不小于<code>num</code>的值的指针。（二分查找）。如下代码返回下标：</p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">int a[10];&#x2F;&#x2F;......\nint b &#x3D; upper_bound(a , a+10 , 3) - a;</code></pre>\n\n<p>2.可使用unique函数返回最后一个非重复元素的指针，如下代码进行<strong>去重</strong>。</p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">vec.erase( unique(vec.begin(),vec.end()) , vec.end() );</code></pre>\n\n<p>拓展排序：partial_sort 方法</p>\n<h2 id=\"局部排序partiai-sort\"><a href=\"#局部排序partiai-sort\" class=\"headerlink\" title=\"局部排序partiai_sort\"></a>局部排序<code>partiai_sort</code></h2><p>可以提供一定区间的排序获得。原理似乎是堆排序。</p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">for(i&#x3D;10;i&gt;&#x3D;1;i--)\tvec.push_back(i);\npartial_sort(vec.begin(),vec.begin()+3,vec.end());\n&#x2F;&#x2F;[1,2,3,10,9,8,7,6,5,4]\n\nrep(i,1,10) a.push_back(i);\npartial_sort(vec.begin(),vec.begin()+3,vec.end(),greater&lt;int&gt;());\n&#x2F;&#x2F;[10,9,8,1,2,3,4,5,6,7]</code></pre>\n\n<p>应用：班上有10个学生，我想知道分数最低的5名是哪些人。如果没有partial_sort，你就需要用sort把所有人排好序，然后再取前5个。现在你只需要对分数最低5名排序。</p>\n<h2 id=\"一些可能有用的数学函数\"><a href=\"#一些可能有用的数学函数\" class=\"headerlink\" title=\"一些可能有用的数学函数\"></a>一些可能有用的数学函数</h2><p><strong>指对运算</strong></p>\n<p>以下函数：接收x为<code>float</code>    <code>double</code>类型，返回传入类型。</p>\n<p><code>exp2(x)</code>  - 快速返回2的x次幂。</p>\n<p><code>log2(x)</code> - 得到以2为底x的对数。</p>\n<p><code>log10(x)</code> - 得到以10为底x的对数。</p>\n<p><code>log(x)</code>  - 得到x的自然对数。</p>\n<p><code>expm(x)</code> - 返回e的x次幂-1。</p>\n<p><code>exp(x)</code> - 得到e的x次幂。x支持complex类型。</p>\n<p><strong>取整函数</strong></p>\n<p>以下函数的传入传出同上。</p>\n<p><code>floor(x)</code> - 向下取整。</p>\n<p><code>ceil(x)</code> - 向上取整。 </p>\n<p><code>round(x)</code> - 四舍五入，基本类似于<code>floor(x+0.5)</code>。<strong>但是中点情况下向远离0的方向舍入</strong>。</p>\n<p><code>trunc(x)</code> - 将x向0方向舍入。</p>\n<h2 id=\"数组生成-iota-shuffle\"><a href=\"#数组生成-iota-shuffle\" class=\"headerlink\" title=\"数组生成- iota/shuffle\"></a>数组生成- iota/shuffle</h2><p>递增数组：与 <code>golang </code>可对比：</p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">iota(arr,arr+n,0);&#x2F;&#x2F;[0,1,2,3,4,...];</code></pre>\n\n<p>随机打乱数组：</p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">srand(time(NULL));\nrandom_shuffle(a+1,a+n+1);</code></pre>\n\n<p><code>random_shuffle</code> 自 C++14 起被弃用，C++17 起被移除。可以使用 <code>shuffle</code> 函数代替：</p>\n<p><code>shuffle(v.begin(),v.end(),rand)</code>（最后一个参数传入的是使用的随机数生成器，一般情况下传入 <code>rand</code> 即可）。</p>\n<p>使用时需要设置随机数种子，配合<code>iota</code>可以实现类似于“洗牌”的效果。同时可进行随机的多次模拟，为了时间种子的不同，可能需要每次模拟间设置<code>sleep</code>间隔。</p>\n<p>参考资料：</p>\n<p>《C++ Primer》 目录</p>\n<p>《C++ Primer Plus》  18.1</p>\n<p>《算法竞赛入门经典习题解答》第一章</p>\n<p><a href=\"http://www.cppblog.com/mzty/archive/2005/12/15/1770.aspx\">http://www.cppblog.com/mzty/archive/2005/12/15/1770.aspx</a></p>\n"},{"title":"C/C++ 多维数组的处理","_content":"\n\n\n笔者要用到多维数组的时候经常忘了多维数组怎么用，在此总结一下：\n\n【内容产出中】\n\n1.二维数组的函数调用实例\n\n```c\n//声明\nvoid bubbleSort(float (*num)[40],int size);\n//调用\nbubbleSort( stu , 40);\n//思想：二维数组——数组的数组\n```\n\n2.把二维数组当一维数组进行赋值：\n\n```c\nint *p=&a[0][0];//获取二维数组首地址\nfor(int i=0;i<6;i++)\n{\nscnaf(\"%d\",p);\np++;\n}\n```\n\n3.使用 C++ 容器时，若可以使用`at`等方法获得对应元素，以缓解运算符`[]`的不稳定性问题。\n\n如： array（C++11）\n\n| 函数         | 作用                                                         |\n| ------------ | ------------------------------------------------------------ |\n| `at`         | 访问指定的元素，同时进行越界检查`at` 若遇 `pos >= size()` 的情况会抛出 `std::out_of_range`。 |\n| `operator[]` | 访问指定的元素，**不** 进行越界检查                          |\n\n4.多维vector的行列空间预留\n\n```\n vector<vector<bool> > table(256);//256行\n table.resize(512);//512列\n```\n\n","source":"_drafts/C中多维数组的处理.md","raw":"---\ntitle: C/C++ 多维数组的处理\n---\n\n\n\n笔者要用到多维数组的时候经常忘了多维数组怎么用，在此总结一下：\n\n【内容产出中】\n\n1.二维数组的函数调用实例\n\n```c\n//声明\nvoid bubbleSort(float (*num)[40],int size);\n//调用\nbubbleSort( stu , 40);\n//思想：二维数组——数组的数组\n```\n\n2.把二维数组当一维数组进行赋值：\n\n```c\nint *p=&a[0][0];//获取二维数组首地址\nfor(int i=0;i<6;i++)\n{\nscnaf(\"%d\",p);\np++;\n}\n```\n\n3.使用 C++ 容器时，若可以使用`at`等方法获得对应元素，以缓解运算符`[]`的不稳定性问题。\n\n如： array（C++11）\n\n| 函数         | 作用                                                         |\n| ------------ | ------------------------------------------------------------ |\n| `at`         | 访问指定的元素，同时进行越界检查`at` 若遇 `pos >= size()` 的情况会抛出 `std::out_of_range`。 |\n| `operator[]` | 访问指定的元素，**不** 进行越界检查                          |\n\n4.多维vector的行列空间预留\n\n```\n vector<vector<bool> > table(256);//256行\n table.resize(512);//512列\n```\n\n","slug":"C中多维数组的处理","published":0,"date":"2022-02-03T12:48:31.991Z","updated":"2021-11-29T15:08:17.177Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckz6z5ofd0002fovv5l0fae0k","content":"<p>笔者要用到多维数组的时候经常忘了多维数组怎么用，在此总结一下：</p>\n<p>【内容产出中】</p>\n<p>1.二维数组的函数调用实例</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">&#x2F;&#x2F;声明\nvoid bubbleSort(float (*num)[40],int size);\n&#x2F;&#x2F;调用\nbubbleSort( stu , 40);\n&#x2F;&#x2F;思想：二维数组——数组的数组</code></pre>\n\n<p>2.把二维数组当一维数组进行赋值：</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">int *p&#x3D;&amp;a[0][0];&#x2F;&#x2F;获取二维数组首地址\nfor(int i&#x3D;0;i&lt;6;i++)\n&#123;\nscnaf(&quot;%d&quot;,p);\np++;\n&#125;</code></pre>\n\n<p>3.使用 C++ 容器时，若可以使用<code>at</code>等方法获得对应元素，以缓解运算符<code>[]</code>的不稳定性问题。</p>\n<p>如： array（C++11）</p>\n<table>\n<thead>\n<tr>\n<th>函数</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>at</code></td>\n<td>访问指定的元素，同时进行越界检查<code>at</code> 若遇 <code>pos &gt;= size()</code> 的情况会抛出 <code>std::out_of_range</code>。</td>\n</tr>\n<tr>\n<td><code>operator[]</code></td>\n<td>访问指定的元素，<strong>不</strong> 进行越界检查</td>\n</tr>\n</tbody></table>\n<p>4.多维vector的行列空间预留</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">vector&lt;vector&lt;bool&gt; &gt; table(256);&#x2F;&#x2F;256行\ntable.resize(512);&#x2F;&#x2F;512列</code></pre>\n\n","site":{"data":{}},"excerpt":"","more":"<p>笔者要用到多维数组的时候经常忘了多维数组怎么用，在此总结一下：</p>\n<p>【内容产出中】</p>\n<p>1.二维数组的函数调用实例</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">&#x2F;&#x2F;声明\nvoid bubbleSort(float (*num)[40],int size);\n&#x2F;&#x2F;调用\nbubbleSort( stu , 40);\n&#x2F;&#x2F;思想：二维数组——数组的数组</code></pre>\n\n<p>2.把二维数组当一维数组进行赋值：</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">int *p&#x3D;&amp;a[0][0];&#x2F;&#x2F;获取二维数组首地址\nfor(int i&#x3D;0;i&lt;6;i++)\n&#123;\nscnaf(&quot;%d&quot;,p);\np++;\n&#125;</code></pre>\n\n<p>3.使用 C++ 容器时，若可以使用<code>at</code>等方法获得对应元素，以缓解运算符<code>[]</code>的不稳定性问题。</p>\n<p>如： array（C++11）</p>\n<table>\n<thead>\n<tr>\n<th>函数</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>at</code></td>\n<td>访问指定的元素，同时进行越界检查<code>at</code> 若遇 <code>pos &gt;= size()</code> 的情况会抛出 <code>std::out_of_range</code>。</td>\n</tr>\n<tr>\n<td><code>operator[]</code></td>\n<td>访问指定的元素，<strong>不</strong> 进行越界检查</td>\n</tr>\n</tbody></table>\n<p>4.多维vector的行列空间预留</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">vector&lt;vector&lt;bool&gt; &gt; table(256);&#x2F;&#x2F;256行\ntable.resize(512);&#x2F;&#x2F;512列</code></pre>\n\n"},{"title":"动态规划初步","_content":"# 动态规划初步\n\n[toc]\n\n\n\n## 基本思路\n\n动态规划实际是“聪明地枚举”，会遍历所有可能的情况。对其中的“剪枝”（不丢失最优解）属于贪心的范畴，可能提高了“溯源”的难度。\n\n首先注意：动态规划不是说一上来就写状态转移方程（直接做“备忘录”），而是逐步分析，如下：\n\n分析最优子结构 -> 递推公式 -> 自底向上求解（初始化、状态转移）\n\n分析技巧： 递归树、状态转移图\n\n调试技巧：打印 dp 数组\n\n如果需要“溯源”，可以开一个新数组标记。\n\n由于需要状态转移，一般数组下标从1开始，对应的`dp`数组也开有“安全空间\"。\n\n### 背包 dp\n\n####背包问题的基本状态转移方程\n\nf[j] 表示处理到当前物品 i 时背包容量为 j 的最大价值，得出以下方程：\n\n![image-20210806174605728](C:\\Users\\ll\\blog\\source\\_posts\\贴图\\20210806dp1.png)\n\n#### 0-1背包问题\n\n注意：关于 j 的循环是逆向的。**为了保证物品i只被放入一次！**从后往前循环，每次取得状态**不会和之前取得状态重合**（也就是要求子问题之间互相独立），这样每种物品就只取一次了。\n\n```C++\nfor (int i = 0; i < n; i++) {\n        for (int j = m; j >= w[i]; j--) {\n            dp[j] = max(dp[j], dp[j - w[i]] + v[i]);\n        }\n    }\n```\n\n#### 0-1背包问题打印方案\n\n对于滚动数组方法，由于少存储了很多数据，所以很难溯源。\n\n我们先来看二维情况下，背包问题的循环遍历顺序：\n\n1.当然，传统地（i++,j++）是可行的。并且可以边读边计算。\n\n2.**先遍历容量，再遍历物品，也是可以的！**虽然两个for循环遍历的次序不同，但是`dp[i][j]`所需要的状态来自左上角，不影响`dp[i][j]`的下标和状态转移。\n\n3.能否**逆序遍历物品**？需要经过小小地修改。此时，用dp[i,j]表示 把第 i, i＋1, i＋2,…, n 个物品装到容量为j的背包中的最大总重量。也就是说，“对称”了一下：\n\n由于下标的意义变化，其状态转移方程也要发生改变：\n\n```cpp\nfor(i = n; i >= 1; i--)\nfor(j = 0; j <= C; j++) \nif(j >= V[i]) \n\td[i][j]=max(d[i+1][j],d[i＋1][j－V[i]]＋W[i]);//！\nelse  \n    d[i][j]= d[i+1][j]；\n```\n\n当然，最后我们的输出的结果也就为最终的 `dp[1][C]`了。\n\n我们可以总结一下：循环的遍历顺序和状态转移的方向最好是对应的！这和我们提到过的子问题之间互相独立也是一致的。\n\n4.能否**逆序遍历容量**？类似于3的思路，但比较难理解，略。\n\n\n\n对于打印方案，可以按照（i++，j++）的方案结合标志数组记录回溯，如果有**字典序最小**的要求，最终需要`reverse`；另一种想法是上面的第3点，不需要`reverse`。以下是示例代码：\n\n```cpp\nint dp[MAX_N][MAX_N];\nint dp_d[MAX_N][MAX_N];\nint N, V;//n - 物品数，v - 容量（体积） w - 价值\nvector<int> w(1, 0);\nvector<int> v(1, 0);\n\nint main() {\n    //INPUT\n    memset(dp, 0, sizeof dp);\n    memset(dp_d, 0, sizeof dp_d);\n\n\t//DP\n    for (int i = N; i > 0; i--) {\n        for (int j = 0; j <= V; j++) {\n            int noti = dp[i + 1][j];\n            int geti = j >= v[i] ? dp[i + 1][j - v[i]] + w[i] : 0;\n            //for (int j = v[i]; j <= V; j++)不可！why？遍历不完全！（dp本质）\n            if (noti > geti) {//不能用>= 不然多解时会出错\n                dp[i][j] = noti;\n                dp_d[i][j] = 1;\n            } else {\n                dp[i][j] = geti;\n                dp_d[i][j] = 2;\n            }\n        }\n    }\n    //DP_D\n    vector<int> ans;\n    int i = 1 ,  j = V;\n    while (i <= N && j > 0) {\n        switch (dp_d[i][j]) {\n            case 1:\n                i++;\n                break;\n            case 2:\n                if (j >= v[i])//一个补丁，bug以后补坑\n                    ans.push_back(i);\n                j -= v[i];\n                i++;\n                break;\n        }\n    }\n    for (auto i : ans) {\n        cout << i << \" \";\n    }\n}\n\n```\n\n\n\n#### 完全背包问题\n\n注意：关于 j 的循环是正向的。\n\n```\nfor (int i = 0; i < m; i++) {\n        for (int j = t[i]; j <= T; j++) {\n            dp[j] = max(dp[j], dp[j - t[i]] + v[i]);\n        }\n    }\n```\n\nTips：解题时，注意数据范围，选择合适的数据结构（eg.long long，_int128）。\n\n**完全背包和 01 背包的区别就在于对容量限制枚举的顺序不同**\n\n原因：0-1背包问题的状态转移利用的是“上一个状态”，完全背包利用的是“当前状态”。\n\n\n\n","source":"_drafts/动态规划初步.md","raw":"---\ntitle:\t\t动态规划初步\ntags:\t\tdp\ncategories:\t算法基础\t\npermalink:  https://oi-wiki.org/dp/knapsack/\t\n---\n# 动态规划初步\n\n[toc]\n\n\n\n## 基本思路\n\n动态规划实际是“聪明地枚举”，会遍历所有可能的情况。对其中的“剪枝”（不丢失最优解）属于贪心的范畴，可能提高了“溯源”的难度。\n\n首先注意：动态规划不是说一上来就写状态转移方程（直接做“备忘录”），而是逐步分析，如下：\n\n分析最优子结构 -> 递推公式 -> 自底向上求解（初始化、状态转移）\n\n分析技巧： 递归树、状态转移图\n\n调试技巧：打印 dp 数组\n\n如果需要“溯源”，可以开一个新数组标记。\n\n由于需要状态转移，一般数组下标从1开始，对应的`dp`数组也开有“安全空间\"。\n\n### 背包 dp\n\n####背包问题的基本状态转移方程\n\nf[j] 表示处理到当前物品 i 时背包容量为 j 的最大价值，得出以下方程：\n\n![image-20210806174605728](C:\\Users\\ll\\blog\\source\\_posts\\贴图\\20210806dp1.png)\n\n#### 0-1背包问题\n\n注意：关于 j 的循环是逆向的。**为了保证物品i只被放入一次！**从后往前循环，每次取得状态**不会和之前取得状态重合**（也就是要求子问题之间互相独立），这样每种物品就只取一次了。\n\n```C++\nfor (int i = 0; i < n; i++) {\n        for (int j = m; j >= w[i]; j--) {\n            dp[j] = max(dp[j], dp[j - w[i]] + v[i]);\n        }\n    }\n```\n\n#### 0-1背包问题打印方案\n\n对于滚动数组方法，由于少存储了很多数据，所以很难溯源。\n\n我们先来看二维情况下，背包问题的循环遍历顺序：\n\n1.当然，传统地（i++,j++）是可行的。并且可以边读边计算。\n\n2.**先遍历容量，再遍历物品，也是可以的！**虽然两个for循环遍历的次序不同，但是`dp[i][j]`所需要的状态来自左上角，不影响`dp[i][j]`的下标和状态转移。\n\n3.能否**逆序遍历物品**？需要经过小小地修改。此时，用dp[i,j]表示 把第 i, i＋1, i＋2,…, n 个物品装到容量为j的背包中的最大总重量。也就是说，“对称”了一下：\n\n由于下标的意义变化，其状态转移方程也要发生改变：\n\n```cpp\nfor(i = n; i >= 1; i--)\nfor(j = 0; j <= C; j++) \nif(j >= V[i]) \n\td[i][j]=max(d[i+1][j],d[i＋1][j－V[i]]＋W[i]);//！\nelse  \n    d[i][j]= d[i+1][j]；\n```\n\n当然，最后我们的输出的结果也就为最终的 `dp[1][C]`了。\n\n我们可以总结一下：循环的遍历顺序和状态转移的方向最好是对应的！这和我们提到过的子问题之间互相独立也是一致的。\n\n4.能否**逆序遍历容量**？类似于3的思路，但比较难理解，略。\n\n\n\n对于打印方案，可以按照（i++，j++）的方案结合标志数组记录回溯，如果有**字典序最小**的要求，最终需要`reverse`；另一种想法是上面的第3点，不需要`reverse`。以下是示例代码：\n\n```cpp\nint dp[MAX_N][MAX_N];\nint dp_d[MAX_N][MAX_N];\nint N, V;//n - 物品数，v - 容量（体积） w - 价值\nvector<int> w(1, 0);\nvector<int> v(1, 0);\n\nint main() {\n    //INPUT\n    memset(dp, 0, sizeof dp);\n    memset(dp_d, 0, sizeof dp_d);\n\n\t//DP\n    for (int i = N; i > 0; i--) {\n        for (int j = 0; j <= V; j++) {\n            int noti = dp[i + 1][j];\n            int geti = j >= v[i] ? dp[i + 1][j - v[i]] + w[i] : 0;\n            //for (int j = v[i]; j <= V; j++)不可！why？遍历不完全！（dp本质）\n            if (noti > geti) {//不能用>= 不然多解时会出错\n                dp[i][j] = noti;\n                dp_d[i][j] = 1;\n            } else {\n                dp[i][j] = geti;\n                dp_d[i][j] = 2;\n            }\n        }\n    }\n    //DP_D\n    vector<int> ans;\n    int i = 1 ,  j = V;\n    while (i <= N && j > 0) {\n        switch (dp_d[i][j]) {\n            case 1:\n                i++;\n                break;\n            case 2:\n                if (j >= v[i])//一个补丁，bug以后补坑\n                    ans.push_back(i);\n                j -= v[i];\n                i++;\n                break;\n        }\n    }\n    for (auto i : ans) {\n        cout << i << \" \";\n    }\n}\n\n```\n\n\n\n#### 完全背包问题\n\n注意：关于 j 的循环是正向的。\n\n```\nfor (int i = 0; i < m; i++) {\n        for (int j = t[i]; j <= T; j++) {\n            dp[j] = max(dp[j], dp[j - t[i]] + v[i]);\n        }\n    }\n```\n\nTips：解题时，注意数据范围，选择合适的数据结构（eg.long long，_int128）。\n\n**完全背包和 01 背包的区别就在于对容量限制枚举的顺序不同**\n\n原因：0-1背包问题的状态转移利用的是“上一个状态”，完全背包利用的是“当前状态”。\n\n\n\n","slug":"动态规划初步","published":0,"date":"2022-02-03T12:48:31.996Z","updated":"2021-11-24T07:31:52.238Z","__permalink":"https://oi-wiki.org/dp/knapsack/","comments":1,"layout":"post","photos":[],"link":"","_id":"ckz6z5ofe0004fovv4c8m2i5z","content":"<h1 id=\"动态规划初步\"><a href=\"#动态规划初步\" class=\"headerlink\" title=\"动态规划初步\"></a>动态规划初步</h1><p>[toc]</p>\n<h2 id=\"基本思路\"><a href=\"#基本思路\" class=\"headerlink\" title=\"基本思路\"></a>基本思路</h2><p>动态规划实际是“聪明地枚举”，会遍历所有可能的情况。对其中的“剪枝”（不丢失最优解）属于贪心的范畴，可能提高了“溯源”的难度。</p>\n<p>首先注意：动态规划不是说一上来就写状态转移方程（直接做“备忘录”），而是逐步分析，如下：</p>\n<p>分析最优子结构 -&gt; 递推公式 -&gt; 自底向上求解（初始化、状态转移）</p>\n<p>分析技巧： 递归树、状态转移图</p>\n<p>调试技巧：打印 dp 数组</p>\n<p>如果需要“溯源”，可以开一个新数组标记。</p>\n<p>由于需要状态转移，一般数组下标从1开始，对应的<code>dp</code>数组也开有“安全空间”。</p>\n<h3 id=\"背包-dp\"><a href=\"#背包-dp\" class=\"headerlink\" title=\"背包 dp\"></a>背包 dp</h3><p>####背包问题的基本状态转移方程</p>\n<p>f[j] 表示处理到当前物品 i 时背包容量为 j 的最大价值，得出以下方程：</p>\n<p><img src=\"C:\\Users\\ll\\blog\\source_posts\\贴图\\20210806dp1.png\" alt=\"image-20210806174605728\"></p>\n<h4 id=\"0-1背包问题\"><a href=\"#0-1背包问题\" class=\"headerlink\" title=\"0-1背包问题\"></a>0-1背包问题</h4><p>注意：关于 j 的循环是逆向的。<strong>为了保证物品i只被放入一次！</strong>从后往前循环，每次取得状态<strong>不会和之前取得状态重合</strong>（也就是要求子问题之间互相独立），这样每种物品就只取一次了。</p>\n<pre class=\"line-numbers language-C++\" data-language=\"C++\"><code class=\"language-C++\">for (int i &#x3D; 0; i &lt; n; i++) &#123;\n        for (int j &#x3D; m; j &gt;&#x3D; w[i]; j--) &#123;\n            dp[j] &#x3D; max(dp[j], dp[j - w[i]] + v[i]);\n        &#125;\n    &#125;</code></pre>\n\n<h4 id=\"0-1背包问题打印方案\"><a href=\"#0-1背包问题打印方案\" class=\"headerlink\" title=\"0-1背包问题打印方案\"></a>0-1背包问题打印方案</h4><p>对于滚动数组方法，由于少存储了很多数据，所以很难溯源。</p>\n<p>我们先来看二维情况下，背包问题的循环遍历顺序：</p>\n<p>1.当然，传统地（i++,j++）是可行的。并且可以边读边计算。</p>\n<p>2.<strong>先遍历容量，再遍历物品，也是可以的！</strong>虽然两个for循环遍历的次序不同，但是<code>dp[i][j]</code>所需要的状态来自左上角，不影响<code>dp[i][j]</code>的下标和状态转移。</p>\n<p>3.能否<strong>逆序遍历物品</strong>？需要经过小小地修改。此时，用dp[i,j]表示 把第 i, i＋1, i＋2,…, n 个物品装到容量为j的背包中的最大总重量。也就是说，“对称”了一下：</p>\n<p>由于下标的意义变化，其状态转移方程也要发生改变：</p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">for(i &#x3D; n; i &gt;&#x3D; 1; i--)\nfor(j &#x3D; 0; j &lt;&#x3D; C; j++) \nif(j &gt;&#x3D; V[i]) \n\td[i][j]&#x3D;max(d[i+1][j],d[i＋1][j－V[i]]＋W[i]);&#x2F;&#x2F;！\nelse  \n    d[i][j]&#x3D; d[i+1][j]；</code></pre>\n\n<p>当然，最后我们的输出的结果也就为最终的 <code>dp[1][C]</code>了。</p>\n<p>我们可以总结一下：循环的遍历顺序和状态转移的方向最好是对应的！这和我们提到过的子问题之间互相独立也是一致的。</p>\n<p>4.能否<strong>逆序遍历容量</strong>？类似于3的思路，但比较难理解，略。</p>\n<p>对于打印方案，可以按照（i++，j++）的方案结合标志数组记录回溯，如果有<strong>字典序最小</strong>的要求，最终需要<code>reverse</code>；另一种想法是上面的第3点，不需要<code>reverse</code>。以下是示例代码：</p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">int dp[MAX_N][MAX_N];\nint dp_d[MAX_N][MAX_N];\nint N, V;&#x2F;&#x2F;n - 物品数，v - 容量（体积） w - 价值\nvector&lt;int&gt; w(1, 0);\nvector&lt;int&gt; v(1, 0);\n\nint main() &#123;\n    &#x2F;&#x2F;INPUT\n    memset(dp, 0, sizeof dp);\n    memset(dp_d, 0, sizeof dp_d);\n\n\t&#x2F;&#x2F;DP\n    for (int i &#x3D; N; i &gt; 0; i--) &#123;\n        for (int j &#x3D; 0; j &lt;&#x3D; V; j++) &#123;\n            int noti &#x3D; dp[i + 1][j];\n            int geti &#x3D; j &gt;&#x3D; v[i] ? dp[i + 1][j - v[i]] + w[i] : 0;\n            &#x2F;&#x2F;for (int j &#x3D; v[i]; j &lt;&#x3D; V; j++)不可！why？遍历不完全！（dp本质）\n            if (noti &gt; geti) &#123;&#x2F;&#x2F;不能用&gt;&#x3D; 不然多解时会出错\n                dp[i][j] &#x3D; noti;\n                dp_d[i][j] &#x3D; 1;\n            &#125; else &#123;\n                dp[i][j] &#x3D; geti;\n                dp_d[i][j] &#x3D; 2;\n            &#125;\n        &#125;\n    &#125;\n    &#x2F;&#x2F;DP_D\n    vector&lt;int&gt; ans;\n    int i &#x3D; 1 ,  j &#x3D; V;\n    while (i &lt;&#x3D; N &amp;&amp; j &gt; 0) &#123;\n        switch (dp_d[i][j]) &#123;\n            case 1:\n                i++;\n                break;\n            case 2:\n                if (j &gt;&#x3D; v[i])&#x2F;&#x2F;一个补丁，bug以后补坑\n                    ans.push_back(i);\n                j -&#x3D; v[i];\n                i++;\n                break;\n        &#125;\n    &#125;\n    for (auto i : ans) &#123;\n        cout &lt;&lt; i &lt;&lt; &quot; &quot;;\n    &#125;\n&#125;\n</code></pre>\n\n\n\n<h4 id=\"完全背包问题\"><a href=\"#完全背包问题\" class=\"headerlink\" title=\"完全背包问题\"></a>完全背包问题</h4><p>注意：关于 j 的循环是正向的。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">for (int i &#x3D; 0; i &lt; m; i++) &#123;\n        for (int j &#x3D; t[i]; j &lt;&#x3D; T; j++) &#123;\n            dp[j] &#x3D; max(dp[j], dp[j - t[i]] + v[i]);\n        &#125;\n    &#125;</code></pre>\n\n<p>Tips：解题时，注意数据范围，选择合适的数据结构（eg.long long，_int128）。</p>\n<p><strong>完全背包和 01 背包的区别就在于对容量限制枚举的顺序不同</strong></p>\n<p>原因：0-1背包问题的状态转移利用的是“上一个状态”，完全背包利用的是“当前状态”。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"动态规划初步\"><a href=\"#动态规划初步\" class=\"headerlink\" title=\"动态规划初步\"></a>动态规划初步</h1><p>[toc]</p>\n<h2 id=\"基本思路\"><a href=\"#基本思路\" class=\"headerlink\" title=\"基本思路\"></a>基本思路</h2><p>动态规划实际是“聪明地枚举”，会遍历所有可能的情况。对其中的“剪枝”（不丢失最优解）属于贪心的范畴，可能提高了“溯源”的难度。</p>\n<p>首先注意：动态规划不是说一上来就写状态转移方程（直接做“备忘录”），而是逐步分析，如下：</p>\n<p>分析最优子结构 -&gt; 递推公式 -&gt; 自底向上求解（初始化、状态转移）</p>\n<p>分析技巧： 递归树、状态转移图</p>\n<p>调试技巧：打印 dp 数组</p>\n<p>如果需要“溯源”，可以开一个新数组标记。</p>\n<p>由于需要状态转移，一般数组下标从1开始，对应的<code>dp</code>数组也开有“安全空间”。</p>\n<h3 id=\"背包-dp\"><a href=\"#背包-dp\" class=\"headerlink\" title=\"背包 dp\"></a>背包 dp</h3><p>####背包问题的基本状态转移方程</p>\n<p>f[j] 表示处理到当前物品 i 时背包容量为 j 的最大价值，得出以下方程：</p>\n<p><img src=\"C:\\Users\\ll\\blog\\source_posts\\贴图\\20210806dp1.png\" alt=\"image-20210806174605728\"></p>\n<h4 id=\"0-1背包问题\"><a href=\"#0-1背包问题\" class=\"headerlink\" title=\"0-1背包问题\"></a>0-1背包问题</h4><p>注意：关于 j 的循环是逆向的。<strong>为了保证物品i只被放入一次！</strong>从后往前循环，每次取得状态<strong>不会和之前取得状态重合</strong>（也就是要求子问题之间互相独立），这样每种物品就只取一次了。</p>\n<pre class=\"line-numbers language-C++\" data-language=\"C++\"><code class=\"language-C++\">for (int i &#x3D; 0; i &lt; n; i++) &#123;\n        for (int j &#x3D; m; j &gt;&#x3D; w[i]; j--) &#123;\n            dp[j] &#x3D; max(dp[j], dp[j - w[i]] + v[i]);\n        &#125;\n    &#125;</code></pre>\n\n<h4 id=\"0-1背包问题打印方案\"><a href=\"#0-1背包问题打印方案\" class=\"headerlink\" title=\"0-1背包问题打印方案\"></a>0-1背包问题打印方案</h4><p>对于滚动数组方法，由于少存储了很多数据，所以很难溯源。</p>\n<p>我们先来看二维情况下，背包问题的循环遍历顺序：</p>\n<p>1.当然，传统地（i++,j++）是可行的。并且可以边读边计算。</p>\n<p>2.<strong>先遍历容量，再遍历物品，也是可以的！</strong>虽然两个for循环遍历的次序不同，但是<code>dp[i][j]</code>所需要的状态来自左上角，不影响<code>dp[i][j]</code>的下标和状态转移。</p>\n<p>3.能否<strong>逆序遍历物品</strong>？需要经过小小地修改。此时，用dp[i,j]表示 把第 i, i＋1, i＋2,…, n 个物品装到容量为j的背包中的最大总重量。也就是说，“对称”了一下：</p>\n<p>由于下标的意义变化，其状态转移方程也要发生改变：</p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">for(i &#x3D; n; i &gt;&#x3D; 1; i--)\nfor(j &#x3D; 0; j &lt;&#x3D; C; j++) \nif(j &gt;&#x3D; V[i]) \n\td[i][j]&#x3D;max(d[i+1][j],d[i＋1][j－V[i]]＋W[i]);&#x2F;&#x2F;！\nelse  \n    d[i][j]&#x3D; d[i+1][j]；</code></pre>\n\n<p>当然，最后我们的输出的结果也就为最终的 <code>dp[1][C]</code>了。</p>\n<p>我们可以总结一下：循环的遍历顺序和状态转移的方向最好是对应的！这和我们提到过的子问题之间互相独立也是一致的。</p>\n<p>4.能否<strong>逆序遍历容量</strong>？类似于3的思路，但比较难理解，略。</p>\n<p>对于打印方案，可以按照（i++，j++）的方案结合标志数组记录回溯，如果有<strong>字典序最小</strong>的要求，最终需要<code>reverse</code>；另一种想法是上面的第3点，不需要<code>reverse</code>。以下是示例代码：</p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">int dp[MAX_N][MAX_N];\nint dp_d[MAX_N][MAX_N];\nint N, V;&#x2F;&#x2F;n - 物品数，v - 容量（体积） w - 价值\nvector&lt;int&gt; w(1, 0);\nvector&lt;int&gt; v(1, 0);\n\nint main() &#123;\n    &#x2F;&#x2F;INPUT\n    memset(dp, 0, sizeof dp);\n    memset(dp_d, 0, sizeof dp_d);\n\n\t&#x2F;&#x2F;DP\n    for (int i &#x3D; N; i &gt; 0; i--) &#123;\n        for (int j &#x3D; 0; j &lt;&#x3D; V; j++) &#123;\n            int noti &#x3D; dp[i + 1][j];\n            int geti &#x3D; j &gt;&#x3D; v[i] ? dp[i + 1][j - v[i]] + w[i] : 0;\n            &#x2F;&#x2F;for (int j &#x3D; v[i]; j &lt;&#x3D; V; j++)不可！why？遍历不完全！（dp本质）\n            if (noti &gt; geti) &#123;&#x2F;&#x2F;不能用&gt;&#x3D; 不然多解时会出错\n                dp[i][j] &#x3D; noti;\n                dp_d[i][j] &#x3D; 1;\n            &#125; else &#123;\n                dp[i][j] &#x3D; geti;\n                dp_d[i][j] &#x3D; 2;\n            &#125;\n        &#125;\n    &#125;\n    &#x2F;&#x2F;DP_D\n    vector&lt;int&gt; ans;\n    int i &#x3D; 1 ,  j &#x3D; V;\n    while (i &lt;&#x3D; N &amp;&amp; j &gt; 0) &#123;\n        switch (dp_d[i][j]) &#123;\n            case 1:\n                i++;\n                break;\n            case 2:\n                if (j &gt;&#x3D; v[i])&#x2F;&#x2F;一个补丁，bug以后补坑\n                    ans.push_back(i);\n                j -&#x3D; v[i];\n                i++;\n                break;\n        &#125;\n    &#125;\n    for (auto i : ans) &#123;\n        cout &lt;&lt; i &lt;&lt; &quot; &quot;;\n    &#125;\n&#125;\n</code></pre>\n\n\n\n<h4 id=\"完全背包问题\"><a href=\"#完全背包问题\" class=\"headerlink\" title=\"完全背包问题\"></a>完全背包问题</h4><p>注意：关于 j 的循环是正向的。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">for (int i &#x3D; 0; i &lt; m; i++) &#123;\n        for (int j &#x3D; t[i]; j &lt;&#x3D; T; j++) &#123;\n            dp[j] &#x3D; max(dp[j], dp[j - t[i]] + v[i]);\n        &#125;\n    &#125;</code></pre>\n\n<p>Tips：解题时，注意数据范围，选择合适的数据结构（eg.long long，_int128）。</p>\n<p><strong>完全背包和 01 背包的区别就在于对容量限制枚举的顺序不同</strong></p>\n<p>原因：0-1背包问题的状态转移利用的是“上一个状态”，完全背包利用的是“当前状态”。</p>\n"},{"_content":"","source":"_drafts/函数式编程导论.md","raw":"","slug":"函数式编程导论","published":0,"date":"2022-02-03T12:48:32.002Z","updated":"2021-11-26T01:27:06.727Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"ckz6z5off0005fovv9spgho7w","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"动态规划的优化","_content":"## 动态规划的优化策略\n\n### 单调队列/单调栈优化\n\n#### 单调队列\n\neg.[[Poj2823 - 滑动窗口](http://poj.org/problem?id=2823)]给予一个长度为n的数组，输出每k个连续元素中的最大值和最小值。\n\n解：使用STL容器deque，维护一个单调的数列。以求最小值为例，操作包括：\n\n序列例：1 3 -1 -3 5 3 6 7。\n\n维护递增的队列，操作如下：\n\n| 操作                                                   | 队列状态  |\n| :----------------------------------------------------- | :-------- |\n| 1 入队                                                 | `{1}`     |\n| 3 比 1 大，3 入队                                      | `{1 3}`   |\n| -1 比队列中所有元素小，所以队列被清空， -1 入队        | `{-1}`    |\n| -3 比队列中所有元素小，所以队列被清空， -3 入队        | `{-3}`    |\n| 5 比 -3 大，直接入队                                   | `{-3 5}`  |\n| 3 比 5 小，5 出队，3 入队                              | `{-3 3}`  |\n| -3 已经在窗体外(越界)，所以 -3 出队；6 比 3 大，6 入队 | `{3 6}`   |\n| 7 比 6 大，7 入队                                      | `{3 6 7}` |\n\n即包括：\n\n1.当满足“若待入列数比先进列的数还要小”，可将其前面的数尽数 \"弹出\"，再将该数 push 进队尾。因此，前面的数先出列，不可能是最大值。\n\n2.需要 site 数组记录第 i 个队中的数在原数组中的位置，以弹出越界的队头。\n\n3.输出时只需输出队头即可。\n\n```C++\n    for (int i = 0; i < m; i++) {\n        if (i >= n - 1) {\n            while (!que.empty() && que.front().second <= i - n) {\n                que.pop_front();\n            }\n        }\n        while (!que.empty() && a[i] < que.back().first) {\n            que.pop_back();\n        }\n        que.push_back(P(a[i], i));\n        if (i >= n - 1)\n            cout << que.front().first << \" \";\n    }\n```\n\n####单调栈\n\n与单调队列相比，其只在一端进行进出。单调队列主要处理的是一个区间内的最大/小值，而单调栈处理的是寻找以某个值为最小/大值的最大区间。参考[lucky52529的博客](https://blog.csdn.net/lucky52529/article/details/89155694)\n\n```\nfor (遍历)\n{\n\tif (栈空 || 栈顶元素大于等于当前比较元素)\n\t\t入栈;\n\telse{\n\t\twhile (栈不为空 && 栈顶元素小于当前元素){\n\t\t\t栈顶元素出栈;\n\t\t\t更新结果;\n\t\t}\n\t\t当前数据入栈;\n\t}\n}\n```\n\n\n\n其中需要注意的是：\n\n1.对于某些特殊题目，栈内元素出不完，遗留在栈里面的人还没有考虑，导致答案错误，这时候我们要添加结束标识符强制清空栈。比如：\n\n```\nvec.push_back(INF);//对于单调递增栈（栈顶最小），补充结束标识符，使最后清空栈\n```\n\n2.我们进行栈的处理时，是在出栈操作时进行的。\n\n模板题练习：[[洛谷P5788](https://www.luogu.com.cn/problem/P5788)]\n\n```\n\n```\n\n\n\n\n\n\n\n","source":"_drafts/动态规划优化.md","raw":"---\ntitle:\t\t动态规划的优化\ntags:\t\tdp\t\ncategories:\t算法进阶\n---\n## 动态规划的优化策略\n\n### 单调队列/单调栈优化\n\n#### 单调队列\n\neg.[[Poj2823 - 滑动窗口](http://poj.org/problem?id=2823)]给予一个长度为n的数组，输出每k个连续元素中的最大值和最小值。\n\n解：使用STL容器deque，维护一个单调的数列。以求最小值为例，操作包括：\n\n序列例：1 3 -1 -3 5 3 6 7。\n\n维护递增的队列，操作如下：\n\n| 操作                                                   | 队列状态  |\n| :----------------------------------------------------- | :-------- |\n| 1 入队                                                 | `{1}`     |\n| 3 比 1 大，3 入队                                      | `{1 3}`   |\n| -1 比队列中所有元素小，所以队列被清空， -1 入队        | `{-1}`    |\n| -3 比队列中所有元素小，所以队列被清空， -3 入队        | `{-3}`    |\n| 5 比 -3 大，直接入队                                   | `{-3 5}`  |\n| 3 比 5 小，5 出队，3 入队                              | `{-3 3}`  |\n| -3 已经在窗体外(越界)，所以 -3 出队；6 比 3 大，6 入队 | `{3 6}`   |\n| 7 比 6 大，7 入队                                      | `{3 6 7}` |\n\n即包括：\n\n1.当满足“若待入列数比先进列的数还要小”，可将其前面的数尽数 \"弹出\"，再将该数 push 进队尾。因此，前面的数先出列，不可能是最大值。\n\n2.需要 site 数组记录第 i 个队中的数在原数组中的位置，以弹出越界的队头。\n\n3.输出时只需输出队头即可。\n\n```C++\n    for (int i = 0; i < m; i++) {\n        if (i >= n - 1) {\n            while (!que.empty() && que.front().second <= i - n) {\n                que.pop_front();\n            }\n        }\n        while (!que.empty() && a[i] < que.back().first) {\n            que.pop_back();\n        }\n        que.push_back(P(a[i], i));\n        if (i >= n - 1)\n            cout << que.front().first << \" \";\n    }\n```\n\n####单调栈\n\n与单调队列相比，其只在一端进行进出。单调队列主要处理的是一个区间内的最大/小值，而单调栈处理的是寻找以某个值为最小/大值的最大区间。参考[lucky52529的博客](https://blog.csdn.net/lucky52529/article/details/89155694)\n\n```\nfor (遍历)\n{\n\tif (栈空 || 栈顶元素大于等于当前比较元素)\n\t\t入栈;\n\telse{\n\t\twhile (栈不为空 && 栈顶元素小于当前元素){\n\t\t\t栈顶元素出栈;\n\t\t\t更新结果;\n\t\t}\n\t\t当前数据入栈;\n\t}\n}\n```\n\n\n\n其中需要注意的是：\n\n1.对于某些特殊题目，栈内元素出不完，遗留在栈里面的人还没有考虑，导致答案错误，这时候我们要添加结束标识符强制清空栈。比如：\n\n```\nvec.push_back(INF);//对于单调递增栈（栈顶最小），补充结束标识符，使最后清空栈\n```\n\n2.我们进行栈的处理时，是在出栈操作时进行的。\n\n模板题练习：[[洛谷P5788](https://www.luogu.com.cn/problem/P5788)]\n\n```\n\n```\n\n\n\n\n\n\n\n","slug":"动态规划优化","published":0,"date":"2022-02-03T12:48:31.998Z","updated":"2021-08-07T07:47:49.093Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckz6z5ofh0009fovv4tvw1s3x","content":"<h2 id=\"动态规划的优化策略\"><a href=\"#动态规划的优化策略\" class=\"headerlink\" title=\"动态规划的优化策略\"></a>动态规划的优化策略</h2><h3 id=\"单调队列-单调栈优化\"><a href=\"#单调队列-单调栈优化\" class=\"headerlink\" title=\"单调队列/单调栈优化\"></a>单调队列/单调栈优化</h3><h4 id=\"单调队列\"><a href=\"#单调队列\" class=\"headerlink\" title=\"单调队列\"></a>单调队列</h4><p>eg.[<a href=\"http://poj.org/problem?id=2823\">Poj2823 - 滑动窗口</a>]给予一个长度为n的数组，输出每k个连续元素中的最大值和最小值。</p>\n<p>解：使用STL容器deque，维护一个单调的数列。以求最小值为例，操作包括：</p>\n<p>序列例：1 3 -1 -3 5 3 6 7。</p>\n<p>维护递增的队列，操作如下：</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">操作</th>\n<th align=\"left\">队列状态</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">1 入队</td>\n<td align=\"left\"><code>&#123;1&#125;</code></td>\n</tr>\n<tr>\n<td align=\"left\">3 比 1 大，3 入队</td>\n<td align=\"left\"><code>&#123;1 3&#125;</code></td>\n</tr>\n<tr>\n<td align=\"left\">-1 比队列中所有元素小，所以队列被清空， -1 入队</td>\n<td align=\"left\"><code>&#123;-1&#125;</code></td>\n</tr>\n<tr>\n<td align=\"left\">-3 比队列中所有元素小，所以队列被清空， -3 入队</td>\n<td align=\"left\"><code>&#123;-3&#125;</code></td>\n</tr>\n<tr>\n<td align=\"left\">5 比 -3 大，直接入队</td>\n<td align=\"left\"><code>&#123;-3 5&#125;</code></td>\n</tr>\n<tr>\n<td align=\"left\">3 比 5 小，5 出队，3 入队</td>\n<td align=\"left\"><code>&#123;-3 3&#125;</code></td>\n</tr>\n<tr>\n<td align=\"left\">-3 已经在窗体外(越界)，所以 -3 出队；6 比 3 大，6 入队</td>\n<td align=\"left\"><code>&#123;3 6&#125;</code></td>\n</tr>\n<tr>\n<td align=\"left\">7 比 6 大，7 入队</td>\n<td align=\"left\"><code>&#123;3 6 7&#125;</code></td>\n</tr>\n</tbody></table>\n<p>即包括：</p>\n<p>1.当满足“若待入列数比先进列的数还要小”，可将其前面的数尽数 “弹出”，再将该数 push 进队尾。因此，前面的数先出列，不可能是最大值。</p>\n<p>2.需要 site 数组记录第 i 个队中的数在原数组中的位置，以弹出越界的队头。</p>\n<p>3.输出时只需输出队头即可。</p>\n<pre class=\"line-numbers language-C++\" data-language=\"C++\"><code class=\"language-C++\">for (int i &#x3D; 0; i &lt; m; i++) &#123;\n    if (i &gt;&#x3D; n - 1) &#123;\n        while (!que.empty() &amp;&amp; que.front().second &lt;&#x3D; i - n) &#123;\n            que.pop_front();\n        &#125;\n    &#125;\n    while (!que.empty() &amp;&amp; a[i] &lt; que.back().first) &#123;\n        que.pop_back();\n    &#125;\n    que.push_back(P(a[i], i));\n    if (i &gt;&#x3D; n - 1)\n        cout &lt;&lt; que.front().first &lt;&lt; &quot; &quot;;\n&#125;</code></pre>\n\n<p>####单调栈</p>\n<p>与单调队列相比，其只在一端进行进出。单调队列主要处理的是一个区间内的最大/小值，而单调栈处理的是寻找以某个值为最小/大值的最大区间。参考<a href=\"https://blog.csdn.net/lucky52529/article/details/89155694\">lucky52529的博客</a></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">for (遍历)\n&#123;\n\tif (栈空 || 栈顶元素大于等于当前比较元素)\n\t\t入栈;\n\telse&#123;\n\t\twhile (栈不为空 &amp;&amp; 栈顶元素小于当前元素)&#123;\n\t\t\t栈顶元素出栈;\n\t\t\t更新结果;\n\t\t&#125;\n\t\t当前数据入栈;\n\t&#125;\n&#125;</code></pre>\n\n\n\n<p>其中需要注意的是：</p>\n<p>1.对于某些特殊题目，栈内元素出不完，遗留在栈里面的人还没有考虑，导致答案错误，这时候我们要添加结束标识符强制清空栈。比如：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">vec.push_back(INF);&#x2F;&#x2F;对于单调递增栈（栈顶最小），补充结束标识符，使最后清空栈</code></pre>\n\n<p>2.我们进行栈的处理时，是在出栈操作时进行的。</p>\n<p>模板题练习：[<a href=\"https://www.luogu.com.cn/problem/P5788\">洛谷P5788</a>]</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\"></code></pre>\n\n\n\n\n\n\n\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"动态规划的优化策略\"><a href=\"#动态规划的优化策略\" class=\"headerlink\" title=\"动态规划的优化策略\"></a>动态规划的优化策略</h2><h3 id=\"单调队列-单调栈优化\"><a href=\"#单调队列-单调栈优化\" class=\"headerlink\" title=\"单调队列/单调栈优化\"></a>单调队列/单调栈优化</h3><h4 id=\"单调队列\"><a href=\"#单调队列\" class=\"headerlink\" title=\"单调队列\"></a>单调队列</h4><p>eg.[<a href=\"http://poj.org/problem?id=2823\">Poj2823 - 滑动窗口</a>]给予一个长度为n的数组，输出每k个连续元素中的最大值和最小值。</p>\n<p>解：使用STL容器deque，维护一个单调的数列。以求最小值为例，操作包括：</p>\n<p>序列例：1 3 -1 -3 5 3 6 7。</p>\n<p>维护递增的队列，操作如下：</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">操作</th>\n<th align=\"left\">队列状态</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">1 入队</td>\n<td align=\"left\"><code>&#123;1&#125;</code></td>\n</tr>\n<tr>\n<td align=\"left\">3 比 1 大，3 入队</td>\n<td align=\"left\"><code>&#123;1 3&#125;</code></td>\n</tr>\n<tr>\n<td align=\"left\">-1 比队列中所有元素小，所以队列被清空， -1 入队</td>\n<td align=\"left\"><code>&#123;-1&#125;</code></td>\n</tr>\n<tr>\n<td align=\"left\">-3 比队列中所有元素小，所以队列被清空， -3 入队</td>\n<td align=\"left\"><code>&#123;-3&#125;</code></td>\n</tr>\n<tr>\n<td align=\"left\">5 比 -3 大，直接入队</td>\n<td align=\"left\"><code>&#123;-3 5&#125;</code></td>\n</tr>\n<tr>\n<td align=\"left\">3 比 5 小，5 出队，3 入队</td>\n<td align=\"left\"><code>&#123;-3 3&#125;</code></td>\n</tr>\n<tr>\n<td align=\"left\">-3 已经在窗体外(越界)，所以 -3 出队；6 比 3 大，6 入队</td>\n<td align=\"left\"><code>&#123;3 6&#125;</code></td>\n</tr>\n<tr>\n<td align=\"left\">7 比 6 大，7 入队</td>\n<td align=\"left\"><code>&#123;3 6 7&#125;</code></td>\n</tr>\n</tbody></table>\n<p>即包括：</p>\n<p>1.当满足“若待入列数比先进列的数还要小”，可将其前面的数尽数 “弹出”，再将该数 push 进队尾。因此，前面的数先出列，不可能是最大值。</p>\n<p>2.需要 site 数组记录第 i 个队中的数在原数组中的位置，以弹出越界的队头。</p>\n<p>3.输出时只需输出队头即可。</p>\n<pre class=\"line-numbers language-C++\" data-language=\"C++\"><code class=\"language-C++\">for (int i &#x3D; 0; i &lt; m; i++) &#123;\n    if (i &gt;&#x3D; n - 1) &#123;\n        while (!que.empty() &amp;&amp; que.front().second &lt;&#x3D; i - n) &#123;\n            que.pop_front();\n        &#125;\n    &#125;\n    while (!que.empty() &amp;&amp; a[i] &lt; que.back().first) &#123;\n        que.pop_back();\n    &#125;\n    que.push_back(P(a[i], i));\n    if (i &gt;&#x3D; n - 1)\n        cout &lt;&lt; que.front().first &lt;&lt; &quot; &quot;;\n&#125;</code></pre>\n\n<p>####单调栈</p>\n<p>与单调队列相比，其只在一端进行进出。单调队列主要处理的是一个区间内的最大/小值，而单调栈处理的是寻找以某个值为最小/大值的最大区间。参考<a href=\"https://blog.csdn.net/lucky52529/article/details/89155694\">lucky52529的博客</a></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">for (遍历)\n&#123;\n\tif (栈空 || 栈顶元素大于等于当前比较元素)\n\t\t入栈;\n\telse&#123;\n\t\twhile (栈不为空 &amp;&amp; 栈顶元素小于当前元素)&#123;\n\t\t\t栈顶元素出栈;\n\t\t\t更新结果;\n\t\t&#125;\n\t\t当前数据入栈;\n\t&#125;\n&#125;</code></pre>\n\n\n\n<p>其中需要注意的是：</p>\n<p>1.对于某些特殊题目，栈内元素出不完，遗留在栈里面的人还没有考虑，导致答案错误，这时候我们要添加结束标识符强制清空栈。比如：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">vec.push_back(INF);&#x2F;&#x2F;对于单调递增栈（栈顶最小），补充结束标识符，使最后清空栈</code></pre>\n\n<p>2.我们进行栈的处理时，是在出栈操作时进行的。</p>\n<p>模板题练习：[<a href=\"https://www.luogu.com.cn/problem/P5788\">洛谷P5788</a>]</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\"></code></pre>\n\n\n\n\n\n\n\n"},{"_content":"[toc]\n\n\n\n实际考试中的数据结构题目会比平时代码常用的东西多一点。在此提纲掣领地做一复习。\n\n# 非常规队列\n\n## 顺序的环形实现\n\n顺序队列在数据不断地进队出队过程中，在顺序表中的位置不断后移。\n\n可以使用巧妙的方法将顺序表打造成一个环状表，如图 ：\n\n\n\n![img](https:////upload-images.jianshu.io/upload_images/6567790-e5806e91d36f67b7.png?imageMogr2/auto-orient/strip|imageView2/2/w/300)\n\n在真正的实现时，没必要真创建这样一种结构，可以通过增加取模、判断（到达队尾返回开头）的方式实现。\n\n## 循环队列\n\n队头指针front指向队头元素的前一位置，而队尾指针rear指向队尾元素。\n\n为解决如何判断队列的满与空问题，牺牲一个存储单元。\n\n \n\n## 栈浮动技术\n\n两个栈共享一组地址连续的存储单元。\n\n略。\n\n\n\n# 广义表\n\n\n## 稀疏矩阵的存储\n\n### 三元组存储及快速转置\n\n![img](C:\\Users\\ll\\blog\\source\\_posts\\贴图\\350.png)\n\n关键步骤：以 j 为序列，重新排列三元组表中存储各三元组的先后顺序。\n\n1. 在普通算法的基础上增设两个数组（ array 和 copt）：\n\n- array 数组负责记录原矩阵每一列非 0 元素的个数。例子对应的 array 数组：\n\n  ![img](https:////upload-images.jianshu.io/upload_images/6567790-164e9998c2c3026d.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200)\n\n- copt 数组用于计算稀疏矩阵中每列第一个非 0 元素在**新**三元组表中存放的位置，示例对应的 copt 数组如图 ：\n\n  ![img](https:////upload-images.jianshu.io/upload_images/6567790-22df260c67063f1c.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200)\n\n\n\n```\ncpot[1]=1\ncpot[col]=cpot[col-1] +array[col-1]\t(col > 1)//意思是，后一列首个非 0 元素存放的位置等于前一列首个非 0 元素的存放位置,加上该列非 0 元素的个数。由此可以看出，copt 数组才是最终想要的，而 array 数组的设立只是为了帮助我们得到 copt 数组。\n```\n\n\n\n### 行逻辑链接顺序表\n\n当使用行逻辑链接的顺序表对其进行压缩存储时，需要做以下两个工作：\n\n1.将矩阵中的非 0 元素采用三元组的形式存储到一维数组 data 中，如图 ：\n\n![img](https:////upload-images.jianshu.io/upload_images/6567790-d9807ee6236a2bd1.png?imageMogr2/auto-orient/strip|imageView2/2/w/450)\n\n2.使用数组 rpos 记录矩阵中每行第一个非 0 元素在一维数组中的存储位置。如图:\n\n\n\n![img](https:////upload-images.jianshu.io/upload_images/6567790-230259eea2644095.png?imageMogr2/auto-orient/strip|imageView2/2/w/300)\n\n**此时，如果想从行逻辑链接的顺序表中提取元素，则可以借助 rpos 数组提高遍历数组的效率。**\n\n例如，提取元素 2 的过程如下：\n\n由 `rpos` 数组可知，第一行首个非 0 元素位于data[1]，因此在遍历此行时，可以直接从第 data[1] 的位置开始，一直遍历到下一行首个非 0 元素所在的位置（data[3]）之前\n\n### 十字链表\n\n为克服三元组表在矩阵的非零元素位置或个数经常变动时的使用不便，矩阵中的各行各列都各用一链表存储，与此同时，所有行链表的表头存储到一个数组（`rhead`），所有列链表的表头存储到另一个数组（`chead`）中。各个链表中节点的结构如图:\n\n\n\n![img](https:////upload-images.jianshu.io/upload_images/6567790-81a62ea7f51afc57.png?imageMogr2/auto-orient/strip|imageView2/2/w/230)\n\n![image-20211123171532586](C:\\Users\\ll\\blog\\source\\_posts\\贴图\\image-20211123171532586.png)\n\n# 树\n\n## 线索化\n\n> 二叉链表对于无子树侧的指针域，能否利用这些空闲区存放有用的信息或线索？\n> ——可以用它来存放当前结点的直接前驱和后继等线索，以加快查找速度。按照某种方式对二叉树进行遍历，可以把二叉树中所有结点排序为一个线性序列，参考之，可以把一棵二叉树转变成了一个“双向链表“。\n>\n> 在该序列中，除第一个结点外每个结点有且仅有一个直接前驱结点；除最后一个结点外每一个结点有且仅有一个直接后继结点，由此线索化。\n\nLTag=0, lchild域指向左孩子；LTag=1, lchild域指向其前驱\nRTag=0, rchild域指向右孩子；RTag=1, rchild域指向其后继 \n\n在线索二叉树的基础上，额外添加一个结点。此结点的作用类似于链表中的头指针，数据域不起作用，只利用两个指针域：左指针域指向二叉树的树根，确保可以正方向对二叉树进行遍历；同时右指针指向线索二叉树形成的线性序列中的最后一个结点。同时，该节点也可避免\"悬空\"的情形。\n\n## 补充结论\n\n### 深入理解二叉树遍历\n\n非递归中序遍历：\n\n- 入栈顺序：先序遍历；\n- 出栈顺序：中序遍历\n\n### 二叉树和森林的互化\n\n#### 树和二叉树\n\n回忆我们从树抽象到二叉树的思路：\n\n将树用“长子 - 兄弟“ 表示法时，转化成对应二叉树的方式：\n\n- 从根开始，左子树连接“长子”；\n- 从根开始，右子树连接“兄弟”；\n\n由此便知二者互化的原理；\n\n#### 二叉树和森林\n\n将森林中的每一棵树均用二叉树的方式抽象表述后，从最后一棵二叉树开始，每棵二叉树作为前一棵二叉树的根结点的右子树，得到森林对应的二叉树。\n\n所以，将二叉树根沿着右子树链方向的所有边去掉，得到若干棵孤立的二叉树，对应森林中的各棵树对应的二叉树集合。\n\n![img](C:\\Users\\ll\\blog\\source\\_posts\\贴图\\webp.webp)\n\n参考：\n\nhttps://www.jianshu.com/p/d7d5545012e2\n\n\n\n# 查找与排序\n\n## 分块查找\n\nn元素分块查找，记b为索引表长度，s为块中记录个数，则：\n\n当s取$\\sqrt{n}$时，$ASL_{bs}$取最小值$\\sqrt{n}+1$\n\n\n\n# 仅限考试用的结论\n\n1. 树的高度是从1开始算的，也就是说，空树的高度是0。\n2. 试卷中除非自己定义，请默认下标从“1”开始。\n3. 并查集：与主流一致，根节点的值为-1.\n","source":"_drafts/数据结构笔记——考试中的非主流玩法.md","raw":"[toc]\n\n\n\n实际考试中的数据结构题目会比平时代码常用的东西多一点。在此提纲掣领地做一复习。\n\n# 非常规队列\n\n## 顺序的环形实现\n\n顺序队列在数据不断地进队出队过程中，在顺序表中的位置不断后移。\n\n可以使用巧妙的方法将顺序表打造成一个环状表，如图 ：\n\n\n\n![img](https:////upload-images.jianshu.io/upload_images/6567790-e5806e91d36f67b7.png?imageMogr2/auto-orient/strip|imageView2/2/w/300)\n\n在真正的实现时，没必要真创建这样一种结构，可以通过增加取模、判断（到达队尾返回开头）的方式实现。\n\n## 循环队列\n\n队头指针front指向队头元素的前一位置，而队尾指针rear指向队尾元素。\n\n为解决如何判断队列的满与空问题，牺牲一个存储单元。\n\n \n\n## 栈浮动技术\n\n两个栈共享一组地址连续的存储单元。\n\n略。\n\n\n\n# 广义表\n\n\n## 稀疏矩阵的存储\n\n### 三元组存储及快速转置\n\n![img](C:\\Users\\ll\\blog\\source\\_posts\\贴图\\350.png)\n\n关键步骤：以 j 为序列，重新排列三元组表中存储各三元组的先后顺序。\n\n1. 在普通算法的基础上增设两个数组（ array 和 copt）：\n\n- array 数组负责记录原矩阵每一列非 0 元素的个数。例子对应的 array 数组：\n\n  ![img](https:////upload-images.jianshu.io/upload_images/6567790-164e9998c2c3026d.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200)\n\n- copt 数组用于计算稀疏矩阵中每列第一个非 0 元素在**新**三元组表中存放的位置，示例对应的 copt 数组如图 ：\n\n  ![img](https:////upload-images.jianshu.io/upload_images/6567790-22df260c67063f1c.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200)\n\n\n\n```\ncpot[1]=1\ncpot[col]=cpot[col-1] +array[col-1]\t(col > 1)//意思是，后一列首个非 0 元素存放的位置等于前一列首个非 0 元素的存放位置,加上该列非 0 元素的个数。由此可以看出，copt 数组才是最终想要的，而 array 数组的设立只是为了帮助我们得到 copt 数组。\n```\n\n\n\n### 行逻辑链接顺序表\n\n当使用行逻辑链接的顺序表对其进行压缩存储时，需要做以下两个工作：\n\n1.将矩阵中的非 0 元素采用三元组的形式存储到一维数组 data 中，如图 ：\n\n![img](https:////upload-images.jianshu.io/upload_images/6567790-d9807ee6236a2bd1.png?imageMogr2/auto-orient/strip|imageView2/2/w/450)\n\n2.使用数组 rpos 记录矩阵中每行第一个非 0 元素在一维数组中的存储位置。如图:\n\n\n\n![img](https:////upload-images.jianshu.io/upload_images/6567790-230259eea2644095.png?imageMogr2/auto-orient/strip|imageView2/2/w/300)\n\n**此时，如果想从行逻辑链接的顺序表中提取元素，则可以借助 rpos 数组提高遍历数组的效率。**\n\n例如，提取元素 2 的过程如下：\n\n由 `rpos` 数组可知，第一行首个非 0 元素位于data[1]，因此在遍历此行时，可以直接从第 data[1] 的位置开始，一直遍历到下一行首个非 0 元素所在的位置（data[3]）之前\n\n### 十字链表\n\n为克服三元组表在矩阵的非零元素位置或个数经常变动时的使用不便，矩阵中的各行各列都各用一链表存储，与此同时，所有行链表的表头存储到一个数组（`rhead`），所有列链表的表头存储到另一个数组（`chead`）中。各个链表中节点的结构如图:\n\n\n\n![img](https:////upload-images.jianshu.io/upload_images/6567790-81a62ea7f51afc57.png?imageMogr2/auto-orient/strip|imageView2/2/w/230)\n\n![image-20211123171532586](C:\\Users\\ll\\blog\\source\\_posts\\贴图\\image-20211123171532586.png)\n\n# 树\n\n## 线索化\n\n> 二叉链表对于无子树侧的指针域，能否利用这些空闲区存放有用的信息或线索？\n> ——可以用它来存放当前结点的直接前驱和后继等线索，以加快查找速度。按照某种方式对二叉树进行遍历，可以把二叉树中所有结点排序为一个线性序列，参考之，可以把一棵二叉树转变成了一个“双向链表“。\n>\n> 在该序列中，除第一个结点外每个结点有且仅有一个直接前驱结点；除最后一个结点外每一个结点有且仅有一个直接后继结点，由此线索化。\n\nLTag=0, lchild域指向左孩子；LTag=1, lchild域指向其前驱\nRTag=0, rchild域指向右孩子；RTag=1, rchild域指向其后继 \n\n在线索二叉树的基础上，额外添加一个结点。此结点的作用类似于链表中的头指针，数据域不起作用，只利用两个指针域：左指针域指向二叉树的树根，确保可以正方向对二叉树进行遍历；同时右指针指向线索二叉树形成的线性序列中的最后一个结点。同时，该节点也可避免\"悬空\"的情形。\n\n## 补充结论\n\n### 深入理解二叉树遍历\n\n非递归中序遍历：\n\n- 入栈顺序：先序遍历；\n- 出栈顺序：中序遍历\n\n### 二叉树和森林的互化\n\n#### 树和二叉树\n\n回忆我们从树抽象到二叉树的思路：\n\n将树用“长子 - 兄弟“ 表示法时，转化成对应二叉树的方式：\n\n- 从根开始，左子树连接“长子”；\n- 从根开始，右子树连接“兄弟”；\n\n由此便知二者互化的原理；\n\n#### 二叉树和森林\n\n将森林中的每一棵树均用二叉树的方式抽象表述后，从最后一棵二叉树开始，每棵二叉树作为前一棵二叉树的根结点的右子树，得到森林对应的二叉树。\n\n所以，将二叉树根沿着右子树链方向的所有边去掉，得到若干棵孤立的二叉树，对应森林中的各棵树对应的二叉树集合。\n\n![img](C:\\Users\\ll\\blog\\source\\_posts\\贴图\\webp.webp)\n\n参考：\n\nhttps://www.jianshu.com/p/d7d5545012e2\n\n\n\n# 查找与排序\n\n## 分块查找\n\nn元素分块查找，记b为索引表长度，s为块中记录个数，则：\n\n当s取$\\sqrt{n}$时，$ASL_{bs}$取最小值$\\sqrt{n}+1$\n\n\n\n# 仅限考试用的结论\n\n1. 树的高度是从1开始算的，也就是说，空树的高度是0。\n2. 试卷中除非自己定义，请默认下标从“1”开始。\n3. 并查集：与主流一致，根节点的值为-1.\n","slug":"数据结构笔记——考试中的非主流玩法","published":0,"date":"2022-02-03T12:48:32.004Z","updated":"2021-12-27T14:56:21.539Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"ckz6z5ofi000cfovvh2gw5mnp","content":"<p>[toc]</p>\n<p>实际考试中的数据结构题目会比平时代码常用的东西多一点。在此提纲掣领地做一复习。</p>\n<h1 id=\"非常规队列\"><a href=\"#非常规队列\" class=\"headerlink\" title=\"非常规队列\"></a>非常规队列</h1><h2 id=\"顺序的环形实现\"><a href=\"#顺序的环形实现\" class=\"headerlink\" title=\"顺序的环形实现\"></a>顺序的环形实现</h2><p>顺序队列在数据不断地进队出队过程中，在顺序表中的位置不断后移。</p>\n<p>可以使用巧妙的方法将顺序表打造成一个环状表，如图 ：</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/6567790-e5806e91d36f67b7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/300\" alt=\"img\"></p>\n<p>在真正的实现时，没必要真创建这样一种结构，可以通过增加取模、判断（到达队尾返回开头）的方式实现。</p>\n<h2 id=\"循环队列\"><a href=\"#循环队列\" class=\"headerlink\" title=\"循环队列\"></a>循环队列</h2><p>队头指针front指向队头元素的前一位置，而队尾指针rear指向队尾元素。</p>\n<p>为解决如何判断队列的满与空问题，牺牲一个存储单元。</p>\n<h2 id=\"栈浮动技术\"><a href=\"#栈浮动技术\" class=\"headerlink\" title=\"栈浮动技术\"></a>栈浮动技术</h2><p>两个栈共享一组地址连续的存储单元。</p>\n<p>略。</p>\n<h1 id=\"广义表\"><a href=\"#广义表\" class=\"headerlink\" title=\"广义表\"></a>广义表</h1><h2 id=\"稀疏矩阵的存储\"><a href=\"#稀疏矩阵的存储\" class=\"headerlink\" title=\"稀疏矩阵的存储\"></a>稀疏矩阵的存储</h2><h3 id=\"三元组存储及快速转置\"><a href=\"#三元组存储及快速转置\" class=\"headerlink\" title=\"三元组存储及快速转置\"></a>三元组存储及快速转置</h3><p><img src=\"C:\\Users\\ll\\blog\\source_posts\\贴图\\350.png\" alt=\"img\"></p>\n<p>关键步骤：以 j 为序列，重新排列三元组表中存储各三元组的先后顺序。</p>\n<ol>\n<li>在普通算法的基础上增设两个数组（ array 和 copt）：</li>\n</ol>\n<ul>\n<li><p>array 数组负责记录原矩阵每一列非 0 元素的个数。例子对应的 array 数组：</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/6567790-164e9998c2c3026d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200\" alt=\"img\"></p>\n</li>\n<li><p>copt 数组用于计算稀疏矩阵中每列第一个非 0 元素在<strong>新</strong>三元组表中存放的位置，示例对应的 copt 数组如图 ：</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/6567790-22df260c67063f1c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200\" alt=\"img\"></p>\n</li>\n</ul>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">cpot[1]&#x3D;1\ncpot[col]&#x3D;cpot[col-1] +array[col-1]\t(col &gt; 1)&#x2F;&#x2F;意思是，后一列首个非 0 元素存放的位置等于前一列首个非 0 元素的存放位置,加上该列非 0 元素的个数。由此可以看出，copt 数组才是最终想要的，而 array 数组的设立只是为了帮助我们得到 copt 数组。</code></pre>\n\n\n\n<h3 id=\"行逻辑链接顺序表\"><a href=\"#行逻辑链接顺序表\" class=\"headerlink\" title=\"行逻辑链接顺序表\"></a>行逻辑链接顺序表</h3><p>当使用行逻辑链接的顺序表对其进行压缩存储时，需要做以下两个工作：</p>\n<p>1.将矩阵中的非 0 元素采用三元组的形式存储到一维数组 data 中，如图 ：</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/6567790-d9807ee6236a2bd1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/450\" alt=\"img\"></p>\n<p>2.使用数组 rpos 记录矩阵中每行第一个非 0 元素在一维数组中的存储位置。如图:</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/6567790-230259eea2644095.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/300\" alt=\"img\"></p>\n<p><strong>此时，如果想从行逻辑链接的顺序表中提取元素，则可以借助 rpos 数组提高遍历数组的效率。</strong></p>\n<p>例如，提取元素 2 的过程如下：</p>\n<p>由 <code>rpos</code> 数组可知，第一行首个非 0 元素位于data[1]，因此在遍历此行时，可以直接从第 data[1] 的位置开始，一直遍历到下一行首个非 0 元素所在的位置（data[3]）之前</p>\n<h3 id=\"十字链表\"><a href=\"#十字链表\" class=\"headerlink\" title=\"十字链表\"></a>十字链表</h3><p>为克服三元组表在矩阵的非零元素位置或个数经常变动时的使用不便，矩阵中的各行各列都各用一链表存储，与此同时，所有行链表的表头存储到一个数组（<code>rhead</code>），所有列链表的表头存储到另一个数组（<code>chead</code>）中。各个链表中节点的结构如图:</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/6567790-81a62ea7f51afc57.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/230\" alt=\"img\"></p>\n<p><img src=\"C:\\Users\\ll\\blog\\source_posts\\贴图\\image-20211123171532586.png\" alt=\"image-20211123171532586\"></p>\n<h1 id=\"树\"><a href=\"#树\" class=\"headerlink\" title=\"树\"></a>树</h1><h2 id=\"线索化\"><a href=\"#线索化\" class=\"headerlink\" title=\"线索化\"></a>线索化</h2><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>二叉链表对于无子树侧的指针域，能否利用这些空闲区存放有用的信息或线索？<br>——可以用它来存放当前结点的直接前驱和后继等线索，以加快查找速度。按照某种方式对二叉树进行遍历，可以把二叉树中所有结点排序为一个线性序列，参考之，可以把一棵二叉树转变成了一个“双向链表“。</p>\n<p>在该序列中，除第一个结点外每个结点有且仅有一个直接前驱结点；除最后一个结点外每一个结点有且仅有一个直接后继结点，由此线索化。</p></blockquote>\n<p>LTag=0, lchild域指向左孩子；LTag=1, lchild域指向其前驱<br>RTag=0, rchild域指向右孩子；RTag=1, rchild域指向其后继 </p>\n<p>在线索二叉树的基础上，额外添加一个结点。此结点的作用类似于链表中的头指针，数据域不起作用，只利用两个指针域：左指针域指向二叉树的树根，确保可以正方向对二叉树进行遍历；同时右指针指向线索二叉树形成的线性序列中的最后一个结点。同时，该节点也可避免”悬空”的情形。</p>\n<h2 id=\"补充结论\"><a href=\"#补充结论\" class=\"headerlink\" title=\"补充结论\"></a>补充结论</h2><h3 id=\"深入理解二叉树遍历\"><a href=\"#深入理解二叉树遍历\" class=\"headerlink\" title=\"深入理解二叉树遍历\"></a>深入理解二叉树遍历</h3><p>非递归中序遍历：</p>\n<ul>\n<li>入栈顺序：先序遍历；</li>\n<li>出栈顺序：中序遍历</li>\n</ul>\n<h3 id=\"二叉树和森林的互化\"><a href=\"#二叉树和森林的互化\" class=\"headerlink\" title=\"二叉树和森林的互化\"></a>二叉树和森林的互化</h3><h4 id=\"树和二叉树\"><a href=\"#树和二叉树\" class=\"headerlink\" title=\"树和二叉树\"></a>树和二叉树</h4><p>回忆我们从树抽象到二叉树的思路：</p>\n<p>将树用“长子 - 兄弟“ 表示法时，转化成对应二叉树的方式：</p>\n<ul>\n<li>从根开始，左子树连接“长子”；</li>\n<li>从根开始，右子树连接“兄弟”；</li>\n</ul>\n<p>由此便知二者互化的原理；</p>\n<h4 id=\"二叉树和森林\"><a href=\"#二叉树和森林\" class=\"headerlink\" title=\"二叉树和森林\"></a>二叉树和森林</h4><p>将森林中的每一棵树均用二叉树的方式抽象表述后，从最后一棵二叉树开始，每棵二叉树作为前一棵二叉树的根结点的右子树，得到森林对应的二叉树。</p>\n<p>所以，将二叉树根沿着右子树链方向的所有边去掉，得到若干棵孤立的二叉树，对应森林中的各棵树对应的二叉树集合。</p>\n<p><img src=\"C:\\Users\\ll\\blog\\source_posts\\贴图\\webp.webp\" alt=\"img\"></p>\n<p>参考：</p>\n<p><a href=\"https://www.jianshu.com/p/d7d5545012e2\">https://www.jianshu.com/p/d7d5545012e2</a></p>\n<h1 id=\"查找与排序\"><a href=\"#查找与排序\" class=\"headerlink\" title=\"查找与排序\"></a>查找与排序</h1><h2 id=\"分块查找\"><a href=\"#分块查找\" class=\"headerlink\" title=\"分块查找\"></a>分块查找</h2><p>n元素分块查找，记b为索引表长度，s为块中记录个数，则：</p>\n<p>当s取$\\sqrt{n}$时，$ASL_{bs}$取最小值$\\sqrt{n}+1$</p>\n<h1 id=\"仅限考试用的结论\"><a href=\"#仅限考试用的结论\" class=\"headerlink\" title=\"仅限考试用的结论\"></a>仅限考试用的结论</h1><ol>\n<li>树的高度是从1开始算的，也就是说，空树的高度是0。</li>\n<li>试卷中除非自己定义，请默认下标从“1”开始。</li>\n<li>并查集：与主流一致，根节点的值为-1.</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<p>[toc]</p>\n<p>实际考试中的数据结构题目会比平时代码常用的东西多一点。在此提纲掣领地做一复习。</p>\n<h1 id=\"非常规队列\"><a href=\"#非常规队列\" class=\"headerlink\" title=\"非常规队列\"></a>非常规队列</h1><h2 id=\"顺序的环形实现\"><a href=\"#顺序的环形实现\" class=\"headerlink\" title=\"顺序的环形实现\"></a>顺序的环形实现</h2><p>顺序队列在数据不断地进队出队过程中，在顺序表中的位置不断后移。</p>\n<p>可以使用巧妙的方法将顺序表打造成一个环状表，如图 ：</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/6567790-e5806e91d36f67b7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/300\" alt=\"img\"></p>\n<p>在真正的实现时，没必要真创建这样一种结构，可以通过增加取模、判断（到达队尾返回开头）的方式实现。</p>\n<h2 id=\"循环队列\"><a href=\"#循环队列\" class=\"headerlink\" title=\"循环队列\"></a>循环队列</h2><p>队头指针front指向队头元素的前一位置，而队尾指针rear指向队尾元素。</p>\n<p>为解决如何判断队列的满与空问题，牺牲一个存储单元。</p>\n<h2 id=\"栈浮动技术\"><a href=\"#栈浮动技术\" class=\"headerlink\" title=\"栈浮动技术\"></a>栈浮动技术</h2><p>两个栈共享一组地址连续的存储单元。</p>\n<p>略。</p>\n<h1 id=\"广义表\"><a href=\"#广义表\" class=\"headerlink\" title=\"广义表\"></a>广义表</h1><h2 id=\"稀疏矩阵的存储\"><a href=\"#稀疏矩阵的存储\" class=\"headerlink\" title=\"稀疏矩阵的存储\"></a>稀疏矩阵的存储</h2><h3 id=\"三元组存储及快速转置\"><a href=\"#三元组存储及快速转置\" class=\"headerlink\" title=\"三元组存储及快速转置\"></a>三元组存储及快速转置</h3><p><img src=\"C:\\Users\\ll\\blog\\source_posts\\贴图\\350.png\" alt=\"img\"></p>\n<p>关键步骤：以 j 为序列，重新排列三元组表中存储各三元组的先后顺序。</p>\n<ol>\n<li>在普通算法的基础上增设两个数组（ array 和 copt）：</li>\n</ol>\n<ul>\n<li><p>array 数组负责记录原矩阵每一列非 0 元素的个数。例子对应的 array 数组：</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/6567790-164e9998c2c3026d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200\" alt=\"img\"></p>\n</li>\n<li><p>copt 数组用于计算稀疏矩阵中每列第一个非 0 元素在<strong>新</strong>三元组表中存放的位置，示例对应的 copt 数组如图 ：</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/6567790-22df260c67063f1c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200\" alt=\"img\"></p>\n</li>\n</ul>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">cpot[1]&#x3D;1\ncpot[col]&#x3D;cpot[col-1] +array[col-1]\t(col &gt; 1)&#x2F;&#x2F;意思是，后一列首个非 0 元素存放的位置等于前一列首个非 0 元素的存放位置,加上该列非 0 元素的个数。由此可以看出，copt 数组才是最终想要的，而 array 数组的设立只是为了帮助我们得到 copt 数组。</code></pre>\n\n\n\n<h3 id=\"行逻辑链接顺序表\"><a href=\"#行逻辑链接顺序表\" class=\"headerlink\" title=\"行逻辑链接顺序表\"></a>行逻辑链接顺序表</h3><p>当使用行逻辑链接的顺序表对其进行压缩存储时，需要做以下两个工作：</p>\n<p>1.将矩阵中的非 0 元素采用三元组的形式存储到一维数组 data 中，如图 ：</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/6567790-d9807ee6236a2bd1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/450\" alt=\"img\"></p>\n<p>2.使用数组 rpos 记录矩阵中每行第一个非 0 元素在一维数组中的存储位置。如图:</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/6567790-230259eea2644095.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/300\" alt=\"img\"></p>\n<p><strong>此时，如果想从行逻辑链接的顺序表中提取元素，则可以借助 rpos 数组提高遍历数组的效率。</strong></p>\n<p>例如，提取元素 2 的过程如下：</p>\n<p>由 <code>rpos</code> 数组可知，第一行首个非 0 元素位于data[1]，因此在遍历此行时，可以直接从第 data[1] 的位置开始，一直遍历到下一行首个非 0 元素所在的位置（data[3]）之前</p>\n<h3 id=\"十字链表\"><a href=\"#十字链表\" class=\"headerlink\" title=\"十字链表\"></a>十字链表</h3><p>为克服三元组表在矩阵的非零元素位置或个数经常变动时的使用不便，矩阵中的各行各列都各用一链表存储，与此同时，所有行链表的表头存储到一个数组（<code>rhead</code>），所有列链表的表头存储到另一个数组（<code>chead</code>）中。各个链表中节点的结构如图:</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/6567790-81a62ea7f51afc57.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/230\" alt=\"img\"></p>\n<p><img src=\"C:\\Users\\ll\\blog\\source_posts\\贴图\\image-20211123171532586.png\" alt=\"image-20211123171532586\"></p>\n<h1 id=\"树\"><a href=\"#树\" class=\"headerlink\" title=\"树\"></a>树</h1><h2 id=\"线索化\"><a href=\"#线索化\" class=\"headerlink\" title=\"线索化\"></a>线索化</h2><blockquote>\n<p>二叉链表对于无子树侧的指针域，能否利用这些空闲区存放有用的信息或线索？<br>——可以用它来存放当前结点的直接前驱和后继等线索，以加快查找速度。按照某种方式对二叉树进行遍历，可以把二叉树中所有结点排序为一个线性序列，参考之，可以把一棵二叉树转变成了一个“双向链表“。</p>\n<p>在该序列中，除第一个结点外每个结点有且仅有一个直接前驱结点；除最后一个结点外每一个结点有且仅有一个直接后继结点，由此线索化。</p>\n</blockquote>\n<p>LTag=0, lchild域指向左孩子；LTag=1, lchild域指向其前驱<br>RTag=0, rchild域指向右孩子；RTag=1, rchild域指向其后继 </p>\n<p>在线索二叉树的基础上，额外添加一个结点。此结点的作用类似于链表中的头指针，数据域不起作用，只利用两个指针域：左指针域指向二叉树的树根，确保可以正方向对二叉树进行遍历；同时右指针指向线索二叉树形成的线性序列中的最后一个结点。同时，该节点也可避免”悬空”的情形。</p>\n<h2 id=\"补充结论\"><a href=\"#补充结论\" class=\"headerlink\" title=\"补充结论\"></a>补充结论</h2><h3 id=\"深入理解二叉树遍历\"><a href=\"#深入理解二叉树遍历\" class=\"headerlink\" title=\"深入理解二叉树遍历\"></a>深入理解二叉树遍历</h3><p>非递归中序遍历：</p>\n<ul>\n<li>入栈顺序：先序遍历；</li>\n<li>出栈顺序：中序遍历</li>\n</ul>\n<h3 id=\"二叉树和森林的互化\"><a href=\"#二叉树和森林的互化\" class=\"headerlink\" title=\"二叉树和森林的互化\"></a>二叉树和森林的互化</h3><h4 id=\"树和二叉树\"><a href=\"#树和二叉树\" class=\"headerlink\" title=\"树和二叉树\"></a>树和二叉树</h4><p>回忆我们从树抽象到二叉树的思路：</p>\n<p>将树用“长子 - 兄弟“ 表示法时，转化成对应二叉树的方式：</p>\n<ul>\n<li>从根开始，左子树连接“长子”；</li>\n<li>从根开始，右子树连接“兄弟”；</li>\n</ul>\n<p>由此便知二者互化的原理；</p>\n<h4 id=\"二叉树和森林\"><a href=\"#二叉树和森林\" class=\"headerlink\" title=\"二叉树和森林\"></a>二叉树和森林</h4><p>将森林中的每一棵树均用二叉树的方式抽象表述后，从最后一棵二叉树开始，每棵二叉树作为前一棵二叉树的根结点的右子树，得到森林对应的二叉树。</p>\n<p>所以，将二叉树根沿着右子树链方向的所有边去掉，得到若干棵孤立的二叉树，对应森林中的各棵树对应的二叉树集合。</p>\n<p><img src=\"C:\\Users\\ll\\blog\\source_posts\\贴图\\webp.webp\" alt=\"img\"></p>\n<p>参考：</p>\n<p><a href=\"https://www.jianshu.com/p/d7d5545012e2\">https://www.jianshu.com/p/d7d5545012e2</a></p>\n<h1 id=\"查找与排序\"><a href=\"#查找与排序\" class=\"headerlink\" title=\"查找与排序\"></a>查找与排序</h1><h2 id=\"分块查找\"><a href=\"#分块查找\" class=\"headerlink\" title=\"分块查找\"></a>分块查找</h2><p>n元素分块查找，记b为索引表长度，s为块中记录个数，则：</p>\n<p>当s取$\\sqrt{n}$时，$ASL_{bs}$取最小值$\\sqrt{n}+1$</p>\n<h1 id=\"仅限考试用的结论\"><a href=\"#仅限考试用的结论\" class=\"headerlink\" title=\"仅限考试用的结论\"></a>仅限考试用的结论</h1><ol>\n<li>树的高度是从1开始算的，也就是说，空树的高度是0。</li>\n<li>试卷中除非自己定义，请默认下标从“1”开始。</li>\n<li>并查集：与主流一致，根节点的值为-1.</li>\n</ol>\n"},{"title":"算法模板","_content":"\n\n\n# 回溯法\n\n[TOC]\n\n解决一个回溯问题，实际上就是一个决策树的遍历过程，使用 `isValid` 函数剪枝。回溯算法模板框架如下：\n\n```cpp\nvoid backtracking(参数) {\n    if (结束遍历条件) {\n        存放结果;\n        return;\n    }\n\n    for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) {\n        if (!isValid(..)) \tcontinue;//// 排除不合法选择\n        处理节点;\n        backtracking(路径，选择列表); // 深入\n        撤销节点处理；\n    }\n}\n```\n\n对于`isValid`函数及剪枝策略，回溯法求最值时，可以通过贪心思想找到一个“较优解”，减去差于其的枝。(分支限界法)\n\n回溯与 DFS 的思想很类似，区别主要在于解空间的表示和处理：\n\n```cpp\nfor 循环内：\nrecord[son] = 1; // 标记使用/状态\ndfs(deep + 1); // dfs 下一层\nrecord[son] = 0; // 取消标记/状态\n```\n\n**在递归之前做出选择，在递归之后撤销刚才的选择**。\n\n解空间的状态表示主要有： 排列树 和 组合树 两种。\n\n![回溯算法理论基础](https://img-blog.csdnimg.cn/20210130173631174.png)\n\n口诀：for循环，换子树；递归调用往深溯\n\n## 示例：生成全排列\n\n![img](https://github.com/labuladong/fucking-algorithm/raw/master/pictures/backtracking/3.jpg)\n\n## n-皇后问题的 位运算解法 及 bitset 包\n\n### bitset\n\nbitset 头文件中，有一种类似数组的结构，它的每一个元素只能是０或１，每个元素仅用１bit空间，名为 bitset 。构造方式：\n\n```cpp\n    bitset<4> bitset1;　　//无初始化下，默认每一位均为0\n    bitset<8> bitset2(16);　//保存长度为8的16的二进制表示：[00010000]\n    string s = \"10010\";\n    bitset<8> bitset3(s);　　//长度为10，前补0。[00010010]\n```\n\n\n\nbitset 支持一些按位的位运算，且支持to_string类型转换。\n\n对于一个叫做bit的bitset：\nbit.size()       返回大小（位数）\nbit.count()     返回1的个数\nbit.any()       返回是否有1\nbit.none()      返回是否没有1\nbit.set()       全都变成1\nbit.set(p)      将第p + 1位变成1（bitset是从第0位开始的！） \nbit.set(p, x)   将第p + 1位变成x\nbit.reset()     全都变成0\nbit.reset(p)    将第p + 1位变成0\nbit.flip()      全都取反\nbit.flip(p)     将第p + 1位取反\nbit.to_ulong()  返回它转换为unsigned long的结果，如果超出范围则报错\nbit.to_ullong() 返回它转换为unsigned long long的结果，如果超出范围则报错\n\n","source":"_drafts/算法模板.md","raw":"---\ntitle: 算法模板\n---\n\n\n\n# 回溯法\n\n[TOC]\n\n解决一个回溯问题，实际上就是一个决策树的遍历过程，使用 `isValid` 函数剪枝。回溯算法模板框架如下：\n\n```cpp\nvoid backtracking(参数) {\n    if (结束遍历条件) {\n        存放结果;\n        return;\n    }\n\n    for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) {\n        if (!isValid(..)) \tcontinue;//// 排除不合法选择\n        处理节点;\n        backtracking(路径，选择列表); // 深入\n        撤销节点处理；\n    }\n}\n```\n\n对于`isValid`函数及剪枝策略，回溯法求最值时，可以通过贪心思想找到一个“较优解”，减去差于其的枝。(分支限界法)\n\n回溯与 DFS 的思想很类似，区别主要在于解空间的表示和处理：\n\n```cpp\nfor 循环内：\nrecord[son] = 1; // 标记使用/状态\ndfs(deep + 1); // dfs 下一层\nrecord[son] = 0; // 取消标记/状态\n```\n\n**在递归之前做出选择，在递归之后撤销刚才的选择**。\n\n解空间的状态表示主要有： 排列树 和 组合树 两种。\n\n![回溯算法理论基础](https://img-blog.csdnimg.cn/20210130173631174.png)\n\n口诀：for循环，换子树；递归调用往深溯\n\n## 示例：生成全排列\n\n![img](https://github.com/labuladong/fucking-algorithm/raw/master/pictures/backtracking/3.jpg)\n\n## n-皇后问题的 位运算解法 及 bitset 包\n\n### bitset\n\nbitset 头文件中，有一种类似数组的结构，它的每一个元素只能是０或１，每个元素仅用１bit空间，名为 bitset 。构造方式：\n\n```cpp\n    bitset<4> bitset1;　　//无初始化下，默认每一位均为0\n    bitset<8> bitset2(16);　//保存长度为8的16的二进制表示：[00010000]\n    string s = \"10010\";\n    bitset<8> bitset3(s);　　//长度为10，前补0。[00010010]\n```\n\n\n\nbitset 支持一些按位的位运算，且支持to_string类型转换。\n\n对于一个叫做bit的bitset：\nbit.size()       返回大小（位数）\nbit.count()     返回1的个数\nbit.any()       返回是否有1\nbit.none()      返回是否没有1\nbit.set()       全都变成1\nbit.set(p)      将第p + 1位变成1（bitset是从第0位开始的！） \nbit.set(p, x)   将第p + 1位变成x\nbit.reset()     全都变成0\nbit.reset(p)    将第p + 1位变成0\nbit.flip()      全都取反\nbit.flip(p)     将第p + 1位取反\nbit.to_ulong()  返回它转换为unsigned long的结果，如果超出范围则报错\nbit.to_ullong() 返回它转换为unsigned long long的结果，如果超出范围则报错\n\n","slug":"算法模板","published":0,"date":"2022-02-03T12:48:32.009Z","updated":"2021-11-24T07:37:15.894Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckz6z5ofj000dfovvb54af2nk","content":"<h1 id=\"回溯法\"><a href=\"#回溯法\" class=\"headerlink\" title=\"回溯法\"></a>回溯法</h1><p>[TOC]</p>\n<p>解决一个回溯问题，实际上就是一个决策树的遍历过程，使用 <code>isValid</code> 函数剪枝。回溯算法模板框架如下：</p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">void backtracking(参数) &#123;\n    if (结束遍历条件) &#123;\n        存放结果;\n        return;\n    &#125;\n\n    for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) &#123;\n        if (!isValid(..)) \tcontinue;&#x2F;&#x2F;&#x2F;&#x2F; 排除不合法选择\n        处理节点;\n        backtracking(路径，选择列表); &#x2F;&#x2F; 深入\n        撤销节点处理；\n    &#125;\n&#125;</code></pre>\n\n<p>对于<code>isValid</code>函数及剪枝策略，回溯法求最值时，可以通过贪心思想找到一个“较优解”，减去差于其的枝。(分支限界法)</p>\n<p>回溯与 DFS 的思想很类似，区别主要在于解空间的表示和处理：</p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">for 循环内：\nrecord[son] &#x3D; 1; &#x2F;&#x2F; 标记使用&#x2F;状态\ndfs(deep + 1); &#x2F;&#x2F; dfs 下一层\nrecord[son] &#x3D; 0; &#x2F;&#x2F; 取消标记&#x2F;状态</code></pre>\n\n<p><strong>在递归之前做出选择，在递归之后撤销刚才的选择</strong>。</p>\n<p>解空间的状态表示主要有： 排列树 和 组合树 两种。</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20210130173631174.png\" alt=\"回溯算法理论基础\"></p>\n<p>口诀：for循环，换子树；递归调用往深溯</p>\n<h2 id=\"示例：生成全排列\"><a href=\"#示例：生成全排列\" class=\"headerlink\" title=\"示例：生成全排列\"></a>示例：生成全排列</h2><p><img src=\"https://github.com/labuladong/fucking-algorithm/raw/master/pictures/backtracking/3.jpg\" alt=\"img\"></p>\n<h2 id=\"n-皇后问题的-位运算解法-及-bitset-包\"><a href=\"#n-皇后问题的-位运算解法-及-bitset-包\" class=\"headerlink\" title=\"n-皇后问题的 位运算解法 及 bitset 包\"></a>n-皇后问题的 位运算解法 及 bitset 包</h2><h3 id=\"bitset\"><a href=\"#bitset\" class=\"headerlink\" title=\"bitset\"></a>bitset</h3><p>bitset 头文件中，有一种类似数组的结构，它的每一个元素只能是０或１，每个元素仅用１bit空间，名为 bitset 。构造方式：</p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">bitset&lt;4&gt; bitset1;　　&#x2F;&#x2F;无初始化下，默认每一位均为0\nbitset&lt;8&gt; bitset2(16);　&#x2F;&#x2F;保存长度为8的16的二进制表示：[00010000]\nstring s &#x3D; &quot;10010&quot;;\nbitset&lt;8&gt; bitset3(s);　　&#x2F;&#x2F;长度为10，前补0。[00010010]</code></pre>\n\n\n\n<p>bitset 支持一些按位的位运算，且支持to_string类型转换。</p>\n<p>对于一个叫做bit的bitset：<br>bit.size()       返回大小（位数）<br>bit.count()     返回1的个数<br>bit.any()       返回是否有1<br>bit.none()      返回是否没有1<br>bit.set()       全都变成1<br>bit.set(p)      将第p + 1位变成1（bitset是从第0位开始的！）<br>bit.set(p, x)   将第p + 1位变成x<br>bit.reset()     全都变成0<br>bit.reset(p)    将第p + 1位变成0<br>bit.flip()      全都取反<br>bit.flip(p)     将第p + 1位取反<br>bit.to_ulong()  返回它转换为unsigned long的结果，如果超出范围则报错<br>bit.to_ullong() 返回它转换为unsigned long long的结果，如果超出范围则报错</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"回溯法\"><a href=\"#回溯法\" class=\"headerlink\" title=\"回溯法\"></a>回溯法</h1><p>[TOC]</p>\n<p>解决一个回溯问题，实际上就是一个决策树的遍历过程，使用 <code>isValid</code> 函数剪枝。回溯算法模板框架如下：</p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">void backtracking(参数) &#123;\n    if (结束遍历条件) &#123;\n        存放结果;\n        return;\n    &#125;\n\n    for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) &#123;\n        if (!isValid(..)) \tcontinue;&#x2F;&#x2F;&#x2F;&#x2F; 排除不合法选择\n        处理节点;\n        backtracking(路径，选择列表); &#x2F;&#x2F; 深入\n        撤销节点处理；\n    &#125;\n&#125;</code></pre>\n\n<p>对于<code>isValid</code>函数及剪枝策略，回溯法求最值时，可以通过贪心思想找到一个“较优解”，减去差于其的枝。(分支限界法)</p>\n<p>回溯与 DFS 的思想很类似，区别主要在于解空间的表示和处理：</p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">for 循环内：\nrecord[son] &#x3D; 1; &#x2F;&#x2F; 标记使用&#x2F;状态\ndfs(deep + 1); &#x2F;&#x2F; dfs 下一层\nrecord[son] &#x3D; 0; &#x2F;&#x2F; 取消标记&#x2F;状态</code></pre>\n\n<p><strong>在递归之前做出选择，在递归之后撤销刚才的选择</strong>。</p>\n<p>解空间的状态表示主要有： 排列树 和 组合树 两种。</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20210130173631174.png\" alt=\"回溯算法理论基础\"></p>\n<p>口诀：for循环，换子树；递归调用往深溯</p>\n<h2 id=\"示例：生成全排列\"><a href=\"#示例：生成全排列\" class=\"headerlink\" title=\"示例：生成全排列\"></a>示例：生成全排列</h2><p><img src=\"https://github.com/labuladong/fucking-algorithm/raw/master/pictures/backtracking/3.jpg\" alt=\"img\"></p>\n<h2 id=\"n-皇后问题的-位运算解法-及-bitset-包\"><a href=\"#n-皇后问题的-位运算解法-及-bitset-包\" class=\"headerlink\" title=\"n-皇后问题的 位运算解法 及 bitset 包\"></a>n-皇后问题的 位运算解法 及 bitset 包</h2><h3 id=\"bitset\"><a href=\"#bitset\" class=\"headerlink\" title=\"bitset\"></a>bitset</h3><p>bitset 头文件中，有一种类似数组的结构，它的每一个元素只能是０或１，每个元素仅用１bit空间，名为 bitset 。构造方式：</p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">bitset&lt;4&gt; bitset1;　　&#x2F;&#x2F;无初始化下，默认每一位均为0\nbitset&lt;8&gt; bitset2(16);　&#x2F;&#x2F;保存长度为8的16的二进制表示：[00010000]\nstring s &#x3D; &quot;10010&quot;;\nbitset&lt;8&gt; bitset3(s);　　&#x2F;&#x2F;长度为10，前补0。[00010010]</code></pre>\n\n\n\n<p>bitset 支持一些按位的位运算，且支持to_string类型转换。</p>\n<p>对于一个叫做bit的bitset：<br>bit.size()       返回大小（位数）<br>bit.count()     返回1的个数<br>bit.any()       返回是否有1<br>bit.none()      返回是否没有1<br>bit.set()       全都变成1<br>bit.set(p)      将第p + 1位变成1（bitset是从第0位开始的！）<br>bit.set(p, x)   将第p + 1位变成x<br>bit.reset()     全都变成0<br>bit.reset(p)    将第p + 1位变成0<br>bit.flip()      全都取反<br>bit.flip(p)     将第p + 1位取反<br>bit.to_ulong()  返回它转换为unsigned long的结果，如果超出范围则报错<br>bit.to_ullong() 返回它转换为unsigned long long的结果，如果超出范围则报错</p>\n"},{"_content":"# 数学之美摘抄\n\n合理利用信息，而非玩弄什么公式和机器学习算法，是做好搜索的关键。\n\n先帮用户解决 80% 的问题，再慢慢解决剩下的 20% 问题。\n\n","source":"_drafts/数学之美摘抄.md","raw":"# 数学之美摘抄\n\n合理利用信息，而非玩弄什么公式和机器学习算法，是做好搜索的关键。\n\n先帮用户解决 80% 的问题，再慢慢解决剩下的 20% 问题。\n\n","slug":"数学之美摘抄","published":0,"date":"2022-02-03T12:48:32.006Z","updated":"2021-10-04T12:09:34.453Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"ckz6z5ofk000efovv34c4ax7z","content":"<h1 id=\"数学之美摘抄\"><a href=\"#数学之美摘抄\" class=\"headerlink\" title=\"数学之美摘抄\"></a>数学之美摘抄</h1><p>合理利用信息，而非玩弄什么公式和机器学习算法，是做好搜索的关键。</p>\n<p>先帮用户解决 80% 的问题，再慢慢解决剩下的 20% 问题。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"数学之美摘抄\"><a href=\"#数学之美摘抄\" class=\"headerlink\" title=\"数学之美摘抄\"></a>数学之美摘抄</h1><p>合理利用信息，而非玩弄什么公式和机器学习算法，是做好搜索的关键。</p>\n<p>先帮用户解决 80% 的问题，再慢慢解决剩下的 20% 问题。</p>\n"},{"title":"谈谈我对艺术的理解","_content":"\n# 艺术\n\n[TOC]\n\n【内容产出中】\n\n近来身体良好，灵感迸发，借此良机，抒发笔者对艺术所感，同时借以小憩。\n\n艺术，听似很有逼格的词语，其实也可以很接地气。艺术，不仅仅是在798艺术中心里，用不同的理论和方法表现出富有冲击力的美感和画面，也可以是用各种形式对生活的记录。\n\n## 信息的记录\n\n身临其境之时，方是全身心投入环境的好时机。画作，是一种精湛的技术，由点到面，从细节到整体，一步步勾勒出自己的心灵想象；音乐，是一种共情的表达，用乐器和音符构筑开阔或是幽美的想象空间。摄影，是一种宝贵的记忆，每一张照片都是独一无二的，其角度和参数都涵盖摄影者的巧思。\n\n曾经我以为，在信息高速发展的浪潮下，我想去的地方，其景象能够由照片看见，其声音可以由midi生成，其氛围亦可由文字所构造，如果配以虚拟导游，我可能真的不必费心破财亲临其境，更不用拍摄下、记录下当时的所见所感。\n\n非也，以上的想法都是在接收信息，而信息的记录及后期处理、亲临其境的感受，那都是心灵的创造，是一种美的艺术。\n\n### 当下\n\n###个性化\n\n##信息的处理\n\n运用python爬取到想要的资料自然是增强了科技处理的信心，想到这里，大一时真的不够自信\n\n### 二创和个性变化\n\n###启发式处理","source":"_drafts/谈谈我对艺术的理解.md","raw":"---\ntitle: 谈谈我对艺术的理解\n---\n\n# 艺术\n\n[TOC]\n\n【内容产出中】\n\n近来身体良好，灵感迸发，借此良机，抒发笔者对艺术所感，同时借以小憩。\n\n艺术，听似很有逼格的词语，其实也可以很接地气。艺术，不仅仅是在798艺术中心里，用不同的理论和方法表现出富有冲击力的美感和画面，也可以是用各种形式对生活的记录。\n\n## 信息的记录\n\n身临其境之时，方是全身心投入环境的好时机。画作，是一种精湛的技术，由点到面，从细节到整体，一步步勾勒出自己的心灵想象；音乐，是一种共情的表达，用乐器和音符构筑开阔或是幽美的想象空间。摄影，是一种宝贵的记忆，每一张照片都是独一无二的，其角度和参数都涵盖摄影者的巧思。\n\n曾经我以为，在信息高速发展的浪潮下，我想去的地方，其景象能够由照片看见，其声音可以由midi生成，其氛围亦可由文字所构造，如果配以虚拟导游，我可能真的不必费心破财亲临其境，更不用拍摄下、记录下当时的所见所感。\n\n非也，以上的想法都是在接收信息，而信息的记录及后期处理、亲临其境的感受，那都是心灵的创造，是一种美的艺术。\n\n### 当下\n\n###个性化\n\n##信息的处理\n\n运用python爬取到想要的资料自然是增强了科技处理的信心，想到这里，大一时真的不够自信\n\n### 二创和个性变化\n\n###启发式处理","slug":"谈谈我对艺术的理解","published":0,"date":"2022-02-03T12:48:32.011Z","updated":"2021-11-24T07:37:44.189Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckz6z5ofl000ffovv077823jm","content":"<h1 id=\"艺术\"><a href=\"#艺术\" class=\"headerlink\" title=\"艺术\"></a>艺术</h1><p>[TOC]</p>\n<p>【内容产出中】</p>\n<p>近来身体良好，灵感迸发，借此良机，抒发笔者对艺术所感，同时借以小憩。</p>\n<p>艺术，听似很有逼格的词语，其实也可以很接地气。艺术，不仅仅是在798艺术中心里，用不同的理论和方法表现出富有冲击力的美感和画面，也可以是用各种形式对生活的记录。</p>\n<h2 id=\"信息的记录\"><a href=\"#信息的记录\" class=\"headerlink\" title=\"信息的记录\"></a>信息的记录</h2><p>身临其境之时，方是全身心投入环境的好时机。画作，是一种精湛的技术，由点到面，从细节到整体，一步步勾勒出自己的心灵想象；音乐，是一种共情的表达，用乐器和音符构筑开阔或是幽美的想象空间。摄影，是一种宝贵的记忆，每一张照片都是独一无二的，其角度和参数都涵盖摄影者的巧思。</p>\n<p>曾经我以为，在信息高速发展的浪潮下，我想去的地方，其景象能够由照片看见，其声音可以由midi生成，其氛围亦可由文字所构造，如果配以虚拟导游，我可能真的不必费心破财亲临其境，更不用拍摄下、记录下当时的所见所感。</p>\n<p>非也，以上的想法都是在接收信息，而信息的记录及后期处理、亲临其境的感受，那都是心灵的创造，是一种美的艺术。</p>\n<h3 id=\"当下\"><a href=\"#当下\" class=\"headerlink\" title=\"当下\"></a>当下</h3><p>###个性化</p>\n<p>##信息的处理</p>\n<p>运用python爬取到想要的资料自然是增强了科技处理的信心，想到这里，大一时真的不够自信</p>\n<h3 id=\"二创和个性变化\"><a href=\"#二创和个性变化\" class=\"headerlink\" title=\"二创和个性变化\"></a>二创和个性变化</h3><p>###启发式处理</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"艺术\"><a href=\"#艺术\" class=\"headerlink\" title=\"艺术\"></a>艺术</h1><p>[TOC]</p>\n<p>【内容产出中】</p>\n<p>近来身体良好，灵感迸发，借此良机，抒发笔者对艺术所感，同时借以小憩。</p>\n<p>艺术，听似很有逼格的词语，其实也可以很接地气。艺术，不仅仅是在798艺术中心里，用不同的理论和方法表现出富有冲击力的美感和画面，也可以是用各种形式对生活的记录。</p>\n<h2 id=\"信息的记录\"><a href=\"#信息的记录\" class=\"headerlink\" title=\"信息的记录\"></a>信息的记录</h2><p>身临其境之时，方是全身心投入环境的好时机。画作，是一种精湛的技术，由点到面，从细节到整体，一步步勾勒出自己的心灵想象；音乐，是一种共情的表达，用乐器和音符构筑开阔或是幽美的想象空间。摄影，是一种宝贵的记忆，每一张照片都是独一无二的，其角度和参数都涵盖摄影者的巧思。</p>\n<p>曾经我以为，在信息高速发展的浪潮下，我想去的地方，其景象能够由照片看见，其声音可以由midi生成，其氛围亦可由文字所构造，如果配以虚拟导游，我可能真的不必费心破财亲临其境，更不用拍摄下、记录下当时的所见所感。</p>\n<p>非也，以上的想法都是在接收信息，而信息的记录及后期处理、亲临其境的感受，那都是心灵的创造，是一种美的艺术。</p>\n<h3 id=\"当下\"><a href=\"#当下\" class=\"headerlink\" title=\"当下\"></a>当下</h3><p>###个性化</p>\n<p>##信息的处理</p>\n<p>运用python爬取到想要的资料自然是增强了科技处理的信心，想到这里，大一时真的不够自信</p>\n<h3 id=\"二创和个性变化\"><a href=\"#二创和个性变化\" class=\"headerlink\" title=\"二创和个性变化\"></a>二创和个性变化</h3><p>###启发式处理</p>\n"},{"title":"C++ 特性","feature":true,"_content":"\n\n\n# 从C进步到C++——特性\n\n[TOC]\n\n## 结构体初始化构造\n\n定义结构体时，加入以下语句，可以方便地进行初始化。\n\n```c++\nstruct student{\n\tint id;\n\tchar gender;\n\t\n\tstudent(){}  //系统默认，用于未经初始化定义结构体\n\t\n\tstudent (int _id, char _gender ){\n\t\tid = _id;\n\t\tgender = _gender;\n\t}//用于初始化id和gender。注意：减少参数 可以达到只使用部分元素构造的效果\n}\n```\n\n构造函数可以简化为一行，并且可以进行默认赋值，如此调用时可以省略对应参数。如：\n\n```cpp\nPoint (int x=0 , int y = 0):x(x),y(y) {};\n//Point();\n```\n\n\n\n这是一个二叉树节点的定义示例：\n\n```c++\nstruct TreeNode {\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n    TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n};\n```\n\n\n\n## auto声明推断\n\n使用STL容器时的迭代器声明等等往往比较复杂，此时使用 `auto` 可简单很多：\n\n```c++\nvector<int> vec;\nauto pvec = vec.begin();//vector<int>::iterator\n```\n\n\n\n## 容器类for-range循环\n\n对数组或容器执行循环操作可写成：\n\n```c++\ndouble prices[5] = {1.1 , 2.2 , 3.3 , 4.4 , 5.5}\nfor ( double x : prices){//只读\n\tcout<<x<<endl;\n}\nfor ( double &x : prices){//写需要使用指针\n\tx = x / 2;\n}\n```\n\n\n\n结合上面的auto 部分循环可以写成：\n\n```\nfor ( auto x : vec )\n```\n\n\n\n## string类的类型转换函数\n\n```cpp\nint i = 43;\nstring s = to_string(i);\ndouble d = stod(s);//43.000000\n//对应的有：stoi , stoll , stof\n```\n\n**注意不要传入空串！**\n\n\n\n## rotate/copy/fill函数\n\nrotate函数可以“平移”。直接看例子吧：\n\n```cpp\nvector<int> a{1,2,3,4,5,6,7,8,9};\nrotate(a.begin() , a.begin()+2 , a.end());\n//a:[3,4,5,6,7,8,9,1,2]\n```\n\n相当于得到：[mid:end] + [begin:mid)\n\n\n\ncopy函数将一个目标（容器、数组）里面的元素复制至另一个目标。\n\n**注：使用前 `newvector.resize(7) `这行代码为`newvector`分配空间，防止程序崩溃**。\n\n此外，通过`vector<int>  dp ( 7 , 0 )`也可以达到初始化`dp`为[0,0,0,0,0,0,0].\n\n\n\nfill函数可以为数组和vector赋初始值。头文件：`<algorithm>`\n\n```c++\nint v[10];\nfill(v,v+10,-1);//相当于 memset(v,-1,sizeof v);\nint s[10][10];\nfill(s[0],s[0]+10*10,-1);\n```\n\n\n\n## sort/lower_bound/upper_bound/unique函数\n\nsort函数可用于 `vector `、 数组 和 `deque` 的排序。如：\n\n```cpp\nsort(b,b+n,greater<int>());//将b降序排列\n```\n\n在**已排好升序**的情况下：\n\n1.可使用lower_bound函数（`startptr`，`endptr` ，`num`）得到第一个不小于`num`的值的指针。（二分查找）。如下代码返回下标：\n\n```cpp\nint a[10];//......\nint b = upper_bound(a , a+10 , 3) - a;\n```\n\n2.可使用unique函数返回最后一个非重复元素的指针，如下代码进行**去重**。\n\n```cpp\nvec.erase( unique(vec.begin(),vec.end()) , vec.end() );\n```\n\n拓展排序：partial_sort 方法\n\n\n\n##  局部排序`partiai_sort`\n\n可以提供一定区间的排序获得。原理似乎是堆排序。\n\n```cpp\nfor(i=10;i>=1;i--)\tvec.push_back(i);\npartial_sort(vec.begin(),vec.begin()+3,vec.end());\n//[1,2,3,10,9,8,7,6,5,4]\n\nrep(i,1,10) a.push_back(i);\npartial_sort(vec.begin(),vec.begin()+3,vec.end(),greater<int>());\n//[10,9,8,1,2,3,4,5,6,7]\n```\n\n应用：班上有10个学生，我想知道分数最低的5名是哪些人。如果没有partial_sort，你就需要用sort把所有人排好序，然后再取前5个。现在你只需要对分数最低5名排序。\n\n## 一些可能有用的数学函数\n\n**指对运算**\n\n以下函数：接收x为`float`\t`double`类型，返回传入类型。\n\n`exp2(x)`  - 快速返回2的x次幂。\n\n`log2(x)` - 得到以2为底x的对数。\n\n`log10(x)` - 得到以10为底x的对数。\n\n`log(x)`  - 得到x的自然对数。\n\n`expm(x)` - 返回e的x次幂-1。\n\n`exp(x)` - 得到e的x次幂。x支持complex类型。\n\n**取整函数**\n\n以下函数的传入传出同上。\n\n`floor(x)` - 向下取整。\n\n`ceil(x)` - 向上取整。 \n\n`round(x)` - 四舍五入，基本类似于`floor(x+0.5)`。**但是中点情况下向远离0的方向舍入**。\n\n`trunc(x)` - 将x向0方向舍入。\n\n\n\n## 数组生成- iota/shuffle\n\n递增数组：与 `golang `可对比：\n\n```cpp\niota(arr,arr+n,0);//[0,1,2,3,4,...];\n```\n\n随机打乱数组：\n\n```cpp\nsrand(time(NULL));\nrandom_shuffle(a+1,a+n+1);\n```\n\n`random_shuffle` 自 C++14 起被弃用，C++17 起被移除。可以使用 `shuffle` 函数代替：\n\n`shuffle(v.begin(),v.end(),rand)`（最后一个参数传入的是使用的随机数生成器，一般情况下传入 `rand` 即可）。\n\n使用时需要设置随机数种子，配合`iota`可以实现类似于“洗牌”的效果。同时可进行随机的多次模拟，为了时间种子的不同，可能需要每次模拟间设置`sleep`间隔。\n\n\n\n参考资料：\n\n《C++ Primer》 目录\n\n《C++ Primer Plus》  18.1\n\n《算法竞赛入门经典习题解答》第一章\n\nhttp://www.cppblog.com/mzty/archive/2005/12/15/1770.aspx\n\n\n\n","source":"_posts/从C进步到C++——特性.md","raw":"---\ntitle:\t\tC++ 特性\ntags:\t\tC++,语法\ncategories:\t语言基础\nfeature: true\n---\n\n\n\n# 从C进步到C++——特性\n\n[TOC]\n\n## 结构体初始化构造\n\n定义结构体时，加入以下语句，可以方便地进行初始化。\n\n```c++\nstruct student{\n\tint id;\n\tchar gender;\n\t\n\tstudent(){}  //系统默认，用于未经初始化定义结构体\n\t\n\tstudent (int _id, char _gender ){\n\t\tid = _id;\n\t\tgender = _gender;\n\t}//用于初始化id和gender。注意：减少参数 可以达到只使用部分元素构造的效果\n}\n```\n\n构造函数可以简化为一行，并且可以进行默认赋值，如此调用时可以省略对应参数。如：\n\n```cpp\nPoint (int x=0 , int y = 0):x(x),y(y) {};\n//Point();\n```\n\n\n\n这是一个二叉树节点的定义示例：\n\n```c++\nstruct TreeNode {\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n    TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n};\n```\n\n\n\n## auto声明推断\n\n使用STL容器时的迭代器声明等等往往比较复杂，此时使用 `auto` 可简单很多：\n\n```c++\nvector<int> vec;\nauto pvec = vec.begin();//vector<int>::iterator\n```\n\n\n\n## 容器类for-range循环\n\n对数组或容器执行循环操作可写成：\n\n```c++\ndouble prices[5] = {1.1 , 2.2 , 3.3 , 4.4 , 5.5}\nfor ( double x : prices){//只读\n\tcout<<x<<endl;\n}\nfor ( double &x : prices){//写需要使用指针\n\tx = x / 2;\n}\n```\n\n\n\n结合上面的auto 部分循环可以写成：\n\n```\nfor ( auto x : vec )\n```\n\n\n\n## string类的类型转换函数\n\n```cpp\nint i = 43;\nstring s = to_string(i);\ndouble d = stod(s);//43.000000\n//对应的有：stoi , stoll , stof\n```\n\n**注意不要传入空串！**\n\n\n\n## rotate/copy/fill函数\n\nrotate函数可以“平移”。直接看例子吧：\n\n```cpp\nvector<int> a{1,2,3,4,5,6,7,8,9};\nrotate(a.begin() , a.begin()+2 , a.end());\n//a:[3,4,5,6,7,8,9,1,2]\n```\n\n相当于得到：[mid:end] + [begin:mid)\n\n\n\ncopy函数将一个目标（容器、数组）里面的元素复制至另一个目标。\n\n**注：使用前 `newvector.resize(7) `这行代码为`newvector`分配空间，防止程序崩溃**。\n\n此外，通过`vector<int>  dp ( 7 , 0 )`也可以达到初始化`dp`为[0,0,0,0,0,0,0].\n\n\n\nfill函数可以为数组和vector赋初始值。头文件：`<algorithm>`\n\n```c++\nint v[10];\nfill(v,v+10,-1);//相当于 memset(v,-1,sizeof v);\nint s[10][10];\nfill(s[0],s[0]+10*10,-1);\n```\n\n\n\n## sort/lower_bound/upper_bound/unique函数\n\nsort函数可用于 `vector `、 数组 和 `deque` 的排序。如：\n\n```cpp\nsort(b,b+n,greater<int>());//将b降序排列\n```\n\n在**已排好升序**的情况下：\n\n1.可使用lower_bound函数（`startptr`，`endptr` ，`num`）得到第一个不小于`num`的值的指针。（二分查找）。如下代码返回下标：\n\n```cpp\nint a[10];//......\nint b = upper_bound(a , a+10 , 3) - a;\n```\n\n2.可使用unique函数返回最后一个非重复元素的指针，如下代码进行**去重**。\n\n```cpp\nvec.erase( unique(vec.begin(),vec.end()) , vec.end() );\n```\n\n拓展排序：partial_sort 方法\n\n\n\n##  局部排序`partiai_sort`\n\n可以提供一定区间的排序获得。原理似乎是堆排序。\n\n```cpp\nfor(i=10;i>=1;i--)\tvec.push_back(i);\npartial_sort(vec.begin(),vec.begin()+3,vec.end());\n//[1,2,3,10,9,8,7,6,5,4]\n\nrep(i,1,10) a.push_back(i);\npartial_sort(vec.begin(),vec.begin()+3,vec.end(),greater<int>());\n//[10,9,8,1,2,3,4,5,6,7]\n```\n\n应用：班上有10个学生，我想知道分数最低的5名是哪些人。如果没有partial_sort，你就需要用sort把所有人排好序，然后再取前5个。现在你只需要对分数最低5名排序。\n\n## 一些可能有用的数学函数\n\n**指对运算**\n\n以下函数：接收x为`float`\t`double`类型，返回传入类型。\n\n`exp2(x)`  - 快速返回2的x次幂。\n\n`log2(x)` - 得到以2为底x的对数。\n\n`log10(x)` - 得到以10为底x的对数。\n\n`log(x)`  - 得到x的自然对数。\n\n`expm(x)` - 返回e的x次幂-1。\n\n`exp(x)` - 得到e的x次幂。x支持complex类型。\n\n**取整函数**\n\n以下函数的传入传出同上。\n\n`floor(x)` - 向下取整。\n\n`ceil(x)` - 向上取整。 \n\n`round(x)` - 四舍五入，基本类似于`floor(x+0.5)`。**但是中点情况下向远离0的方向舍入**。\n\n`trunc(x)` - 将x向0方向舍入。\n\n\n\n## 数组生成- iota/shuffle\n\n递增数组：与 `golang `可对比：\n\n```cpp\niota(arr,arr+n,0);//[0,1,2,3,4,...];\n```\n\n随机打乱数组：\n\n```cpp\nsrand(time(NULL));\nrandom_shuffle(a+1,a+n+1);\n```\n\n`random_shuffle` 自 C++14 起被弃用，C++17 起被移除。可以使用 `shuffle` 函数代替：\n\n`shuffle(v.begin(),v.end(),rand)`（最后一个参数传入的是使用的随机数生成器，一般情况下传入 `rand` 即可）。\n\n使用时需要设置随机数种子，配合`iota`可以实现类似于“洗牌”的效果。同时可进行随机的多次模拟，为了时间种子的不同，可能需要每次模拟间设置`sleep`间隔。\n\n\n\n参考资料：\n\n《C++ Primer》 目录\n\n《C++ Primer Plus》  18.1\n\n《算法竞赛入门经典习题解答》第一章\n\nhttp://www.cppblog.com/mzty/archive/2005/12/15/1770.aspx\n\n\n\n","slug":"从C进步到C++——特性","published":1,"date":"2021-09-06T11:11:52.010Z","updated":"2022-01-02T12:08:13.849Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckz6z68tu000gfovv1lqoh3ic","content":"<h1 id=\"从C进步到C-——特性\"><a href=\"#从C进步到C-——特性\" class=\"headerlink\" title=\"从C进步到C++——特性\"></a>从C进步到C++——特性</h1><p>[TOC]</p>\n<h2 id=\"结构体初始化构造\"><a href=\"#结构体初始化构造\" class=\"headerlink\" title=\"结构体初始化构造\"></a>结构体初始化构造</h2><p>定义结构体时，加入以下语句，可以方便地进行初始化。</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">struct student&#123;\n\tint id;\n\tchar gender;\n\t\n\tstudent()&#123;&#125;  &#x2F;&#x2F;系统默认，用于未经初始化定义结构体\n\t\n\tstudent (int _id, char _gender )&#123;\n\t\tid &#x3D; _id;\n\t\tgender &#x3D; _gender;\n\t&#125;&#x2F;&#x2F;用于初始化id和gender。注意：减少参数 可以达到只使用部分元素构造的效果\n&#125;</code></pre>\n\n<p>构造函数可以简化为一行，并且可以进行默认赋值，如此调用时可以省略对应参数。如：</p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">Point (int x&#x3D;0 , int y &#x3D; 0):x(x),y(y) &#123;&#125;;\n&#x2F;&#x2F;Point();</code></pre>\n\n\n\n<p>这是一个二叉树节点的定义示例：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">struct TreeNode &#123;\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n    TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;\n&#125;;</code></pre>\n\n\n\n<h2 id=\"auto声明推断\"><a href=\"#auto声明推断\" class=\"headerlink\" title=\"auto声明推断\"></a>auto声明推断</h2><p>使用STL容器时的迭代器声明等等往往比较复杂，此时使用 <code>auto</code> 可简单很多：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">vector&lt;int&gt; vec;\nauto pvec &#x3D; vec.begin();&#x2F;&#x2F;vector&lt;int&gt;::iterator</code></pre>\n\n\n\n<h2 id=\"容器类for-range循环\"><a href=\"#容器类for-range循环\" class=\"headerlink\" title=\"容器类for-range循环\"></a>容器类for-range循环</h2><p>对数组或容器执行循环操作可写成：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">double prices[5] &#x3D; &#123;1.1 , 2.2 , 3.3 , 4.4 , 5.5&#125;\nfor ( double x : prices)&#123;&#x2F;&#x2F;只读\n\tcout&lt;&lt;x&lt;&lt;endl;\n&#125;\nfor ( double &amp;x : prices)&#123;&#x2F;&#x2F;写需要使用指针\n\tx &#x3D; x &#x2F; 2;\n&#125;</code></pre>\n\n\n\n<p>结合上面的auto 部分循环可以写成：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">for ( auto x : vec )</code></pre>\n\n\n\n<h2 id=\"string类的类型转换函数\"><a href=\"#string类的类型转换函数\" class=\"headerlink\" title=\"string类的类型转换函数\"></a>string类的类型转换函数</h2><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">int i &#x3D; 43;\nstring s &#x3D; to_string(i);\ndouble d &#x3D; stod(s);&#x2F;&#x2F;43.000000\n&#x2F;&#x2F;对应的有：stoi , stoll , stof</code></pre>\n\n<p><strong>注意不要传入空串！</strong></p>\n<h2 id=\"rotate-copy-fill函数\"><a href=\"#rotate-copy-fill函数\" class=\"headerlink\" title=\"rotate/copy/fill函数\"></a>rotate/copy/fill函数</h2><p>rotate函数可以“平移”。直接看例子吧：</p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">vector&lt;int&gt; a&#123;1,2,3,4,5,6,7,8,9&#125;;\nrotate(a.begin() , a.begin()+2 , a.end());\n&#x2F;&#x2F;a:[3,4,5,6,7,8,9,1,2]</code></pre>\n\n<p>相当于得到：[mid:end] + [begin:mid)</p>\n<p>copy函数将一个目标（容器、数组）里面的元素复制至另一个目标。</p>\n<p><strong>注：使用前 <code>newvector.resize(7) </code>这行代码为<code>newvector</code>分配空间，防止程序崩溃</strong>。</p>\n<p>此外，通过<code>vector&lt;int&gt;  dp ( 7 , 0 )</code>也可以达到初始化<code>dp</code>为[0,0,0,0,0,0,0].</p>\n<p>fill函数可以为数组和vector赋初始值。头文件：<code>&lt;algorithm&gt;</code></p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">int v[10];\nfill(v,v+10,-1);&#x2F;&#x2F;相当于 memset(v,-1,sizeof v);\nint s[10][10];\nfill(s[0],s[0]+10*10,-1);</code></pre>\n\n\n\n<h2 id=\"sort-lower-bound-upper-bound-unique函数\"><a href=\"#sort-lower-bound-upper-bound-unique函数\" class=\"headerlink\" title=\"sort/lower_bound/upper_bound/unique函数\"></a>sort/lower_bound/upper_bound/unique函数</h2><p>sort函数可用于 <code>vector </code>、 数组 和 <code>deque</code> 的排序。如：</p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">sort(b,b+n,greater&lt;int&gt;());&#x2F;&#x2F;将b降序排列</code></pre>\n\n<p>在<strong>已排好升序</strong>的情况下：</p>\n<p>1.可使用lower_bound函数（<code>startptr</code>，<code>endptr</code> ，<code>num</code>）得到第一个不小于<code>num</code>的值的指针。（二分查找）。如下代码返回下标：</p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">int a[10];&#x2F;&#x2F;......\nint b &#x3D; upper_bound(a , a+10 , 3) - a;</code></pre>\n\n<p>2.可使用unique函数返回最后一个非重复元素的指针，如下代码进行<strong>去重</strong>。</p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">vec.erase( unique(vec.begin(),vec.end()) , vec.end() );</code></pre>\n\n<p>拓展排序：partial_sort 方法</p>\n<h2 id=\"局部排序partiai-sort\"><a href=\"#局部排序partiai-sort\" class=\"headerlink\" title=\"局部排序partiai_sort\"></a>局部排序<code>partiai_sort</code></h2><p>可以提供一定区间的排序获得。原理似乎是堆排序。</p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">for(i&#x3D;10;i&gt;&#x3D;1;i--)\tvec.push_back(i);\npartial_sort(vec.begin(),vec.begin()+3,vec.end());\n&#x2F;&#x2F;[1,2,3,10,9,8,7,6,5,4]\n\nrep(i,1,10) a.push_back(i);\npartial_sort(vec.begin(),vec.begin()+3,vec.end(),greater&lt;int&gt;());\n&#x2F;&#x2F;[10,9,8,1,2,3,4,5,6,7]</code></pre>\n\n<p>应用：班上有10个学生，我想知道分数最低的5名是哪些人。如果没有partial_sort，你就需要用sort把所有人排好序，然后再取前5个。现在你只需要对分数最低5名排序。</p>\n<h2 id=\"一些可能有用的数学函数\"><a href=\"#一些可能有用的数学函数\" class=\"headerlink\" title=\"一些可能有用的数学函数\"></a>一些可能有用的数学函数</h2><p><strong>指对运算</strong></p>\n<p>以下函数：接收x为<code>float</code>    <code>double</code>类型，返回传入类型。</p>\n<p><code>exp2(x)</code>  - 快速返回2的x次幂。</p>\n<p><code>log2(x)</code> - 得到以2为底x的对数。</p>\n<p><code>log10(x)</code> - 得到以10为底x的对数。</p>\n<p><code>log(x)</code>  - 得到x的自然对数。</p>\n<p><code>expm(x)</code> - 返回e的x次幂-1。</p>\n<p><code>exp(x)</code> - 得到e的x次幂。x支持complex类型。</p>\n<p><strong>取整函数</strong></p>\n<p>以下函数的传入传出同上。</p>\n<p><code>floor(x)</code> - 向下取整。</p>\n<p><code>ceil(x)</code> - 向上取整。 </p>\n<p><code>round(x)</code> - 四舍五入，基本类似于<code>floor(x+0.5)</code>。<strong>但是中点情况下向远离0的方向舍入</strong>。</p>\n<p><code>trunc(x)</code> - 将x向0方向舍入。</p>\n<h2 id=\"数组生成-iota-shuffle\"><a href=\"#数组生成-iota-shuffle\" class=\"headerlink\" title=\"数组生成- iota/shuffle\"></a>数组生成- iota/shuffle</h2><p>递增数组：与 <code>golang </code>可对比：</p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">iota(arr,arr+n,0);&#x2F;&#x2F;[0,1,2,3,4,...];</code></pre>\n\n<p>随机打乱数组：</p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">srand(time(NULL));\nrandom_shuffle(a+1,a+n+1);</code></pre>\n\n<p><code>random_shuffle</code> 自 C++14 起被弃用，C++17 起被移除。可以使用 <code>shuffle</code> 函数代替：</p>\n<p><code>shuffle(v.begin(),v.end(),rand)</code>（最后一个参数传入的是使用的随机数生成器，一般情况下传入 <code>rand</code> 即可）。</p>\n<p>使用时需要设置随机数种子，配合<code>iota</code>可以实现类似于“洗牌”的效果。同时可进行随机的多次模拟，为了时间种子的不同，可能需要每次模拟间设置<code>sleep</code>间隔。</p>\n<p>参考资料：</p>\n<p>《C++ Primer》 目录</p>\n<p>《C++ Primer Plus》  18.1</p>\n<p>《算法竞赛入门经典习题解答》第一章</p>\n<p><a href=\"http://www.cppblog.com/mzty/archive/2005/12/15/1770.aspx\">http://www.cppblog.com/mzty/archive/2005/12/15/1770.aspx</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"从C进步到C-——特性\"><a href=\"#从C进步到C-——特性\" class=\"headerlink\" title=\"从C进步到C++——特性\"></a>从C进步到C++——特性</h1><p>[TOC]</p>\n<h2 id=\"结构体初始化构造\"><a href=\"#结构体初始化构造\" class=\"headerlink\" title=\"结构体初始化构造\"></a>结构体初始化构造</h2><p>定义结构体时，加入以下语句，可以方便地进行初始化。</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">struct student&#123;\n\tint id;\n\tchar gender;\n\t\n\tstudent()&#123;&#125;  &#x2F;&#x2F;系统默认，用于未经初始化定义结构体\n\t\n\tstudent (int _id, char _gender )&#123;\n\t\tid &#x3D; _id;\n\t\tgender &#x3D; _gender;\n\t&#125;&#x2F;&#x2F;用于初始化id和gender。注意：减少参数 可以达到只使用部分元素构造的效果\n&#125;</code></pre>\n\n<p>构造函数可以简化为一行，并且可以进行默认赋值，如此调用时可以省略对应参数。如：</p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">Point (int x&#x3D;0 , int y &#x3D; 0):x(x),y(y) &#123;&#125;;\n&#x2F;&#x2F;Point();</code></pre>\n\n\n\n<p>这是一个二叉树节点的定义示例：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">struct TreeNode &#123;\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n    TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;\n&#125;;</code></pre>\n\n\n\n<h2 id=\"auto声明推断\"><a href=\"#auto声明推断\" class=\"headerlink\" title=\"auto声明推断\"></a>auto声明推断</h2><p>使用STL容器时的迭代器声明等等往往比较复杂，此时使用 <code>auto</code> 可简单很多：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">vector&lt;int&gt; vec;\nauto pvec &#x3D; vec.begin();&#x2F;&#x2F;vector&lt;int&gt;::iterator</code></pre>\n\n\n\n<h2 id=\"容器类for-range循环\"><a href=\"#容器类for-range循环\" class=\"headerlink\" title=\"容器类for-range循环\"></a>容器类for-range循环</h2><p>对数组或容器执行循环操作可写成：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">double prices[5] &#x3D; &#123;1.1 , 2.2 , 3.3 , 4.4 , 5.5&#125;\nfor ( double x : prices)&#123;&#x2F;&#x2F;只读\n\tcout&lt;&lt;x&lt;&lt;endl;\n&#125;\nfor ( double &amp;x : prices)&#123;&#x2F;&#x2F;写需要使用指针\n\tx &#x3D; x &#x2F; 2;\n&#125;</code></pre>\n\n\n\n<p>结合上面的auto 部分循环可以写成：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">for ( auto x : vec )</code></pre>\n\n\n\n<h2 id=\"string类的类型转换函数\"><a href=\"#string类的类型转换函数\" class=\"headerlink\" title=\"string类的类型转换函数\"></a>string类的类型转换函数</h2><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">int i &#x3D; 43;\nstring s &#x3D; to_string(i);\ndouble d &#x3D; stod(s);&#x2F;&#x2F;43.000000\n&#x2F;&#x2F;对应的有：stoi , stoll , stof</code></pre>\n\n<p><strong>注意不要传入空串！</strong></p>\n<h2 id=\"rotate-copy-fill函数\"><a href=\"#rotate-copy-fill函数\" class=\"headerlink\" title=\"rotate/copy/fill函数\"></a>rotate/copy/fill函数</h2><p>rotate函数可以“平移”。直接看例子吧：</p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">vector&lt;int&gt; a&#123;1,2,3,4,5,6,7,8,9&#125;;\nrotate(a.begin() , a.begin()+2 , a.end());\n&#x2F;&#x2F;a:[3,4,5,6,7,8,9,1,2]</code></pre>\n\n<p>相当于得到：[mid:end] + [begin:mid)</p>\n<p>copy函数将一个目标（容器、数组）里面的元素复制至另一个目标。</p>\n<p><strong>注：使用前 <code>newvector.resize(7) </code>这行代码为<code>newvector</code>分配空间，防止程序崩溃</strong>。</p>\n<p>此外，通过<code>vector&lt;int&gt;  dp ( 7 , 0 )</code>也可以达到初始化<code>dp</code>为[0,0,0,0,0,0,0].</p>\n<p>fill函数可以为数组和vector赋初始值。头文件：<code>&lt;algorithm&gt;</code></p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">int v[10];\nfill(v,v+10,-1);&#x2F;&#x2F;相当于 memset(v,-1,sizeof v);\nint s[10][10];\nfill(s[0],s[0]+10*10,-1);</code></pre>\n\n\n\n<h2 id=\"sort-lower-bound-upper-bound-unique函数\"><a href=\"#sort-lower-bound-upper-bound-unique函数\" class=\"headerlink\" title=\"sort/lower_bound/upper_bound/unique函数\"></a>sort/lower_bound/upper_bound/unique函数</h2><p>sort函数可用于 <code>vector </code>、 数组 和 <code>deque</code> 的排序。如：</p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">sort(b,b+n,greater&lt;int&gt;());&#x2F;&#x2F;将b降序排列</code></pre>\n\n<p>在<strong>已排好升序</strong>的情况下：</p>\n<p>1.可使用lower_bound函数（<code>startptr</code>，<code>endptr</code> ，<code>num</code>）得到第一个不小于<code>num</code>的值的指针。（二分查找）。如下代码返回下标：</p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">int a[10];&#x2F;&#x2F;......\nint b &#x3D; upper_bound(a , a+10 , 3) - a;</code></pre>\n\n<p>2.可使用unique函数返回最后一个非重复元素的指针，如下代码进行<strong>去重</strong>。</p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">vec.erase( unique(vec.begin(),vec.end()) , vec.end() );</code></pre>\n\n<p>拓展排序：partial_sort 方法</p>\n<h2 id=\"局部排序partiai-sort\"><a href=\"#局部排序partiai-sort\" class=\"headerlink\" title=\"局部排序partiai_sort\"></a>局部排序<code>partiai_sort</code></h2><p>可以提供一定区间的排序获得。原理似乎是堆排序。</p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">for(i&#x3D;10;i&gt;&#x3D;1;i--)\tvec.push_back(i);\npartial_sort(vec.begin(),vec.begin()+3,vec.end());\n&#x2F;&#x2F;[1,2,3,10,9,8,7,6,5,4]\n\nrep(i,1,10) a.push_back(i);\npartial_sort(vec.begin(),vec.begin()+3,vec.end(),greater&lt;int&gt;());\n&#x2F;&#x2F;[10,9,8,1,2,3,4,5,6,7]</code></pre>\n\n<p>应用：班上有10个学生，我想知道分数最低的5名是哪些人。如果没有partial_sort，你就需要用sort把所有人排好序，然后再取前5个。现在你只需要对分数最低5名排序。</p>\n<h2 id=\"一些可能有用的数学函数\"><a href=\"#一些可能有用的数学函数\" class=\"headerlink\" title=\"一些可能有用的数学函数\"></a>一些可能有用的数学函数</h2><p><strong>指对运算</strong></p>\n<p>以下函数：接收x为<code>float</code>    <code>double</code>类型，返回传入类型。</p>\n<p><code>exp2(x)</code>  - 快速返回2的x次幂。</p>\n<p><code>log2(x)</code> - 得到以2为底x的对数。</p>\n<p><code>log10(x)</code> - 得到以10为底x的对数。</p>\n<p><code>log(x)</code>  - 得到x的自然对数。</p>\n<p><code>expm(x)</code> - 返回e的x次幂-1。</p>\n<p><code>exp(x)</code> - 得到e的x次幂。x支持complex类型。</p>\n<p><strong>取整函数</strong></p>\n<p>以下函数的传入传出同上。</p>\n<p><code>floor(x)</code> - 向下取整。</p>\n<p><code>ceil(x)</code> - 向上取整。 </p>\n<p><code>round(x)</code> - 四舍五入，基本类似于<code>floor(x+0.5)</code>。<strong>但是中点情况下向远离0的方向舍入</strong>。</p>\n<p><code>trunc(x)</code> - 将x向0方向舍入。</p>\n<h2 id=\"数组生成-iota-shuffle\"><a href=\"#数组生成-iota-shuffle\" class=\"headerlink\" title=\"数组生成- iota/shuffle\"></a>数组生成- iota/shuffle</h2><p>递增数组：与 <code>golang </code>可对比：</p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">iota(arr,arr+n,0);&#x2F;&#x2F;[0,1,2,3,4,...];</code></pre>\n\n<p>随机打乱数组：</p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">srand(time(NULL));\nrandom_shuffle(a+1,a+n+1);</code></pre>\n\n<p><code>random_shuffle</code> 自 C++14 起被弃用，C++17 起被移除。可以使用 <code>shuffle</code> 函数代替：</p>\n<p><code>shuffle(v.begin(),v.end(),rand)</code>（最后一个参数传入的是使用的随机数生成器，一般情况下传入 <code>rand</code> 即可）。</p>\n<p>使用时需要设置随机数种子，配合<code>iota</code>可以实现类似于“洗牌”的效果。同时可进行随机的多次模拟，为了时间种子的不同，可能需要每次模拟间设置<code>sleep</code>间隔。</p>\n<p>参考资料：</p>\n<p>《C++ Primer》 目录</p>\n<p>《C++ Primer Plus》  18.1</p>\n<p>《算法竞赛入门经典习题解答》第一章</p>\n<p><a href=\"http://www.cppblog.com/mzty/archive/2005/12/15/1770.aspx\">http://www.cppblog.com/mzty/archive/2005/12/15/1770.aspx</a></p>\n"},{"title":"C/C++ 多维数组的处理","_content":"\n\n\n笔者要用到多维数组的时候经常忘了多维数组怎么用，在此总结一下：\n\n【内容产出中】\n\n1.二维数组的函数调用实例\n\n```c\n//声明\nvoid bubbleSort(float (*num)[40],int size);\n//调用\nbubbleSort( stu , 40);\n//思想：二维数组——数组的数组\n```\n\n2.把二维数组当一维数组进行赋值：\n\n```c\nint *p=&a[0][0];//获取二维数组首地址\nfor(int i=0;i<6;i++)\n{\nscnaf(\"%d\",p);\np++;\n}\n```\n\n3.使用 C++ 容器时，若可以使用`at`等方法获得对应元素，以缓解运算符`[]`的不稳定性问题。\n\n如： array（C++11）\n\n| 函数         | 作用                                                         |\n| ------------ | ------------------------------------------------------------ |\n| `at`         | 访问指定的元素，同时进行越界检查`at` 若遇 `pos >= size()` 的情况会抛出 `std::out_of_range`。 |\n| `operator[]` | 访问指定的元素，**不** 进行越界检查                          |\n\n4.多维vector的行列空间预留\n\n```\n vector<vector<bool> > table(256);//256行\n table.resize(512);//512列\n```\n\n","source":"_posts/C中多维数组的处理.md","raw":"---\ntitle: C/C++ 多维数组的处理\n---\n\n\n\n笔者要用到多维数组的时候经常忘了多维数组怎么用，在此总结一下：\n\n【内容产出中】\n\n1.二维数组的函数调用实例\n\n```c\n//声明\nvoid bubbleSort(float (*num)[40],int size);\n//调用\nbubbleSort( stu , 40);\n//思想：二维数组——数组的数组\n```\n\n2.把二维数组当一维数组进行赋值：\n\n```c\nint *p=&a[0][0];//获取二维数组首地址\nfor(int i=0;i<6;i++)\n{\nscnaf(\"%d\",p);\np++;\n}\n```\n\n3.使用 C++ 容器时，若可以使用`at`等方法获得对应元素，以缓解运算符`[]`的不稳定性问题。\n\n如： array（C++11）\n\n| 函数         | 作用                                                         |\n| ------------ | ------------------------------------------------------------ |\n| `at`         | 访问指定的元素，同时进行越界检查`at` 若遇 `pos >= size()` 的情况会抛出 `std::out_of_range`。 |\n| `operator[]` | 访问指定的元素，**不** 进行越界检查                          |\n\n4.多维vector的行列空间预留\n\n```\n vector<vector<bool> > table(256);//256行\n table.resize(512);//512列\n```\n\n","slug":"C中多维数组的处理","published":1,"date":"2021-09-19T13:17:35.450Z","updated":"2021-11-29T15:08:17.177Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckz6z68vy000jfovv1n060xfl","content":"<p>笔者要用到多维数组的时候经常忘了多维数组怎么用，在此总结一下：</p>\n<p>【内容产出中】</p>\n<p>1.二维数组的函数调用实例</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">&#x2F;&#x2F;声明\nvoid bubbleSort(float (*num)[40],int size);\n&#x2F;&#x2F;调用\nbubbleSort( stu , 40);\n&#x2F;&#x2F;思想：二维数组——数组的数组</code></pre>\n\n<p>2.把二维数组当一维数组进行赋值：</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">int *p&#x3D;&amp;a[0][0];&#x2F;&#x2F;获取二维数组首地址\nfor(int i&#x3D;0;i&lt;6;i++)\n&#123;\nscnaf(&quot;%d&quot;,p);\np++;\n&#125;</code></pre>\n\n<p>3.使用 C++ 容器时，若可以使用<code>at</code>等方法获得对应元素，以缓解运算符<code>[]</code>的不稳定性问题。</p>\n<p>如： array（C++11）</p>\n<table>\n<thead>\n<tr>\n<th>函数</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>at</code></td>\n<td>访问指定的元素，同时进行越界检查<code>at</code> 若遇 <code>pos &gt;= size()</code> 的情况会抛出 <code>std::out_of_range</code>。</td>\n</tr>\n<tr>\n<td><code>operator[]</code></td>\n<td>访问指定的元素，<strong>不</strong> 进行越界检查</td>\n</tr>\n</tbody></table>\n<p>4.多维vector的行列空间预留</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">vector&lt;vector&lt;bool&gt; &gt; table(256);&#x2F;&#x2F;256行\ntable.resize(512);&#x2F;&#x2F;512列</code></pre>\n\n","site":{"data":{}},"excerpt":"","more":"<p>笔者要用到多维数组的时候经常忘了多维数组怎么用，在此总结一下：</p>\n<p>【内容产出中】</p>\n<p>1.二维数组的函数调用实例</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">&#x2F;&#x2F;声明\nvoid bubbleSort(float (*num)[40],int size);\n&#x2F;&#x2F;调用\nbubbleSort( stu , 40);\n&#x2F;&#x2F;思想：二维数组——数组的数组</code></pre>\n\n<p>2.把二维数组当一维数组进行赋值：</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">int *p&#x3D;&amp;a[0][0];&#x2F;&#x2F;获取二维数组首地址\nfor(int i&#x3D;0;i&lt;6;i++)\n&#123;\nscnaf(&quot;%d&quot;,p);\np++;\n&#125;</code></pre>\n\n<p>3.使用 C++ 容器时，若可以使用<code>at</code>等方法获得对应元素，以缓解运算符<code>[]</code>的不稳定性问题。</p>\n<p>如： array（C++11）</p>\n<table>\n<thead>\n<tr>\n<th>函数</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>at</code></td>\n<td>访问指定的元素，同时进行越界检查<code>at</code> 若遇 <code>pos &gt;= size()</code> 的情况会抛出 <code>std::out_of_range</code>。</td>\n</tr>\n<tr>\n<td><code>operator[]</code></td>\n<td>访问指定的元素，<strong>不</strong> 进行越界检查</td>\n</tr>\n</tbody></table>\n<p>4.多维vector的行列空间预留</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">vector&lt;vector&lt;bool&gt; &gt; table(256);&#x2F;&#x2F;256行\ntable.resize(512);&#x2F;&#x2F;512列</code></pre>\n\n"},{"_content":"title:\t\tC++ STL使用手册\ntags:\t\tC++,语法\ncategories:\t语言基础\nfeature: true\n\n#C++ STL的使用手册\n\n[toc]\n\n![img](https://oi-wiki.org/lang/csl/images/container1.png)\n\n### 共有函数\n\n`=`：有赋值运算符以及复制构造函数。\n\n`begin()`：返回指向开头元素的迭代器。\n\n`end()`：返回指向末尾的下一个元素的迭代器。`end()` **不指向某个元素**，它是末尾元素的后继。\n\n`size()`：返回容器内的元素个数。\n\n`max_size()`：返回容器 **理论上** 能存储的最大元素个数。依容器类型和所存储变量的类型而变。\n\n`empty()`：返回容器是否为空的一个 `bool` 值，即 `begin() == end()`，`true` 为空，`false` 为非空。\n\n`swap()`：交换两个容器。\n\n`clear()`：清空容器。\n\n`==`/`!=`/`<`/`>`/`<=`/`>=`：按 **字典序** 比较两个容器的大小。（比较元素大小时 `map` 的每个元素相当于 `set<pair<key, value> >`，`pair` 按 first 到 second 的顺序比较。无序容器不支持 `<`/`>`/`<=`/`>=`\n\n## 序列式容器\n\n### vector\n\n**元素访问**\n\n1. `at()`\n\n   `v.at(pos)` 返回容器中下标为 `pos` 的引用。如果数组越界抛出 `std::out_of_range` 类型的异常。\n\n2. `operator[]`\n\n   `v[pos]` 返回容器中下标为 `pos` 的引用。不执行越界检查。\n\n3. `front()`\n\n   `v.front()` 返回首元素的引用。\n\n4. `back()`\n\n   `v.back()` 返回末尾元素的引用。\n\n**迭代器**\n\n   1. `begin()/cbegin()`\n\n      返回指向首元素的迭代器，其中 `*begin = front`。\n\n   2. `end()/cend()`\n\n      返回指向数组尾端占位符的迭代器，注意是没有元素的。\n      \n\n 可以认为，`v[i]`与`*(v.begin()+i)`等价。但，**除`vector` `string`外**，其他STL容器不支持后者的形式。\n\n\n- `size()` 返回容器长度（元素数量），即 `std::distance(v.begin(), v.end())`。\n\n- `insert()` 支持在某个迭代器位置插入元素、可以插入多个。**复杂度与 `pos` 距离末尾长度成线性而非常数**\n\n- `erase()` 删除某个**迭代器或者区间的元素**，返回最后被删除的迭代器。复杂度与 `insert` 一致。\n\n- `push_back(x)` 在末尾插入一个元素x，均摊复杂度：常数，最坏为线性复杂度。\n\n- `pop_back()` 删除末尾元素，常数复杂度。\n\n  \n\n### deque\n\n能够提供线性复杂度的插入和删除，以及常数复杂度的随机访问。操作大同`vector`。\n\n- `push_front()` 在头部插入一个元素。\n\n- `pop_front()` 删除头部元素。\n\n- `push_back()` 在末尾插入一个元素。\n\n- `pop_back()` 删除末尾元素。\n\n  \n\n### list\n\n与`deque`大致相同，但是由于 `list` 的实现是链表，因此不提供随机访问的接口。若需要访问中间元素，则需要使用迭代器。\n\n- `front()` 返回首元素的引用。\n\n- `back()` 返回末尾元素的引用。\n\n  \n\n### array(C++11)\n\n| 成员函数    | 作用                                      | 示例         |\n| :---------- | :---------------------------------------- | ------------ |\n| `operator=` | `array2` 的每个元素重写 `array1` 对应元素 |              |\n| `max_size`  | 返回可容纳的最大元素数                    |              |\n| `fill`      | 以指定值填充容器                          | arr.fill(1); |\n| `swap`      | 交换，交换array的复杂度为：O(size)        |              |\n\n| 非成员函数   | 作用                          |\n| :----------- | :---------------------------- |\n| `operator==` | 按照字典序比较 `array` 中的值 |\n| `std::get`   | 访问 `array` 的一个元素       |\n\n## 关联式容器\n\n### 统一共有函数\n\n- `find(x)`: 若容器内存在键为 x 的元素，会返回该元素的迭代器；否则返回 `end()`。\n\n  ![image-20211015124758889](C:\\Users\\ll\\AppData\\Roaming\\Typora\\typora-user-images\\image-20211015124758889.png)\n\n- `erase(pos)` 删除迭代器为 pos 的元素，可结合`find`函数使用。\n\n- `erase(first,last)` 删除迭代器在 [first,last)范围内的所有元素。\n\n- `count(x)`: 返回容器内键为 x 的元素数量。\n\n- `lower_bound(x)`: 返回指向首个**不小于** 给定**键**的元素的迭代器。\n\n- `upper_bound(x)`: 返回指向首个**大于 **给定键的元素的迭代器。若容器内所有元素均小于或等于给定键，返回 `end()`。\n\n- `size()`: 返回容器内元素个数。\n\n### set\n\n`set` 内部采用红黑树实现。平衡二叉树的特性使得 `set` 非常适合处理需要同时兼顾查找、插入与删除的情况。\n\n- `insert(x)` 将元素 x 插入到 `set` 中。自动排序和去重。\n- `erase(x)` 删除值为 x 的 **所有** 元素，返回删除元素的个数。\n- `erase(first,last)` 删除迭代器在 [first,last)范围内的所有元素。\n\n### map\n\n`map` 重载了 `operator[]`，可以用任意定义了 `operator <` 的类型作为下标（在 `map` 中叫做 `key`，也就是索引）。\n\n- 可以直接通过下标访问来进行查询或插入操作。例： `mp[\"Alan\"]=100`。利用下标访问 时，如果 `map` 中不存在相应键的元素，会自动在 `map` 中插入一个新元素，并将其值设置为默认值（对于整数，值为零；对于有默认构造函数的类型，会调用默认构造函数进行初始化）\n- 通过向 `map` 中插入一个类型为 `pair<Key, T>` 的值可以达到插入元素的目的，例如 `mp.insert(pair<string,int>(\"Alan\",100));`\n- `erase(key)` 函数会删除键为 `key` 的 **所有** 元素。返回值为删除元素的数量。\n\n## 哈希适配容器\n\n四种基于哈希实现的无序关联式容器：`unordered_set`，`unordered_multiset`，`unordered_map`，`unordered_multimap`。\n\n其操作与关联式容器类似。\n\n## 容器适配器\n\n为什么称为容器适配器呢，是因为其内部的实现是基于`vector`  `deque ` 等等，其原理可以参考《STL源码剖析》。\n\n### 后进先出的stack\n\n仅支持查询或删除最后一个加入的元素（栈顶元素），不支持随机访问。\n\n- `top()` 访问栈顶元素（如果栈为空，此处会出错）\n- `push(x)` 向栈中插入元素 x\n- `pop()` 删除栈顶元素\n\n### 先进先出的queue\n\n- `front()` 访问队首元素（如果队列为空，此处会出错）\n- `push(x)` 向队列中插入元素 x\n- `pop()` 删除队首元素\n\n### 优先队列\n\n- `top()` 访问堆顶元素（此时优先队列不能为空）\n\n- `push(x)` 插入元素，并对底层容器排序\n\n- `pop()` 删除堆顶元素（此时优先队列不能为空）\n\n以上`pop`方法，返回已删除元素的值。\n\n- 优先级的定义：\n\n  对于数字，一般是值大者优先。即默认为：\n\n  `priority_queue<int,vector<int>,less<int> > pq;`\n\n  第二个参数是内部实现方式；第三个参数  **less表示数字大的优先级越大。如果是`greater<int>`，则为数字小者优先级大。**优先级大者，位于`top`。\n\n  结构体也可以定义优先级，可以通过`cmp`函数或者重载`<`运算符实现。这种思路也适用于其他关联式容器。\n\n### pair的常见用法\n\n头文件：`<utility>`\n\n按照正常的结构体访问（first，second…）。\n\n### string的常见用法\n\n`string`的实现形式类似于字符型`vector`，支持`push_back`、直接赋值（注意使用**双引号**）和下标访问。只支持`cin` `cout`，不支持`printf`等。\n\n- 可以通过加减运算符实现字符串拼接和删减、比较运算符进行字典序比较。\n\n- `substr(pos,len)`方法截取子串。时间复杂度是O（len）。\n\n- `find(x,pos)`指定了开始寻找的位置为下标`pos`\n\n- 上面的共有函数（`erase` `find`等）也是支持的。复杂度都是O(n)\n\n  ```cpp\n  string s1 = \"Hello\";\n  string s2 = \"world\";\n  s1.insert(3,s2);//Helworldlo\n  ```\n  \n  \n\n### STL算法\n\n在《特性》篇也介绍有一些用法。\n\n- `find_end`：逆序查找。`find_end(v.begin(), v.end(), value)`。\n- `nth_element`：按指定范围进行分类，即找出序列中第 *n* 大的元素，使其左边均为小于它的数，右边均为大于它的数。`nth_element(v.begin(), v.begin() + mid, v.end(), cmp)` 或 `nth_element(a + begin, a + begin + mid, a + end, cmp)`\n- `next_permutation`：将当前排列更改为 **全排列中的下一个排列**。如果当前排列已经是 **全排列中的最后一个排列**（元素完全从大到小排列），函数返回 `false` 并将排列更改为 **全排列中的第一个排列**（元素完全从小到大排列）；否则，函数返回 `true`。`next_permutation(v.begin(), v.end())` 或 `next_permutation(v + begin, v + end)`。\n\n### bitset\n\n通过固定的优化，使得一个字节的八个比特能分别储存 8 位的 `0/1`。\n\n头文件：`<bitset>`\n\n- `bitset()`: 每一位都是 `false`。\n- `bitset(int val)`: 设为 `val` 的二进制形式。\n- `bitset(const string& str)`: 设为 01 串 `str`。\n\n```cpp\nbitset<4> bitset1;　　//无初始化下，默认每一位均为0\nbitset<8> bitset2(16);　//保存长度为8的16的二进制表示：[00010000]\nstring s = \"10010\";\nbitset<8> bitset3(s);　　//长度为10，前补0。[00010010]\n```\n\n- `operator []`: 访问其特定的一位。\n- `operator ==/!=`: 比较两个 `bitset` 内容是否完全一样。\n- `operator &/&=/|/| =/^/^=/~`: 进行按位与/或/异或/取反操作。**`bitset` 只能与 `bitset` 进行位运算**，若要和整型进行位运算，要先将整型转换为 `bitset`。\n- `operator <>/<<=/>>=`: 进行二进制左移/右移。\n- `operator <>`: 流运算符，这意味着你可以通过 `cin/cout` 进行输入输出。\n- `count()`: 返回 `true` 的数量。\n- `size()`: 返回 `bitset` 的大小。\n- `test(pos)`: 它和 `vector` 中的 `at()` 的作用是一样的，和 `[]` 运算符的区别就是越界检查。\n- `to_string()`: 返回转换成的字符串表达。\n- `to_ulong()`: 返回转换成的 `unsigned long` 表达 (`long` 在 NT 及 32 位 POSIX 系统下与 `int` 一样，在 64 位 POSIX 下与 `long long` 一样）。\n- `to_ullong()`:*C++11*，返回转换成的 `unsigned long long` 表达。\n- `any()`: 若存在某一位是 `true` 则返回 `true`，否则返回 `false`。\n- `none()`: 若所有位都是 `false` 则返回 `true`，否则返回 `false`。\n- `all()`:*C++11*，若所有位都是 `true` 则返回 `true`，否则返回 `false`。\n- `set()`: 将整个 `bitset` 设置成 `true`。\n\n  `set(pos, val = true)`: 将某一位设置成 `true`/`false`。\n- `reset()`: 将整个 `bitset` 设置成 `false`。\n\n  `reset(pos)`: 将某一位设置成 `false`。相当于 `set(pos, false)`。\n- `flip()`: 翻转每一位。（01互换，相当于异或一个全是1 的 `bitset`）\n\n  `flip(pos)`: 翻转某一位。\n\n- `_Find_first()`: 返回 `bitset` 第一个 `true` 的下标，若没有 `true` 则返回 `bitset` 的大小。\n\n- `_Find_next(pos)`: 返回 `pos` 后面（下标严格大于 `pos` 的位置）第一个 `true` 的下标，若 `pos` 后面没有 `true` 则返回 `bitset` 的大小。\n\n  \n\n参考资料：\n\nOI-wiki\n\n《算法笔记》","source":"_posts/C++STL的使用.md","raw":"title:\t\tC++ STL使用手册\ntags:\t\tC++,语法\ncategories:\t语言基础\nfeature: true\n\n#C++ STL的使用手册\n\n[toc]\n\n![img](https://oi-wiki.org/lang/csl/images/container1.png)\n\n### 共有函数\n\n`=`：有赋值运算符以及复制构造函数。\n\n`begin()`：返回指向开头元素的迭代器。\n\n`end()`：返回指向末尾的下一个元素的迭代器。`end()` **不指向某个元素**，它是末尾元素的后继。\n\n`size()`：返回容器内的元素个数。\n\n`max_size()`：返回容器 **理论上** 能存储的最大元素个数。依容器类型和所存储变量的类型而变。\n\n`empty()`：返回容器是否为空的一个 `bool` 值，即 `begin() == end()`，`true` 为空，`false` 为非空。\n\n`swap()`：交换两个容器。\n\n`clear()`：清空容器。\n\n`==`/`!=`/`<`/`>`/`<=`/`>=`：按 **字典序** 比较两个容器的大小。（比较元素大小时 `map` 的每个元素相当于 `set<pair<key, value> >`，`pair` 按 first 到 second 的顺序比较。无序容器不支持 `<`/`>`/`<=`/`>=`\n\n## 序列式容器\n\n### vector\n\n**元素访问**\n\n1. `at()`\n\n   `v.at(pos)` 返回容器中下标为 `pos` 的引用。如果数组越界抛出 `std::out_of_range` 类型的异常。\n\n2. `operator[]`\n\n   `v[pos]` 返回容器中下标为 `pos` 的引用。不执行越界检查。\n\n3. `front()`\n\n   `v.front()` 返回首元素的引用。\n\n4. `back()`\n\n   `v.back()` 返回末尾元素的引用。\n\n**迭代器**\n\n   1. `begin()/cbegin()`\n\n      返回指向首元素的迭代器，其中 `*begin = front`。\n\n   2. `end()/cend()`\n\n      返回指向数组尾端占位符的迭代器，注意是没有元素的。\n      \n\n 可以认为，`v[i]`与`*(v.begin()+i)`等价。但，**除`vector` `string`外**，其他STL容器不支持后者的形式。\n\n\n- `size()` 返回容器长度（元素数量），即 `std::distance(v.begin(), v.end())`。\n\n- `insert()` 支持在某个迭代器位置插入元素、可以插入多个。**复杂度与 `pos` 距离末尾长度成线性而非常数**\n\n- `erase()` 删除某个**迭代器或者区间的元素**，返回最后被删除的迭代器。复杂度与 `insert` 一致。\n\n- `push_back(x)` 在末尾插入一个元素x，均摊复杂度：常数，最坏为线性复杂度。\n\n- `pop_back()` 删除末尾元素，常数复杂度。\n\n  \n\n### deque\n\n能够提供线性复杂度的插入和删除，以及常数复杂度的随机访问。操作大同`vector`。\n\n- `push_front()` 在头部插入一个元素。\n\n- `pop_front()` 删除头部元素。\n\n- `push_back()` 在末尾插入一个元素。\n\n- `pop_back()` 删除末尾元素。\n\n  \n\n### list\n\n与`deque`大致相同，但是由于 `list` 的实现是链表，因此不提供随机访问的接口。若需要访问中间元素，则需要使用迭代器。\n\n- `front()` 返回首元素的引用。\n\n- `back()` 返回末尾元素的引用。\n\n  \n\n### array(C++11)\n\n| 成员函数    | 作用                                      | 示例         |\n| :---------- | :---------------------------------------- | ------------ |\n| `operator=` | `array2` 的每个元素重写 `array1` 对应元素 |              |\n| `max_size`  | 返回可容纳的最大元素数                    |              |\n| `fill`      | 以指定值填充容器                          | arr.fill(1); |\n| `swap`      | 交换，交换array的复杂度为：O(size)        |              |\n\n| 非成员函数   | 作用                          |\n| :----------- | :---------------------------- |\n| `operator==` | 按照字典序比较 `array` 中的值 |\n| `std::get`   | 访问 `array` 的一个元素       |\n\n## 关联式容器\n\n### 统一共有函数\n\n- `find(x)`: 若容器内存在键为 x 的元素，会返回该元素的迭代器；否则返回 `end()`。\n\n  ![image-20211015124758889](C:\\Users\\ll\\AppData\\Roaming\\Typora\\typora-user-images\\image-20211015124758889.png)\n\n- `erase(pos)` 删除迭代器为 pos 的元素，可结合`find`函数使用。\n\n- `erase(first,last)` 删除迭代器在 [first,last)范围内的所有元素。\n\n- `count(x)`: 返回容器内键为 x 的元素数量。\n\n- `lower_bound(x)`: 返回指向首个**不小于** 给定**键**的元素的迭代器。\n\n- `upper_bound(x)`: 返回指向首个**大于 **给定键的元素的迭代器。若容器内所有元素均小于或等于给定键，返回 `end()`。\n\n- `size()`: 返回容器内元素个数。\n\n### set\n\n`set` 内部采用红黑树实现。平衡二叉树的特性使得 `set` 非常适合处理需要同时兼顾查找、插入与删除的情况。\n\n- `insert(x)` 将元素 x 插入到 `set` 中。自动排序和去重。\n- `erase(x)` 删除值为 x 的 **所有** 元素，返回删除元素的个数。\n- `erase(first,last)` 删除迭代器在 [first,last)范围内的所有元素。\n\n### map\n\n`map` 重载了 `operator[]`，可以用任意定义了 `operator <` 的类型作为下标（在 `map` 中叫做 `key`，也就是索引）。\n\n- 可以直接通过下标访问来进行查询或插入操作。例： `mp[\"Alan\"]=100`。利用下标访问 时，如果 `map` 中不存在相应键的元素，会自动在 `map` 中插入一个新元素，并将其值设置为默认值（对于整数，值为零；对于有默认构造函数的类型，会调用默认构造函数进行初始化）\n- 通过向 `map` 中插入一个类型为 `pair<Key, T>` 的值可以达到插入元素的目的，例如 `mp.insert(pair<string,int>(\"Alan\",100));`\n- `erase(key)` 函数会删除键为 `key` 的 **所有** 元素。返回值为删除元素的数量。\n\n## 哈希适配容器\n\n四种基于哈希实现的无序关联式容器：`unordered_set`，`unordered_multiset`，`unordered_map`，`unordered_multimap`。\n\n其操作与关联式容器类似。\n\n## 容器适配器\n\n为什么称为容器适配器呢，是因为其内部的实现是基于`vector`  `deque ` 等等，其原理可以参考《STL源码剖析》。\n\n### 后进先出的stack\n\n仅支持查询或删除最后一个加入的元素（栈顶元素），不支持随机访问。\n\n- `top()` 访问栈顶元素（如果栈为空，此处会出错）\n- `push(x)` 向栈中插入元素 x\n- `pop()` 删除栈顶元素\n\n### 先进先出的queue\n\n- `front()` 访问队首元素（如果队列为空，此处会出错）\n- `push(x)` 向队列中插入元素 x\n- `pop()` 删除队首元素\n\n### 优先队列\n\n- `top()` 访问堆顶元素（此时优先队列不能为空）\n\n- `push(x)` 插入元素，并对底层容器排序\n\n- `pop()` 删除堆顶元素（此时优先队列不能为空）\n\n以上`pop`方法，返回已删除元素的值。\n\n- 优先级的定义：\n\n  对于数字，一般是值大者优先。即默认为：\n\n  `priority_queue<int,vector<int>,less<int> > pq;`\n\n  第二个参数是内部实现方式；第三个参数  **less表示数字大的优先级越大。如果是`greater<int>`，则为数字小者优先级大。**优先级大者，位于`top`。\n\n  结构体也可以定义优先级，可以通过`cmp`函数或者重载`<`运算符实现。这种思路也适用于其他关联式容器。\n\n### pair的常见用法\n\n头文件：`<utility>`\n\n按照正常的结构体访问（first，second…）。\n\n### string的常见用法\n\n`string`的实现形式类似于字符型`vector`，支持`push_back`、直接赋值（注意使用**双引号**）和下标访问。只支持`cin` `cout`，不支持`printf`等。\n\n- 可以通过加减运算符实现字符串拼接和删减、比较运算符进行字典序比较。\n\n- `substr(pos,len)`方法截取子串。时间复杂度是O（len）。\n\n- `find(x,pos)`指定了开始寻找的位置为下标`pos`\n\n- 上面的共有函数（`erase` `find`等）也是支持的。复杂度都是O(n)\n\n  ```cpp\n  string s1 = \"Hello\";\n  string s2 = \"world\";\n  s1.insert(3,s2);//Helworldlo\n  ```\n  \n  \n\n### STL算法\n\n在《特性》篇也介绍有一些用法。\n\n- `find_end`：逆序查找。`find_end(v.begin(), v.end(), value)`。\n- `nth_element`：按指定范围进行分类，即找出序列中第 *n* 大的元素，使其左边均为小于它的数，右边均为大于它的数。`nth_element(v.begin(), v.begin() + mid, v.end(), cmp)` 或 `nth_element(a + begin, a + begin + mid, a + end, cmp)`\n- `next_permutation`：将当前排列更改为 **全排列中的下一个排列**。如果当前排列已经是 **全排列中的最后一个排列**（元素完全从大到小排列），函数返回 `false` 并将排列更改为 **全排列中的第一个排列**（元素完全从小到大排列）；否则，函数返回 `true`。`next_permutation(v.begin(), v.end())` 或 `next_permutation(v + begin, v + end)`。\n\n### bitset\n\n通过固定的优化，使得一个字节的八个比特能分别储存 8 位的 `0/1`。\n\n头文件：`<bitset>`\n\n- `bitset()`: 每一位都是 `false`。\n- `bitset(int val)`: 设为 `val` 的二进制形式。\n- `bitset(const string& str)`: 设为 01 串 `str`。\n\n```cpp\nbitset<4> bitset1;　　//无初始化下，默认每一位均为0\nbitset<8> bitset2(16);　//保存长度为8的16的二进制表示：[00010000]\nstring s = \"10010\";\nbitset<8> bitset3(s);　　//长度为10，前补0。[00010010]\n```\n\n- `operator []`: 访问其特定的一位。\n- `operator ==/!=`: 比较两个 `bitset` 内容是否完全一样。\n- `operator &/&=/|/| =/^/^=/~`: 进行按位与/或/异或/取反操作。**`bitset` 只能与 `bitset` 进行位运算**，若要和整型进行位运算，要先将整型转换为 `bitset`。\n- `operator <>/<<=/>>=`: 进行二进制左移/右移。\n- `operator <>`: 流运算符，这意味着你可以通过 `cin/cout` 进行输入输出。\n- `count()`: 返回 `true` 的数量。\n- `size()`: 返回 `bitset` 的大小。\n- `test(pos)`: 它和 `vector` 中的 `at()` 的作用是一样的，和 `[]` 运算符的区别就是越界检查。\n- `to_string()`: 返回转换成的字符串表达。\n- `to_ulong()`: 返回转换成的 `unsigned long` 表达 (`long` 在 NT 及 32 位 POSIX 系统下与 `int` 一样，在 64 位 POSIX 下与 `long long` 一样）。\n- `to_ullong()`:*C++11*，返回转换成的 `unsigned long long` 表达。\n- `any()`: 若存在某一位是 `true` 则返回 `true`，否则返回 `false`。\n- `none()`: 若所有位都是 `false` 则返回 `true`，否则返回 `false`。\n- `all()`:*C++11*，若所有位都是 `true` 则返回 `true`，否则返回 `false`。\n- `set()`: 将整个 `bitset` 设置成 `true`。\n\n  `set(pos, val = true)`: 将某一位设置成 `true`/`false`。\n- `reset()`: 将整个 `bitset` 设置成 `false`。\n\n  `reset(pos)`: 将某一位设置成 `false`。相当于 `set(pos, false)`。\n- `flip()`: 翻转每一位。（01互换，相当于异或一个全是1 的 `bitset`）\n\n  `flip(pos)`: 翻转某一位。\n\n- `_Find_first()`: 返回 `bitset` 第一个 `true` 的下标，若没有 `true` 则返回 `bitset` 的大小。\n\n- `_Find_next(pos)`: 返回 `pos` 后面（下标严格大于 `pos` 的位置）第一个 `true` 的下标，若 `pos` 后面没有 `true` 则返回 `bitset` 的大小。\n\n  \n\n参考资料：\n\nOI-wiki\n\n《算法笔记》","slug":"C++STL的使用","published":1,"date":"2021-08-06T15:07:15.151Z","updated":"2022-02-03T09:30:39.678Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"ckz6z68vz000kfovva2xc7f9b","content":"<p>title:        C++ STL使用手册<br>tags:        C++,语法<br>categories:    语言基础<br>feature: true</p>\n<p>#C++ STL的使用手册</p>\n<p>[toc]</p>\n<p><img src=\"https://oi-wiki.org/lang/csl/images/container1.png\" alt=\"img\"></p>\n<h3 id=\"共有函数\"><a href=\"#共有函数\" class=\"headerlink\" title=\"共有函数\"></a>共有函数</h3><p><code>=</code>：有赋值运算符以及复制构造函数。</p>\n<p><code>begin()</code>：返回指向开头元素的迭代器。</p>\n<p><code>end()</code>：返回指向末尾的下一个元素的迭代器。<code>end()</code> <strong>不指向某个元素</strong>，它是末尾元素的后继。</p>\n<p><code>size()</code>：返回容器内的元素个数。</p>\n<p><code>max_size()</code>：返回容器 <strong>理论上</strong> 能存储的最大元素个数。依容器类型和所存储变量的类型而变。</p>\n<p><code>empty()</code>：返回容器是否为空的一个 <code>bool</code> 值，即 <code>begin() == end()</code>，<code>true</code> 为空，<code>false</code> 为非空。</p>\n<p><code>swap()</code>：交换两个容器。</p>\n<p><code>clear()</code>：清空容器。</p>\n<p><code>==</code>/<code>!=</code>/<code>&lt;</code>/<code>&gt;</code>/<code>&lt;=</code>/<code>&gt;=</code>：按 <strong>字典序</strong> 比较两个容器的大小。（比较元素大小时 <code>map</code> 的每个元素相当于 <code>set&lt;pair&lt;key, value&gt; &gt;</code>，<code>pair</code> 按 first 到 second 的顺序比较。无序容器不支持 <code>&lt;</code>/<code>&gt;</code>/<code>&lt;=</code>/<code>&gt;=</code></p>\n<h2 id=\"序列式容器\"><a href=\"#序列式容器\" class=\"headerlink\" title=\"序列式容器\"></a>序列式容器</h2><h3 id=\"vector\"><a href=\"#vector\" class=\"headerlink\" title=\"vector\"></a>vector</h3><p><strong>元素访问</strong></p>\n<ol>\n<li><p><code>at()</code></p>\n<p><code>v.at(pos)</code> 返回容器中下标为 <code>pos</code> 的引用。如果数组越界抛出 <code>std::out_of_range</code> 类型的异常。</p>\n</li>\n<li><p><code>operator[]</code></p>\n<p><code>v[pos]</code> 返回容器中下标为 <code>pos</code> 的引用。不执行越界检查。</p>\n</li>\n<li><p><code>front()</code></p>\n<p><code>v.front()</code> 返回首元素的引用。</p>\n</li>\n<li><p><code>back()</code></p>\n<p><code>v.back()</code> 返回末尾元素的引用。</p>\n</li>\n</ol>\n<p><strong>迭代器</strong></p>\n<ol>\n<li><p><code>begin()/cbegin()</code></p>\n<p>返回指向首元素的迭代器，其中 <code>*begin = front</code>。</p>\n</li>\n<li><p><code>end()/cend()</code></p>\n<p>返回指向数组尾端占位符的迭代器，注意是没有元素的。</p>\n</li>\n</ol>\n<p> 可以认为，<code>v[i]</code>与<code>*(v.begin()+i)</code>等价。但，<strong>除<code>vector</code> <code>string</code>外</strong>，其他STL容器不支持后者的形式。</p>\n<ul>\n<li><p><code>size()</code> 返回容器长度（元素数量），即 <code>std::distance(v.begin(), v.end())</code>。</p>\n</li>\n<li><p><code>insert()</code> 支持在某个迭代器位置插入元素、可以插入多个。<strong>复杂度与 <code>pos</code> 距离末尾长度成线性而非常数</strong></p>\n</li>\n<li><p><code>erase()</code> 删除某个<strong>迭代器或者区间的元素</strong>，返回最后被删除的迭代器。复杂度与 <code>insert</code> 一致。</p>\n</li>\n<li><p><code>push_back(x)</code> 在末尾插入一个元素x，均摊复杂度：常数，最坏为线性复杂度。</p>\n</li>\n<li><p><code>pop_back()</code> 删除末尾元素，常数复杂度。</p>\n</li>\n</ul>\n<h3 id=\"deque\"><a href=\"#deque\" class=\"headerlink\" title=\"deque\"></a>deque</h3><p>能够提供线性复杂度的插入和删除，以及常数复杂度的随机访问。操作大同<code>vector</code>。</p>\n<ul>\n<li><p><code>push_front()</code> 在头部插入一个元素。</p>\n</li>\n<li><p><code>pop_front()</code> 删除头部元素。</p>\n</li>\n<li><p><code>push_back()</code> 在末尾插入一个元素。</p>\n</li>\n<li><p><code>pop_back()</code> 删除末尾元素。</p>\n</li>\n</ul>\n<h3 id=\"list\"><a href=\"#list\" class=\"headerlink\" title=\"list\"></a>list</h3><p>与<code>deque</code>大致相同，但是由于 <code>list</code> 的实现是链表，因此不提供随机访问的接口。若需要访问中间元素，则需要使用迭代器。</p>\n<ul>\n<li><p><code>front()</code> 返回首元素的引用。</p>\n</li>\n<li><p><code>back()</code> 返回末尾元素的引用。</p>\n</li>\n</ul>\n<h3 id=\"array-C-11\"><a href=\"#array-C-11\" class=\"headerlink\" title=\"array(C++11)\"></a>array(C++11)</h3><table>\n<thead>\n<tr>\n<th align=\"left\">成员函数</th>\n<th align=\"left\">作用</th>\n<th>示例</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><code>operator=</code></td>\n<td align=\"left\"><code>array2</code> 的每个元素重写 <code>array1</code> 对应元素</td>\n<td></td>\n</tr>\n<tr>\n<td align=\"left\"><code>max_size</code></td>\n<td align=\"left\">返回可容纳的最大元素数</td>\n<td></td>\n</tr>\n<tr>\n<td align=\"left\"><code>fill</code></td>\n<td align=\"left\">以指定值填充容器</td>\n<td>arr.fill(1);</td>\n</tr>\n<tr>\n<td align=\"left\"><code>swap</code></td>\n<td align=\"left\">交换，交换array的复杂度为：O(size)</td>\n<td></td>\n</tr>\n</tbody></table>\n<table>\n<thead>\n<tr>\n<th align=\"left\">非成员函数</th>\n<th align=\"left\">作用</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><code>operator==</code></td>\n<td align=\"left\">按照字典序比较 <code>array</code> 中的值</td>\n</tr>\n<tr>\n<td align=\"left\"><code>std::get</code></td>\n<td align=\"left\">访问 <code>array</code> 的一个元素</td>\n</tr>\n</tbody></table>\n<h2 id=\"关联式容器\"><a href=\"#关联式容器\" class=\"headerlink\" title=\"关联式容器\"></a>关联式容器</h2><h3 id=\"统一共有函数\"><a href=\"#统一共有函数\" class=\"headerlink\" title=\"统一共有函数\"></a>统一共有函数</h3><ul>\n<li><p><code>find(x)</code>: 若容器内存在键为 x 的元素，会返回该元素的迭代器；否则返回 <code>end()</code>。</p>\n<p><img src=\"C:\\Users\\ll\\AppData\\Roaming\\Typora\\typora-user-images\\image-20211015124758889.png\" alt=\"image-20211015124758889\"></p>\n</li>\n<li><p><code>erase(pos)</code> 删除迭代器为 pos 的元素，可结合<code>find</code>函数使用。</p>\n</li>\n<li><p><code>erase(first,last)</code> 删除迭代器在 [first,last)范围内的所有元素。</p>\n</li>\n<li><p><code>count(x)</code>: 返回容器内键为 x 的元素数量。</p>\n</li>\n<li><p><code>lower_bound(x)</code>: 返回指向首个<strong>不小于</strong> 给定<strong>键</strong>的元素的迭代器。</p>\n</li>\n<li><p><code>upper_bound(x)</code>: 返回指向首个**大于 **给定键的元素的迭代器。若容器内所有元素均小于或等于给定键，返回 <code>end()</code>。</p>\n</li>\n<li><p><code>size()</code>: 返回容器内元素个数。</p>\n</li>\n</ul>\n<h3 id=\"set\"><a href=\"#set\" class=\"headerlink\" title=\"set\"></a>set</h3><p><code>set</code> 内部采用红黑树实现。平衡二叉树的特性使得 <code>set</code> 非常适合处理需要同时兼顾查找、插入与删除的情况。</p>\n<ul>\n<li><code>insert(x)</code> 将元素 x 插入到 <code>set</code> 中。自动排序和去重。</li>\n<li><code>erase(x)</code> 删除值为 x 的 <strong>所有</strong> 元素，返回删除元素的个数。</li>\n<li><code>erase(first,last)</code> 删除迭代器在 [first,last)范围内的所有元素。</li>\n</ul>\n<h3 id=\"map\"><a href=\"#map\" class=\"headerlink\" title=\"map\"></a>map</h3><p><code>map</code> 重载了 <code>operator[]</code>，可以用任意定义了 <code>operator &lt;</code> 的类型作为下标（在 <code>map</code> 中叫做 <code>key</code>，也就是索引）。</p>\n<ul>\n<li>可以直接通过下标访问来进行查询或插入操作。例： <code>mp[&quot;Alan&quot;]=100</code>。利用下标访问 时，如果 <code>map</code> 中不存在相应键的元素，会自动在 <code>map</code> 中插入一个新元素，并将其值设置为默认值（对于整数，值为零；对于有默认构造函数的类型，会调用默认构造函数进行初始化）</li>\n<li>通过向 <code>map</code> 中插入一个类型为 <code>pair&lt;Key, T&gt;</code> 的值可以达到插入元素的目的，例如 <code>mp.insert(pair&lt;string,int&gt;(&quot;Alan&quot;,100));</code></li>\n<li><code>erase(key)</code> 函数会删除键为 <code>key</code> 的 <strong>所有</strong> 元素。返回值为删除元素的数量。</li>\n</ul>\n<h2 id=\"哈希适配容器\"><a href=\"#哈希适配容器\" class=\"headerlink\" title=\"哈希适配容器\"></a>哈希适配容器</h2><p>四种基于哈希实现的无序关联式容器：<code>unordered_set</code>，<code>unordered_multiset</code>，<code>unordered_map</code>，<code>unordered_multimap</code>。</p>\n<p>其操作与关联式容器类似。</p>\n<h2 id=\"容器适配器\"><a href=\"#容器适配器\" class=\"headerlink\" title=\"容器适配器\"></a>容器适配器</h2><p>为什么称为容器适配器呢，是因为其内部的实现是基于<code>vector</code>  <code>deque </code> 等等，其原理可以参考《STL源码剖析》。</p>\n<h3 id=\"后进先出的stack\"><a href=\"#后进先出的stack\" class=\"headerlink\" title=\"后进先出的stack\"></a>后进先出的stack</h3><p>仅支持查询或删除最后一个加入的元素（栈顶元素），不支持随机访问。</p>\n<ul>\n<li><code>top()</code> 访问栈顶元素（如果栈为空，此处会出错）</li>\n<li><code>push(x)</code> 向栈中插入元素 x</li>\n<li><code>pop()</code> 删除栈顶元素</li>\n</ul>\n<h3 id=\"先进先出的queue\"><a href=\"#先进先出的queue\" class=\"headerlink\" title=\"先进先出的queue\"></a>先进先出的queue</h3><ul>\n<li><code>front()</code> 访问队首元素（如果队列为空，此处会出错）</li>\n<li><code>push(x)</code> 向队列中插入元素 x</li>\n<li><code>pop()</code> 删除队首元素</li>\n</ul>\n<h3 id=\"优先队列\"><a href=\"#优先队列\" class=\"headerlink\" title=\"优先队列\"></a>优先队列</h3><ul>\n<li><p><code>top()</code> 访问堆顶元素（此时优先队列不能为空）</p>\n</li>\n<li><p><code>push(x)</code> 插入元素，并对底层容器排序</p>\n</li>\n<li><p><code>pop()</code> 删除堆顶元素（此时优先队列不能为空）</p>\n</li>\n</ul>\n<p>以上<code>pop</code>方法，返回已删除元素的值。</p>\n<ul>\n<li><p>优先级的定义：</p>\n<p>对于数字，一般是值大者优先。即默认为：</p>\n<p><code>priority_queue&lt;int,vector&lt;int&gt;,less&lt;int&gt; &gt; pq;</code></p>\n<p>第二个参数是内部实现方式；第三个参数  <strong>less表示数字大的优先级越大。如果是<code>greater&lt;int&gt;</code>，则为数字小者优先级大。</strong>优先级大者，位于<code>top</code>。</p>\n<p>结构体也可以定义优先级，可以通过<code>cmp</code>函数或者重载<code>&lt;</code>运算符实现。这种思路也适用于其他关联式容器。</p>\n</li>\n</ul>\n<h3 id=\"pair的常见用法\"><a href=\"#pair的常见用法\" class=\"headerlink\" title=\"pair的常见用法\"></a>pair的常见用法</h3><p>头文件：<code>&lt;utility&gt;</code></p>\n<p>按照正常的结构体访问（first，second…）。</p>\n<h3 id=\"string的常见用法\"><a href=\"#string的常见用法\" class=\"headerlink\" title=\"string的常见用法\"></a>string的常见用法</h3><p><code>string</code>的实现形式类似于字符型<code>vector</code>，支持<code>push_back</code>、直接赋值（注意使用<strong>双引号</strong>）和下标访问。只支持<code>cin</code> <code>cout</code>，不支持<code>printf</code>等。</p>\n<ul>\n<li><p>可以通过加减运算符实现字符串拼接和删减、比较运算符进行字典序比较。</p>\n</li>\n<li><p><code>substr(pos,len)</code>方法截取子串。时间复杂度是O（len）。</p>\n</li>\n<li><p><code>find(x,pos)</code>指定了开始寻找的位置为下标<code>pos</code></p>\n</li>\n<li><p>上面的共有函数（<code>erase</code> <code>find</code>等）也是支持的。复杂度都是O(n)</p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">string s1 &#x3D; &quot;Hello&quot;;\nstring s2 &#x3D; &quot;world&quot;;\ns1.insert(3,s2);&#x2F;&#x2F;Helworldlo</code></pre></li>\n</ul>\n<h3 id=\"STL算法\"><a href=\"#STL算法\" class=\"headerlink\" title=\"STL算法\"></a>STL算法</h3><p>在《特性》篇也介绍有一些用法。</p>\n<ul>\n<li><code>find_end</code>：逆序查找。<code>find_end(v.begin(), v.end(), value)</code>。</li>\n<li><code>nth_element</code>：按指定范围进行分类，即找出序列中第 <em>n</em> 大的元素，使其左边均为小于它的数，右边均为大于它的数。<code>nth_element(v.begin(), v.begin() + mid, v.end(), cmp)</code> 或 <code>nth_element(a + begin, a + begin + mid, a + end, cmp)</code></li>\n<li><code>next_permutation</code>：将当前排列更改为 <strong>全排列中的下一个排列</strong>。如果当前排列已经是 <strong>全排列中的最后一个排列</strong>（元素完全从大到小排列），函数返回 <code>false</code> 并将排列更改为 <strong>全排列中的第一个排列</strong>（元素完全从小到大排列）；否则，函数返回 <code>true</code>。<code>next_permutation(v.begin(), v.end())</code> 或 <code>next_permutation(v + begin, v + end)</code>。</li>\n</ul>\n<h3 id=\"bitset\"><a href=\"#bitset\" class=\"headerlink\" title=\"bitset\"></a>bitset</h3><p>通过固定的优化，使得一个字节的八个比特能分别储存 8 位的 <code>0/1</code>。</p>\n<p>头文件：<code>&lt;bitset&gt;</code></p>\n<ul>\n<li><code>bitset()</code>: 每一位都是 <code>false</code>。</li>\n<li><code>bitset(int val)</code>: 设为 <code>val</code> 的二进制形式。</li>\n<li><code>bitset(const string&amp; str)</code>: 设为 01 串 <code>str</code>。</li>\n</ul>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">bitset&lt;4&gt; bitset1;　　&#x2F;&#x2F;无初始化下，默认每一位均为0\nbitset&lt;8&gt; bitset2(16);　&#x2F;&#x2F;保存长度为8的16的二进制表示：[00010000]\nstring s &#x3D; &quot;10010&quot;;\nbitset&lt;8&gt; bitset3(s);　　&#x2F;&#x2F;长度为10，前补0。[00010010]</code></pre>\n\n<ul>\n<li><p><code>operator []</code>: 访问其特定的一位。</p>\n</li>\n<li><p><code>operator ==/!=</code>: 比较两个 <code>bitset</code> 内容是否完全一样。</p>\n</li>\n<li><p><code>operator &amp;/&amp;=/|/| =/^/^=/~</code>: 进行按位与/或/异或/取反操作。**<code>bitset</code> 只能与 <code>bitset</code> 进行位运算**，若要和整型进行位运算，要先将整型转换为 <code>bitset</code>。</p>\n</li>\n<li><p><code>operator &lt;&gt;/&lt;&lt;=/&gt;&gt;=</code>: 进行二进制左移/右移。</p>\n</li>\n<li><p><code>operator &lt;&gt;</code>: 流运算符，这意味着你可以通过 <code>cin/cout</code> 进行输入输出。</p>\n</li>\n<li><p><code>count()</code>: 返回 <code>true</code> 的数量。</p>\n</li>\n<li><p><code>size()</code>: 返回 <code>bitset</code> 的大小。</p>\n</li>\n<li><p><code>test(pos)</code>: 它和 <code>vector</code> 中的 <code>at()</code> 的作用是一样的，和 <code>[]</code> 运算符的区别就是越界检查。</p>\n</li>\n<li><p><code>to_string()</code>: 返回转换成的字符串表达。</p>\n</li>\n<li><p><code>to_ulong()</code>: 返回转换成的 <code>unsigned long</code> 表达 (<code>long</code> 在 NT 及 32 位 POSIX 系统下与 <code>int</code> 一样，在 64 位 POSIX 下与 <code>long long</code> 一样）。</p>\n</li>\n<li><p><code>to_ullong()</code>:<em>C++11</em>，返回转换成的 <code>unsigned long long</code> 表达。</p>\n</li>\n<li><p><code>any()</code>: 若存在某一位是 <code>true</code> 则返回 <code>true</code>，否则返回 <code>false</code>。</p>\n</li>\n<li><p><code>none()</code>: 若所有位都是 <code>false</code> 则返回 <code>true</code>，否则返回 <code>false</code>。</p>\n</li>\n<li><p><code>all()</code>:<em>C++11</em>，若所有位都是 <code>true</code> 则返回 <code>true</code>，否则返回 <code>false</code>。</p>\n</li>\n<li><p><code>set()</code>: 将整个 <code>bitset</code> 设置成 <code>true</code>。</p>\n<p><code>set(pos, val = true)</code>: 将某一位设置成 <code>true</code>/<code>false</code>。</p>\n</li>\n<li><p><code>reset()</code>: 将整个 <code>bitset</code> 设置成 <code>false</code>。</p>\n<p><code>reset(pos)</code>: 将某一位设置成 <code>false</code>。相当于 <code>set(pos, false)</code>。</p>\n</li>\n<li><p><code>flip()</code>: 翻转每一位。（01互换，相当于异或一个全是1 的 <code>bitset</code>）</p>\n<p><code>flip(pos)</code>: 翻转某一位。</p>\n</li>\n<li><p><code>_Find_first()</code>: 返回 <code>bitset</code> 第一个 <code>true</code> 的下标，若没有 <code>true</code> 则返回 <code>bitset</code> 的大小。</p>\n</li>\n<li><p><code>_Find_next(pos)</code>: 返回 <code>pos</code> 后面（下标严格大于 <code>pos</code> 的位置）第一个 <code>true</code> 的下标，若 <code>pos</code> 后面没有 <code>true</code> 则返回 <code>bitset</code> 的大小。</p>\n</li>\n</ul>\n<p>参考资料：</p>\n<p>OI-wiki</p>\n<p>《算法笔记》</p>\n","site":{"data":{}},"excerpt":"","more":"<p>title:        C++ STL使用手册<br>tags:        C++,语法<br>categories:    语言基础<br>feature: true</p>\n<p>#C++ STL的使用手册</p>\n<p>[toc]</p>\n<p><img src=\"https://oi-wiki.org/lang/csl/images/container1.png\" alt=\"img\"></p>\n<h3 id=\"共有函数\"><a href=\"#共有函数\" class=\"headerlink\" title=\"共有函数\"></a>共有函数</h3><p><code>=</code>：有赋值运算符以及复制构造函数。</p>\n<p><code>begin()</code>：返回指向开头元素的迭代器。</p>\n<p><code>end()</code>：返回指向末尾的下一个元素的迭代器。<code>end()</code> <strong>不指向某个元素</strong>，它是末尾元素的后继。</p>\n<p><code>size()</code>：返回容器内的元素个数。</p>\n<p><code>max_size()</code>：返回容器 <strong>理论上</strong> 能存储的最大元素个数。依容器类型和所存储变量的类型而变。</p>\n<p><code>empty()</code>：返回容器是否为空的一个 <code>bool</code> 值，即 <code>begin() == end()</code>，<code>true</code> 为空，<code>false</code> 为非空。</p>\n<p><code>swap()</code>：交换两个容器。</p>\n<p><code>clear()</code>：清空容器。</p>\n<p><code>==</code>/<code>!=</code>/<code>&lt;</code>/<code>&gt;</code>/<code>&lt;=</code>/<code>&gt;=</code>：按 <strong>字典序</strong> 比较两个容器的大小。（比较元素大小时 <code>map</code> 的每个元素相当于 <code>set&lt;pair&lt;key, value&gt; &gt;</code>，<code>pair</code> 按 first 到 second 的顺序比较。无序容器不支持 <code>&lt;</code>/<code>&gt;</code>/<code>&lt;=</code>/<code>&gt;=</code></p>\n<h2 id=\"序列式容器\"><a href=\"#序列式容器\" class=\"headerlink\" title=\"序列式容器\"></a>序列式容器</h2><h3 id=\"vector\"><a href=\"#vector\" class=\"headerlink\" title=\"vector\"></a>vector</h3><p><strong>元素访问</strong></p>\n<ol>\n<li><p><code>at()</code></p>\n<p><code>v.at(pos)</code> 返回容器中下标为 <code>pos</code> 的引用。如果数组越界抛出 <code>std::out_of_range</code> 类型的异常。</p>\n</li>\n<li><p><code>operator[]</code></p>\n<p><code>v[pos]</code> 返回容器中下标为 <code>pos</code> 的引用。不执行越界检查。</p>\n</li>\n<li><p><code>front()</code></p>\n<p><code>v.front()</code> 返回首元素的引用。</p>\n</li>\n<li><p><code>back()</code></p>\n<p><code>v.back()</code> 返回末尾元素的引用。</p>\n</li>\n</ol>\n<p><strong>迭代器</strong></p>\n<ol>\n<li><p><code>begin()/cbegin()</code></p>\n<p>返回指向首元素的迭代器，其中 <code>*begin = front</code>。</p>\n</li>\n<li><p><code>end()/cend()</code></p>\n<p>返回指向数组尾端占位符的迭代器，注意是没有元素的。</p>\n</li>\n</ol>\n<p> 可以认为，<code>v[i]</code>与<code>*(v.begin()+i)</code>等价。但，<strong>除<code>vector</code> <code>string</code>外</strong>，其他STL容器不支持后者的形式。</p>\n<ul>\n<li><p><code>size()</code> 返回容器长度（元素数量），即 <code>std::distance(v.begin(), v.end())</code>。</p>\n</li>\n<li><p><code>insert()</code> 支持在某个迭代器位置插入元素、可以插入多个。<strong>复杂度与 <code>pos</code> 距离末尾长度成线性而非常数</strong></p>\n</li>\n<li><p><code>erase()</code> 删除某个<strong>迭代器或者区间的元素</strong>，返回最后被删除的迭代器。复杂度与 <code>insert</code> 一致。</p>\n</li>\n<li><p><code>push_back(x)</code> 在末尾插入一个元素x，均摊复杂度：常数，最坏为线性复杂度。</p>\n</li>\n<li><p><code>pop_back()</code> 删除末尾元素，常数复杂度。</p>\n</li>\n</ul>\n<h3 id=\"deque\"><a href=\"#deque\" class=\"headerlink\" title=\"deque\"></a>deque</h3><p>能够提供线性复杂度的插入和删除，以及常数复杂度的随机访问。操作大同<code>vector</code>。</p>\n<ul>\n<li><p><code>push_front()</code> 在头部插入一个元素。</p>\n</li>\n<li><p><code>pop_front()</code> 删除头部元素。</p>\n</li>\n<li><p><code>push_back()</code> 在末尾插入一个元素。</p>\n</li>\n<li><p><code>pop_back()</code> 删除末尾元素。</p>\n</li>\n</ul>\n<h3 id=\"list\"><a href=\"#list\" class=\"headerlink\" title=\"list\"></a>list</h3><p>与<code>deque</code>大致相同，但是由于 <code>list</code> 的实现是链表，因此不提供随机访问的接口。若需要访问中间元素，则需要使用迭代器。</p>\n<ul>\n<li><p><code>front()</code> 返回首元素的引用。</p>\n</li>\n<li><p><code>back()</code> 返回末尾元素的引用。</p>\n</li>\n</ul>\n<h3 id=\"array-C-11\"><a href=\"#array-C-11\" class=\"headerlink\" title=\"array(C++11)\"></a>array(C++11)</h3><table>\n<thead>\n<tr>\n<th align=\"left\">成员函数</th>\n<th align=\"left\">作用</th>\n<th>示例</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><code>operator=</code></td>\n<td align=\"left\"><code>array2</code> 的每个元素重写 <code>array1</code> 对应元素</td>\n<td></td>\n</tr>\n<tr>\n<td align=\"left\"><code>max_size</code></td>\n<td align=\"left\">返回可容纳的最大元素数</td>\n<td></td>\n</tr>\n<tr>\n<td align=\"left\"><code>fill</code></td>\n<td align=\"left\">以指定值填充容器</td>\n<td>arr.fill(1);</td>\n</tr>\n<tr>\n<td align=\"left\"><code>swap</code></td>\n<td align=\"left\">交换，交换array的复杂度为：O(size)</td>\n<td></td>\n</tr>\n</tbody></table>\n<table>\n<thead>\n<tr>\n<th align=\"left\">非成员函数</th>\n<th align=\"left\">作用</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><code>operator==</code></td>\n<td align=\"left\">按照字典序比较 <code>array</code> 中的值</td>\n</tr>\n<tr>\n<td align=\"left\"><code>std::get</code></td>\n<td align=\"left\">访问 <code>array</code> 的一个元素</td>\n</tr>\n</tbody></table>\n<h2 id=\"关联式容器\"><a href=\"#关联式容器\" class=\"headerlink\" title=\"关联式容器\"></a>关联式容器</h2><h3 id=\"统一共有函数\"><a href=\"#统一共有函数\" class=\"headerlink\" title=\"统一共有函数\"></a>统一共有函数</h3><ul>\n<li><p><code>find(x)</code>: 若容器内存在键为 x 的元素，会返回该元素的迭代器；否则返回 <code>end()</code>。</p>\n<p><img src=\"C:\\Users\\ll\\AppData\\Roaming\\Typora\\typora-user-images\\image-20211015124758889.png\" alt=\"image-20211015124758889\"></p>\n</li>\n<li><p><code>erase(pos)</code> 删除迭代器为 pos 的元素，可结合<code>find</code>函数使用。</p>\n</li>\n<li><p><code>erase(first,last)</code> 删除迭代器在 [first,last)范围内的所有元素。</p>\n</li>\n<li><p><code>count(x)</code>: 返回容器内键为 x 的元素数量。</p>\n</li>\n<li><p><code>lower_bound(x)</code>: 返回指向首个<strong>不小于</strong> 给定<strong>键</strong>的元素的迭代器。</p>\n</li>\n<li><p><code>upper_bound(x)</code>: 返回指向首个**大于 **给定键的元素的迭代器。若容器内所有元素均小于或等于给定键，返回 <code>end()</code>。</p>\n</li>\n<li><p><code>size()</code>: 返回容器内元素个数。</p>\n</li>\n</ul>\n<h3 id=\"set\"><a href=\"#set\" class=\"headerlink\" title=\"set\"></a>set</h3><p><code>set</code> 内部采用红黑树实现。平衡二叉树的特性使得 <code>set</code> 非常适合处理需要同时兼顾查找、插入与删除的情况。</p>\n<ul>\n<li><code>insert(x)</code> 将元素 x 插入到 <code>set</code> 中。自动排序和去重。</li>\n<li><code>erase(x)</code> 删除值为 x 的 <strong>所有</strong> 元素，返回删除元素的个数。</li>\n<li><code>erase(first,last)</code> 删除迭代器在 [first,last)范围内的所有元素。</li>\n</ul>\n<h3 id=\"map\"><a href=\"#map\" class=\"headerlink\" title=\"map\"></a>map</h3><p><code>map</code> 重载了 <code>operator[]</code>，可以用任意定义了 <code>operator &lt;</code> 的类型作为下标（在 <code>map</code> 中叫做 <code>key</code>，也就是索引）。</p>\n<ul>\n<li>可以直接通过下标访问来进行查询或插入操作。例： <code>mp[&quot;Alan&quot;]=100</code>。利用下标访问 时，如果 <code>map</code> 中不存在相应键的元素，会自动在 <code>map</code> 中插入一个新元素，并将其值设置为默认值（对于整数，值为零；对于有默认构造函数的类型，会调用默认构造函数进行初始化）</li>\n<li>通过向 <code>map</code> 中插入一个类型为 <code>pair&lt;Key, T&gt;</code> 的值可以达到插入元素的目的，例如 <code>mp.insert(pair&lt;string,int&gt;(&quot;Alan&quot;,100));</code></li>\n<li><code>erase(key)</code> 函数会删除键为 <code>key</code> 的 <strong>所有</strong> 元素。返回值为删除元素的数量。</li>\n</ul>\n<h2 id=\"哈希适配容器\"><a href=\"#哈希适配容器\" class=\"headerlink\" title=\"哈希适配容器\"></a>哈希适配容器</h2><p>四种基于哈希实现的无序关联式容器：<code>unordered_set</code>，<code>unordered_multiset</code>，<code>unordered_map</code>，<code>unordered_multimap</code>。</p>\n<p>其操作与关联式容器类似。</p>\n<h2 id=\"容器适配器\"><a href=\"#容器适配器\" class=\"headerlink\" title=\"容器适配器\"></a>容器适配器</h2><p>为什么称为容器适配器呢，是因为其内部的实现是基于<code>vector</code>  <code>deque </code> 等等，其原理可以参考《STL源码剖析》。</p>\n<h3 id=\"后进先出的stack\"><a href=\"#后进先出的stack\" class=\"headerlink\" title=\"后进先出的stack\"></a>后进先出的stack</h3><p>仅支持查询或删除最后一个加入的元素（栈顶元素），不支持随机访问。</p>\n<ul>\n<li><code>top()</code> 访问栈顶元素（如果栈为空，此处会出错）</li>\n<li><code>push(x)</code> 向栈中插入元素 x</li>\n<li><code>pop()</code> 删除栈顶元素</li>\n</ul>\n<h3 id=\"先进先出的queue\"><a href=\"#先进先出的queue\" class=\"headerlink\" title=\"先进先出的queue\"></a>先进先出的queue</h3><ul>\n<li><code>front()</code> 访问队首元素（如果队列为空，此处会出错）</li>\n<li><code>push(x)</code> 向队列中插入元素 x</li>\n<li><code>pop()</code> 删除队首元素</li>\n</ul>\n<h3 id=\"优先队列\"><a href=\"#优先队列\" class=\"headerlink\" title=\"优先队列\"></a>优先队列</h3><ul>\n<li><p><code>top()</code> 访问堆顶元素（此时优先队列不能为空）</p>\n</li>\n<li><p><code>push(x)</code> 插入元素，并对底层容器排序</p>\n</li>\n<li><p><code>pop()</code> 删除堆顶元素（此时优先队列不能为空）</p>\n</li>\n</ul>\n<p>以上<code>pop</code>方法，返回已删除元素的值。</p>\n<ul>\n<li><p>优先级的定义：</p>\n<p>对于数字，一般是值大者优先。即默认为：</p>\n<p><code>priority_queue&lt;int,vector&lt;int&gt;,less&lt;int&gt; &gt; pq;</code></p>\n<p>第二个参数是内部实现方式；第三个参数  <strong>less表示数字大的优先级越大。如果是<code>greater&lt;int&gt;</code>，则为数字小者优先级大。</strong>优先级大者，位于<code>top</code>。</p>\n<p>结构体也可以定义优先级，可以通过<code>cmp</code>函数或者重载<code>&lt;</code>运算符实现。这种思路也适用于其他关联式容器。</p>\n</li>\n</ul>\n<h3 id=\"pair的常见用法\"><a href=\"#pair的常见用法\" class=\"headerlink\" title=\"pair的常见用法\"></a>pair的常见用法</h3><p>头文件：<code>&lt;utility&gt;</code></p>\n<p>按照正常的结构体访问（first，second…）。</p>\n<h3 id=\"string的常见用法\"><a href=\"#string的常见用法\" class=\"headerlink\" title=\"string的常见用法\"></a>string的常见用法</h3><p><code>string</code>的实现形式类似于字符型<code>vector</code>，支持<code>push_back</code>、直接赋值（注意使用<strong>双引号</strong>）和下标访问。只支持<code>cin</code> <code>cout</code>，不支持<code>printf</code>等。</p>\n<ul>\n<li><p>可以通过加减运算符实现字符串拼接和删减、比较运算符进行字典序比较。</p>\n</li>\n<li><p><code>substr(pos,len)</code>方法截取子串。时间复杂度是O（len）。</p>\n</li>\n<li><p><code>find(x,pos)</code>指定了开始寻找的位置为下标<code>pos</code></p>\n</li>\n<li><p>上面的共有函数（<code>erase</code> <code>find</code>等）也是支持的。复杂度都是O(n)</p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">string s1 &#x3D; &quot;Hello&quot;;\nstring s2 &#x3D; &quot;world&quot;;\ns1.insert(3,s2);&#x2F;&#x2F;Helworldlo</code></pre></li>\n</ul>\n<h3 id=\"STL算法\"><a href=\"#STL算法\" class=\"headerlink\" title=\"STL算法\"></a>STL算法</h3><p>在《特性》篇也介绍有一些用法。</p>\n<ul>\n<li><code>find_end</code>：逆序查找。<code>find_end(v.begin(), v.end(), value)</code>。</li>\n<li><code>nth_element</code>：按指定范围进行分类，即找出序列中第 <em>n</em> 大的元素，使其左边均为小于它的数，右边均为大于它的数。<code>nth_element(v.begin(), v.begin() + mid, v.end(), cmp)</code> 或 <code>nth_element(a + begin, a + begin + mid, a + end, cmp)</code></li>\n<li><code>next_permutation</code>：将当前排列更改为 <strong>全排列中的下一个排列</strong>。如果当前排列已经是 <strong>全排列中的最后一个排列</strong>（元素完全从大到小排列），函数返回 <code>false</code> 并将排列更改为 <strong>全排列中的第一个排列</strong>（元素完全从小到大排列）；否则，函数返回 <code>true</code>。<code>next_permutation(v.begin(), v.end())</code> 或 <code>next_permutation(v + begin, v + end)</code>。</li>\n</ul>\n<h3 id=\"bitset\"><a href=\"#bitset\" class=\"headerlink\" title=\"bitset\"></a>bitset</h3><p>通过固定的优化，使得一个字节的八个比特能分别储存 8 位的 <code>0/1</code>。</p>\n<p>头文件：<code>&lt;bitset&gt;</code></p>\n<ul>\n<li><code>bitset()</code>: 每一位都是 <code>false</code>。</li>\n<li><code>bitset(int val)</code>: 设为 <code>val</code> 的二进制形式。</li>\n<li><code>bitset(const string&amp; str)</code>: 设为 01 串 <code>str</code>。</li>\n</ul>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">bitset&lt;4&gt; bitset1;　　&#x2F;&#x2F;无初始化下，默认每一位均为0\nbitset&lt;8&gt; bitset2(16);　&#x2F;&#x2F;保存长度为8的16的二进制表示：[00010000]\nstring s &#x3D; &quot;10010&quot;;\nbitset&lt;8&gt; bitset3(s);　　&#x2F;&#x2F;长度为10，前补0。[00010010]</code></pre>\n\n<ul>\n<li><p><code>operator []</code>: 访问其特定的一位。</p>\n</li>\n<li><p><code>operator ==/!=</code>: 比较两个 <code>bitset</code> 内容是否完全一样。</p>\n</li>\n<li><p><code>operator &amp;/&amp;=/|/| =/^/^=/~</code>: 进行按位与/或/异或/取反操作。**<code>bitset</code> 只能与 <code>bitset</code> 进行位运算**，若要和整型进行位运算，要先将整型转换为 <code>bitset</code>。</p>\n</li>\n<li><p><code>operator &lt;&gt;/&lt;&lt;=/&gt;&gt;=</code>: 进行二进制左移/右移。</p>\n</li>\n<li><p><code>operator &lt;&gt;</code>: 流运算符，这意味着你可以通过 <code>cin/cout</code> 进行输入输出。</p>\n</li>\n<li><p><code>count()</code>: 返回 <code>true</code> 的数量。</p>\n</li>\n<li><p><code>size()</code>: 返回 <code>bitset</code> 的大小。</p>\n</li>\n<li><p><code>test(pos)</code>: 它和 <code>vector</code> 中的 <code>at()</code> 的作用是一样的，和 <code>[]</code> 运算符的区别就是越界检查。</p>\n</li>\n<li><p><code>to_string()</code>: 返回转换成的字符串表达。</p>\n</li>\n<li><p><code>to_ulong()</code>: 返回转换成的 <code>unsigned long</code> 表达 (<code>long</code> 在 NT 及 32 位 POSIX 系统下与 <code>int</code> 一样，在 64 位 POSIX 下与 <code>long long</code> 一样）。</p>\n</li>\n<li><p><code>to_ullong()</code>:<em>C++11</em>，返回转换成的 <code>unsigned long long</code> 表达。</p>\n</li>\n<li><p><code>any()</code>: 若存在某一位是 <code>true</code> 则返回 <code>true</code>，否则返回 <code>false</code>。</p>\n</li>\n<li><p><code>none()</code>: 若所有位都是 <code>false</code> 则返回 <code>true</code>，否则返回 <code>false</code>。</p>\n</li>\n<li><p><code>all()</code>:<em>C++11</em>，若所有位都是 <code>true</code> 则返回 <code>true</code>，否则返回 <code>false</code>。</p>\n</li>\n<li><p><code>set()</code>: 将整个 <code>bitset</code> 设置成 <code>true</code>。</p>\n<p><code>set(pos, val = true)</code>: 将某一位设置成 <code>true</code>/<code>false</code>。</p>\n</li>\n<li><p><code>reset()</code>: 将整个 <code>bitset</code> 设置成 <code>false</code>。</p>\n<p><code>reset(pos)</code>: 将某一位设置成 <code>false</code>。相当于 <code>set(pos, false)</code>。</p>\n</li>\n<li><p><code>flip()</code>: 翻转每一位。（01互换，相当于异或一个全是1 的 <code>bitset</code>）</p>\n<p><code>flip(pos)</code>: 翻转某一位。</p>\n</li>\n<li><p><code>_Find_first()</code>: 返回 <code>bitset</code> 第一个 <code>true</code> 的下标，若没有 <code>true</code> 则返回 <code>bitset</code> 的大小。</p>\n</li>\n<li><p><code>_Find_next(pos)</code>: 返回 <code>pos</code> 后面（下标严格大于 <code>pos</code> 的位置）第一个 <code>true</code> 的下标，若 <code>pos</code> 后面没有 <code>true</code> 则返回 <code>bitset</code> 的大小。</p>\n</li>\n</ul>\n<p>参考资料：</p>\n<p>OI-wiki</p>\n<p>《算法笔记》</p>\n"},{"_content":"#《原神》祈愿机制概率研究\n\n【摘要】本文以概率论、随机过程理论等工具研究游戏《原神》中的祈愿机制，主要基于动态规划，以“期望”和“概率的概率”两大分析方向进行数据处理，并根据分析结果总结了一些方便玩家规划金钱与资源的建议。由于追求多次获得五星道具的玩家基本“不差钱”，本文附有获取少量五星情况下的数据可视化。\n\n[TOC]\n\n> Version:20220105\n>\n> - 修了讲一遍时找到的笔误\n\n## 规则表述\n\n旅行者（玩家）可以通过祈愿机制获取“五星角色”“五星武器“”四星角色“”四星武器“来提高战斗力。其中，角色具有命之座机制，首次获得为0命，最高6命，命座数越高，角色越强；类似地，武器拥有精炼层数机制，首次获得为1阶，最高5阶。\n\n最近的版本更新中，《原神》的祈愿机制也发生了一定的变化。\n\n以下是《原神》两个祈愿机制的官方描述（https://ys.mihoyo.com/main/news/public）：\n\n### 角色祈愿\n\n**五星角色祈愿的基础概率为0.600%，综合概率（含保底）为1.600%**，最多90次祈愿必定能通过保底获取5星角色。\n\n当祈愿获取到5星角色时，有50.000%的概率为本期5星UP角色「A1」*（小保底）*。如果本次祈愿获取的5星角色非本期5星UP角色，下次祈愿获取的5星角色必定为本期5星UP角色*（大保底）*。\n\n**4星物品祈愿的基础概率为5.100%，4星角色祈愿的基础概率为2.550%，4星武器祈愿的基础概率为2.550%，4星物品祈愿的综合概率（含保底）为13.000%。**最多10次祈愿必定能通过保底获取4星或以上物品，通过保底获取4星物品的概率为99.400%，获取5星物品的概率为0.600%。\n\n当祈愿获取到4星物品时，有50.000%的概率为本期4星UP角色「B」、「C」、「D」中的一个。如果本次祈愿获取的4星物品非本期4星UP角色，下次祈愿获取的4星物品必定为本期4星UP角色。当祈愿获取到4星UP物品时，每个本期4星UP角色的获取概率均等。\n\n角色祈愿包括「角色活动祈愿-1」和「角色活动祈愿-2」，祈愿次数和保底完全共享，共同累计。二者区别仅在于当期UP的五星角色不同。\n\n### 武器祈愿\n\n**武器祈愿中，5星武器祈愿的基础概率为0.700%，综合概率（含保底）为1.850%，**最多80次祈愿必定能通过保底获取5星武器。\n\n当祈愿获取到5星武器时，有75.000%的概率为本期5星UP武器「M」、「N」中的一个。如果本次祈愿获取的5星武器非本期5星UP武器，下次祈愿获取的5星武器必定为本期5星UP武器。\n\n【定轨机制】命定值：玩家可以指定一把本期5星UP武器（定轨）。当获取到的5星武器为非当前定轨武器时，获得1点命定值，命定值达到满值2后，在本祈愿中获得的下一把5星武器必定为当前定轨武器。获取到当前定轨武器时，无论当前命定值是否达到满值，都将会重置为0，重新累计。在未通过命定值达到满值获取定轨武器的情况下，当祈愿获取到5星UP物品时，每把本期5星UP武器的获取概率均等。\n\n未使用「神铸定轨」定轨武器时，将不会累积命定值。\n\n**4星物品祈愿的基础概率为6.000%，4星角色祈愿的基础概率为3.000%，4星武器祈愿的基础概率为3.000%，4星物品祈愿的综合概率（含保底）为14.500%。**最多10次祈愿必定能通过保底获取4星或以上物品，通过保底获取4星物品的概率为99.300%，获取5星物品的概率为0.700%。\n\n当祈愿获取到4星物品时，有75.000%的概率为本期4星UP武器「F」、「G」、「H」、「J」、「K」中的一个。如果本次祈愿获取的4星物品非本期4星UP武器，下次祈愿获取的4星物品必定为本期4星UP武器。当祈愿获取到4星UP物品时，每把本期4星UP武器的获取概率均等。\n\n# 角色祈愿分析\n\n## 五星角色概率建模\n\n   前面的作业中，笔者通过运行代码和期望分析，对角色祈愿的机制进行了尝试1的模拟，简单回顾如下：\n\n### 尝试1：89次伯努利实验\n\n建模1：前89次祈愿，每次获得五星角色的概率均为0.6%，若前89次实验没有获得五星角色，则获取五星角色的概率为100%。\n\n则可以建模二项分布概率密度：\n\n$$ PDF(X = k) = (1-p)^{k-1}p(p = 0.6 \\%)$$\n\n$$ CDF(X = k) = (1 - p)^k$$\n\n计算每次获取五星角色的祈愿数期望：\n\n$$ E(X) = 90(1-CDF(89)) + \\sum_{i=1}^{89}iPDF(x=i)$$\n\n得到综合概率：\n\n$$P = \\frac{1}{E(X)} $$\n\n结果为：1.435%。（详见week9作业）\n\n与官方描述不符。实际上，官方提到的0.6%是基础概率，说明不是恒定概率的伯努利实验，于是提出模型2.\n\n### 尝试2：概率递增的保底机制\n\n建模2：在一定抽数都没有得到五星角色后，获得五星角色概率开始线性上升，直到第90抽达到100%。 \n\n由于具体概率密度没有官方文档，只能站在前人的分析上，根据结合数据统计的开源项目（https://github.com/OneBST/GGanalysis，本文实际上相当于模型的复现）采用的模型，第x次祈愿获得五星角色的概率如下：\n\n$$ P(x) = \\begin{cases} 0.6\\% &{x<=73}\\\\ 0.6\\% + 6\\%(x - 73) &{74<=x<=89}\\\\1&{x = 90} \\end{cases}$$\n\n由此，可以得到第x次祈愿得到五星角色的分布列（类似于几何分布）：\n\n$$ PDF(x) = P(x) * \\prod_{k = 1}^{x - 1}1-P(x) $$\n\n$$ PDF(x) = \\begin{cases} (1 - 0.6\\%)^{x-1}\\times0.6\\% &{x\\leqslant73}\\\\ (1-0.6\\%)^{73} \\times \\sum_{k = 74}^{x} (1- 6\\%(k - 73))^{k-73}(6\\%(k-73)) &{74\\leqslant x\\leqslant89}\\\\(1-0.6\\%)^{73} \\times \\sum_{k = 74}^{89} (1- 6\\%(k - 73))^{k-73}&{x = 90} \\end{cases} $$\n\n**该模型平均获取五星角色的祈愿次数为62.3。**该模型下五星角色的综合概率为1.605%。\n\n注：期望计算公式：\n\n$$ E(X) = \\sum_{i=1}^{x}PDF(x)\\times x $$\n\n## 概率递增保底机制下的数字特征\n\n### 求数据特征\n\n在这里处理一个认识误区：期望 != 概率为50%的点（中分位点）。\n\n也就是说，期望作为概率的平均值，$ CDF(EX) = 0.5 $ **是不成立的**。 注意到这一前提，才能比较正确地理解下面的结论。\n\n由于其概率密度并不是均匀分布的，差别较大，选择平均数似乎不太合适。所以我们获取中分位点。根本不应该是程序员能写出来的粗糙代码验证：\n\n```python\nimport numpy as np\nimport matplotlib as mlp\nimport matplotlib.pyplot as plt\nfrom matplotlib.pyplot import MultipleLocator\ndef p_5(n):\n    if n < 73:\n        return 0.006\n    elif n < 89:\n        return 0.006 + (n - 72) * 0.06\n    else:\n        return 1\n    \npdf_5 = [];\ncdf_5 = [];\ntmp = 0.0;\n\nfor i in range (0,90):\n    tmp = p_5(i);\n    for j in range(0,i):\n        tmp = tmp * (1 - p_5(j))\n    pdf_5.append(tmp);\n#注：下文中其他代码可能要用到p_5,p_4函数,pdf_5列表哦\n\nfor i in range (0,90):\n    tmp = 0.0;\n    for j in range (0,i+1):\n        tmp = tmp + pdf_5[j];\n    cdf_5.append(tmp);\n    print(i+1,cdf_5[i])\n# out:\n#75 0.4739047630777248\n#76 0.571758477145268\n```\n\n该模型的概率密度函数（蓝线）和分布函数（黄线）图：\n\n![img](http://img.070077.xyz/%E5%8E%9F%E7%A5%9E%E6%8A%BD%E5%8D%A1%E6%A6%82%E7%8E%87%E5%88%86%E5%B8%83%E5%9B%BE.png)\n\n我们不妨乐观一点，中分位点：75.\n\n注：最概然祈愿次数为77。也就是说，在第77次祈愿获取五星角色的概率最高。\n\n每次获得五星角色，需要的祈愿次数记为$N$. 则：\n\n- 从期望角度考虑，N = 62.3.\n- 从中分位点角度考虑，N = 75.\n\n实际理解为：需要75次祈愿，才能使获得5星角色的发生概率达到50%（实际：46.8%）。\n\n这种分布具有较强的右偏性。上面分析过，这两个数字特征具有不同的分析意义，可以理解为：\n\n+ 祈愿623次，期望获得10个五星角色。（期望值）\n+ 祈愿75次，能使获得五星角色的概率达到50%。\n\n### 由期望特征进行资源规划\n\n回到规则中，解决以下问题：\n\n#### 获得五星角色A的期望次数分析\n\n对于期望分析：注意到，对于获取当期UP五星角色，最多需要2次获得五星角色。也就是说，有50%的概率，仅需要获取一次五星角色；有50%的概率，需要获取2次五星角色。也就是说，需要获得五星角色的次数：\n\n$$ 1 \\times 50\\% + 2 \\times 50\\%  = 1.5 $$\n\n对于“获取五星角色”而言，多次获取（不论是否为当期UP角色）之间互相独立，因此需要的祈愿次数为$1.5 \\times 62.3 = 93.45$ 次。\n\n#### 获得6命座A角色的期望次数分析\n\n注意到，对于“获取五星角色”而言，多次获取（不论是否为当期UP角色）之间互相独立。考虑这个问题：对于“获取A角色”事件之间，是相互独立的吗？\n\n从期望角度考虑，可以说：是的。参考上面的思路，只需要“获取A角色”发生7次即可。因此需要的祈愿次数为 $1.5N \\times 7 = 10.5N$ 也就是 654.15 次。\n\n#### 获得四星角色B的期望次数分析\n\n由于涉及“基础概率”，我们沿用上一开源项目模型的概率递增保底机制结论：\n\n- 从第9次祈愿处开始上升。\n\n- 获得五星角色并不会重置四星保底。\n\n第x次祈愿获得四星角色的概率如下：\n\n$$ P(x) = \\begin{cases} 5.1\\% & {x\\leqslant8}\\\\ 56.1\\% &{x = 9}\\\\1&{x = 10} \\end{cases}$$\n\n$$ PDF(x) = P(x) * \\prod_{k = 1}^{x - 1}1-P(x)  = \\begin{cases} (1 - 5.1\\%)^{x-1}\\times5.1\\% & {x\\leqslant8}\\\\ (1-5.1\\%)^8\\times56.1\\% &{x=9}\\\\(1-5.1\\%)^8\\times43.9\\%&{x = 10} \\end{cases}$$ \n\n期望值：\n\n$$ E(X) = \\sum_{i=1}^{x}PDF(x)\\times x = 7.66$$ \n\n综合概率：13.05%.\n\n对于期望分析：注意到，对于获取当期UP五星角色，仅有$\\frac{1}{3}$的概率得到当期UP的四星角色中的B，且每次获得当期四星角色时，有50%的概率，仅需要获取一次四星角色；有50%的概率，需要获取2次四星角色。也就是说，获得角色B的次数期望为$1.5 \\times 3 \\times E(X) = 34.5$ 。\n\n### 由分位点特征进行分析\n\n从“概率的概率”角度分析便没有期望分析那么简单了。中位点与期望的乘积并不能得到叠加事件的中位点。基本上大部分分而治之的想法均不满足独立性要求。我们需要寻找更一般的数学模型：\n\n#### 获得多次五星角色的分位点分析\n\n接下来，由于**使获得两次五星角色的概率达到50%的祈愿次数不等于获得一次五星角色祈愿次数的中位点的2倍**，我们需要计算分布的**叠加**。\n\n我们从简单问题入手（自己编的）：\n\n(1) 一直抛硬币，直到总共出现2次正面朝上，求期望的抛硬币次数——显然是4.\n\n(2) 需要抛多少次硬币，使【至少出现2次正面朝上】的概率达到50%。\n\n(3) 需要抛多少次骰子，使【至少出现2次点数1】的概率达到50%。\n\n题目（2）（3）这类问题，可以转化成“几何分布的叠加问题”。这里的概率稳定~~比较简单~~，还可以参阅负二项分布有关资料。\n\n而对于的祈愿的建模，概率不稳定，有三种可能的思考方向：一可以用模拟动态规划处理，二是对各种情况进行全概率公式展开（~~工作量极大~~），三是离散信号的进行卷积运算:$P(Z=X+Y=z) = \\sum_1^\\infty PDF(X=z-y)P(X=y)$\n\n笔者采用第三种方法。\n\n各位修改一下代码的变量，即可获取想要的值。\n\n```python\nc5_need = 2#需要抽出几次五星角色；\nc5_poss = 0.25#想知道的概率;\nconv = pdf_5;\nfor cnt in range(0,c5_need - 1):\n    conv=np.convolve(conv,pdf_5,'full')\n    plt.plot(conv)\n    tmp = 0.0\n    for i in range (0,len(conv)):\n        tmp += conv[i]\n        if(cnt == c5_need - 2 and tmp >= c5_poss):\n            print(i+c5_need);\n            break\n    #DEMO\n    #135 -- 需要祈愿135次，才有50%的概率获得两个五星角色。\n\t#祈愿154次，有75%的概率获得两个五星角色。\n```\n\n我对获得两次的情况列了个分布图：\n\n![原神抽卡2次五星概率分布图](http://img.070077.xyz/%E5%8E%9F%E7%A5%9E%E6%8A%BD%E5%8D%A12%E6%AC%A1%E4%BA%94%E6%98%9F%E6%A6%82%E7%8E%87%E5%88%86%E5%B8%83%E5%9B%BE.png)\n\n#### 双角色池祈愿\n\n这个其实没什么太大的变化，把A2等价成A1，就可以和上文的A的结论统一了。\n\n## 保底依赖下的分位点分析\n\n### 尝试1：将“保底获得的五星”和“祈愿次数”拆成两个独立事件\n\n#### 保底之间的马尔可夫过程\n\n由于角色祈愿机制满足：本次获取五星角色是否为A的概率仅取决于上次获取的五星角色是否为A。符合马尔可夫过程（状态$i$只取决于上一次状态$i-1$，与再先前的状态相互独立。参：课本P321）的建模标准，可以做出以下状态图和概率转移矩阵：\n\n```mermaid\ngraph LR\nA --1/2--> !A\n!A --1--> A\nA --1/2--> A\n```\n$$ M = \\space \\begin{matrix}  & A & !A\\\\A & {1}\\over{2} & {1}\\over{2}\\\\!A & 1 & 0\\end{matrix}$$\n\n马尔可夫链在三门问题、经济学分析、自然语言处理等领域具有广泛的应用，在极值环境下具有平稳分布的特点。以下进行模拟分析。\n\n收敛的综合概率：$M^\\infty$。经过计算，可知A物品的综合概率为$\\frac{2}{3}$ 。这个计算结果可以理解为：任意一次获得五星角色，有$\\frac{2}{3}$的概率是A.（初始状况：刚获得A，以说明存在小保底）\n\n而对于中间情况的分析，可对应转换为矩阵的乘法和加法运算。\n\n但是我们很难把两个独立事件的概率组合到一起，以达到50%，请看下面的分析。\n\n#### 分类讨论的方式求取概率\n\n我们以抽到零命为例，对应的状态矩阵为$M$。因为初始状态（你可以理解为-1命）为A，此时可以理解为对应的概率为：$p_{11}P(获得一次五星) +p_{12}(获得二次五星)$，其中获得两次五星的概率模型可参考上面的卷积公式（由于二次五星也比较简单，大可自己分类讨论写）,如：\n\n$$ \\frac{1}{2}PDF(X) + \\frac{1}{2}PDF(Z)$$（注：x>90的部分，记为0即可，因为那部分情况已结束。）\n\n验证这一方法的正确性：\n\n```python\ntmp = 0.0\nfor i in range(0,179):\n    if(i<90): tmp += 0.5 * pdf_5[i];\n    tmp+=0.5*conv[i];\n    if(tmp>=0.5):\n        print(i);\n        break;\n//沿用上方的数组了，输出为79.\n因为列表下标是从0开始计数的，79 < 90 ，所以对应：80次祈愿可使抽到UP五星的概率达到50%。\n```\n\n如果需要制图，可以使用以下的画图模板代码\n\n```python\n#制图代码\nx_major_locator=MultipleLocator(4)#x分度值设置\ny_major_locator=MultipleLocator(0.1)\nax=plt.gca()\nax.xaxis.set_major_locator(x_major_locator)\nax.yaxis.set_major_locator(y_major_locator)\nplt.grid()  # 生成网格\nx_values = [x for x in range(1, 91)]\ny_values = [pdf_5[x] for x in range(0, 90)]\nplt.plot(x_values,y_values)\n```\n\n如果是多命，则需要更复杂的分类讨论。如：一命的情况，就需要二次转移矩阵$M^2$的各项作为转移概率了，包括(A A ， A !A A ， !A A A ， !A A !A A)四种状态对应的状态转移概率，以及多次的卷积结果。由于前面代码没有记忆，就不尝试了。\n\n### 尝试2：动态规划的角度\n\n#### 抽到多个五星角色中UP五星角色的个数概率\n\n其实上面的转移矩阵比较简单，直接可以写出状态转移方程，考虑动态规划。\n\n定义状态$dp[i][j][1]$表示第 $i$ 次获得的五星角色时得到当期UP角色A后，共获得了$j$次A角色，达到$j-1$命 （第一次获得A角色达到0命）；类似地，$dp[i][j][0]$ 表示第 $i$ 次获得的五星角色不是A。\n\n则状态转移方程：\n\n$$ dp[i][j][0] = \\frac{1}{2}dp[i-1][j][1] $$\n\n$$ dp[i][j][1] = \\frac{1}{2}dp[i-1][j-1][1] + dp[i-1][j-1][0]$$\n\n起点：$dp[0][0][1] = 1$\n\n由此可以记$dp[i][j]$为第$i$次获得五星角色后共获得$j$次（及以上）A角色的概率，则：\n\n$$ dp[i][j] = \\sum_{k=j}^{i}dp[i][k][1]+dp[i][k][0] $$\n\n\n\n尝试构造含$i,j,dp[i][j]$三个变量的图：![](http://img.070077.xyz/%E5%8E%9F%E7%A5%9E%E5%91%BD%E5%BA%A7%E6%8A%BD%E6%95%B0%E6%A6%82%E7%8E%87%E5%88%86%E5%B8%83%E5%9B%BE.png)\n\n由图中可以估计获取1~7次A角色时，使概率达到50%时，横坐标即为需要获得A角色的次数。（x，y）表示，已获得x次五星角色的情况下，y为对应的总共获取次数大于等于对应i的概率。\n\n#### 求取命座-祈愿次数概率\n\n定义：$ dp[i][j][k] $ ：第j次祈愿的结果对应k，并第i次获得A角色的概率，则状态转移方程：\n\n- 大保底状态：上次五星!A，这次必获得A；\n- 小保底状态：上次五星是A（初始状态），这次只有50%的概率获得A。\n- k = 0 ： 获得五星角色A\n- k = 1 ： 获得五星角色且!A\n\n（临时变量：tmp：上次获得五星的祈愿次数）\n\n- 注意：要明确状态转移的结果“from to”。循环遍历时，由j逐步+k确定后续值并进行迭代赋值，会导致一个点的值多次计入概率，所以最后取概率只需要取[0]\n\n$$ dp[i][j][0] = dp[i-1][tmp][1] * PDF(j-tmp) + dp[i-1][tmp][0] * \\frac{1}{2} * PDF(j-tmp)$$\n\n$$ dp[i][j][1] = dp[i][tmp][0] * \\frac{1}{2} * PDF(j-tmp)$$\n\n```python\nn5_cnt=1;#要抽出多少次A\nn5_tries=180;#准备的祈愿次数\ntmp = 0;\ndp_p = np.zeros((13, 180*n5_cnt+90,2), dtype=float);\ndp_p[0][0][0] = 1\nfor i in range (0,n5_cnt+1):\n        for j in range (0,n5_tries):\n            for k in range (1,91):\n                if(i-1>=0):\n                    dp_p[i][j+k][0] += dp_p[i-1][j][1] * pdf_5[k-1] + dp_p[i-1][j][0] * 0.5 * pdf_5[k-1];\n                dp_p[i][j+k][1] += dp_p[i][j][0] * 0.5 * pdf_5[k-1]\nposs=[]\nfor i in range(0,n5_tries):\n    tmp = tmp + dp_p[n5_cnt][i][0]\n    poss.append(tmp)\nprint(tmp)\nplt.plot(poss)\n#DEMO:0.4762677010731945\n```\n\n 与上面的卷积验证是一致的。\n\n0命概率图：![原神抽卡2次五星概率分布图.1png](http://img.070077.xyz/%E5%8E%9F%E7%A5%9E%E6%8A%BD%E5%8D%A12%E6%AC%A1%E4%BA%94%E6%98%9F%E6%A6%82%E7%8E%87%E5%88%86%E5%B8%83%E5%9B%BE.1png.png)\n\n#### 非默认状态开始的动态规划（To Be Continued…）\n\n如果开始状态为大保底状态，或已经有一定的祈愿次数呢？以后再写。\n\n## 四星角色祈愿分析\n\n预设：获取到五星时，不会重置四星角色的保底。且，以下策略，如果出了五星角色，先笑一笑，算法就当没祈愿哈~\n\n### 概览\n\n四星的分析只需要将上面的p_5相关改成p_4即可，在此省略不表，给出一定结论：![原神四星角色pdfcdf](http://img.070077.xyz/%E5%8E%9F%E7%A5%9E%E5%9B%9B%E6%98%9F%E8%A7%92%E8%89%B2pdfcdf.png)\n\n0命图：![原神4星0命抽数概率分布图](http://img.070077.xyz/%E5%8E%9F%E7%A5%9E4%E6%98%9F0%E5%91%BD%E6%8A%BD%E6%95%B0%E6%A6%82%E7%8E%87%E5%88%86%E5%B8%83%E5%9B%BE.png)\n\n### 算法\n\n定义：$ dp[i][j][k] $ ：第j次祈愿的结果对应k，并第i次获得B角色的概率，则状态转移方程：\n\n- 保底状态：上次四星!UP，这次必获得UP角色\n- k = 0 ： 获得想要的四星角色B\n- k = 1 ： 获得UP四星角色但不是B\n- k = 2：获得非UP四星角色\n\n（临时变量：tmp：上次获得四星的祈愿次数）\n\n$$ dp[i][j][0] = dp[i-1][tmp][1] * PDF(j-tmp) * \\frac{1}{6} \\\\+ dp[i-1][tmp][0] * \\frac{1}{6} * PDF(j-tmp) \\\\+ dp[i-1][tmp][1] * PDF(j-tmp) * \\frac{1}{3}$$\n\n$$ dp[i][j][1] = dp[i][tmp][0] * \\frac{1}{3} * PDF(j-tmp) \\\\+ dp[i][tmp][1] * PDF(j-tmp) * \\frac{1}{3} \\\\+  dp[i][tmp][2] * \\frac{2}{3} * PDF(j-tmp)$$\n\n$$ dp[i][j][2] = dp[i][tmp][0] * \\frac{1}{2} * PDF(j-tmp) + dp[i][tmp][1] * \\frac{1}{2} * PDF(j-tmp)$$\n\n任意代码：（原理与下方“无定轨机制武器祈愿”类似，这里人比较懒，直接对p_5移花接木了）\n\n```python\n#每抽概率\n#这是研究四星的，但是为了偷懒，捏：\ndef p_5(n):\n    if n < 8:\n        return 0.051;\n    elif n < 9:\n        return 0.561;\n    else:\n        return 1;\n        \npdf_5 = [];\ncdf_5 = [];\ntmp = 0.0;\n\nfor i in range (0,10):\n    tmp = p_5(i);\n    for j in range(0,i):\n        tmp = tmp * (1 - p_5(j))\n    pdf_5.append(tmp);\n\nfor i in range (0,10):\n    tmp = 0.0;\n    for j in range (0,i+1):\n        tmp = tmp + pdf_5[j];\n    cdf_5.append(tmp);\n    print(i+1,cdf_5[i])\n \nn5_cnt=1#要抽出多少次B\nn5_tries=130 * n5_cnt;#准备的祈愿次数\ntmp = 0;\ndp_p = np.zeros((13, 150*n5_cnt + 20,3), dtype=float);\ndp_p[0][0][0] = 1\n# 0 - B 1 - UP & !B 2- !UP\nfor i in range (0,n5_cnt+1):\n        for j in range (0,n5_tries):\n            for k in range (1,11):\n                if(i-1>=0):\n                    dp_p[i][j+k][0] += dp_p[i-1][j][2] * pdf_5[k-1] * 1/3\\\n                                    + dp_p[i-1][j][1] * pdf_5[k-1] * 1/6 + dp_p[i-1][j][0] * 1/6 * pdf_5[k-1];\n                dp_p[i][j+k][1] += dp_p[i][j][0] * 1/3 * pdf_5[k-1] + dp_p[i][j][2] * 2/3 * pdf_5[k-1]\\\n                                + dp_p[i][j][1] * 1/3 * pdf_5[k-1];\n                dp_p[i][j+k][2] += dp_p[i][j][0] * 1/2 * pdf_5[k-1] + dp_p[i][j][1] * 1/2 * pdf_5[k-1];\nposs=[]\nfor i in range(0,n5_tries):\n    tmp = tmp + dp_p[n5_cnt][i][0]\n    poss.append(tmp)\nprint(tmp)\n#制图代码，直接cv用\nx_major_locator=MultipleLocator(10)#x分度值设置\ny_major_locator=MultipleLocator(0.1)\nax=plt.gca()\nax.xaxis.set_major_locator(x_major_locator)\nax.yaxis.set_major_locator(y_major_locator)\nx_values = [x for x in range(1, n5_tries)]\nplt.grid()  # 生成网格\nplt.plot(poss)  \n```\n\n\n\n## 不同模型对比研究\n\n### 与无保底机制（均匀1.6%）的对比\n\n​\t修改\n\n```\ndef p_5(n):\n\treturn 0.016;\n```\n\n期望：不变；\n\n分位点图：![均匀1.6原神抽卡概率分布图](http://img.070077.xyz/%E5%9D%87%E5%8C%801.6%E5%8E%9F%E7%A5%9E%E6%8A%BD%E5%8D%A1%E6%A6%82%E7%8E%87%E5%88%86%E5%B8%83%E5%9B%BE.png)\n\n极端情况上升了~\n\n两次五星分布图：![均匀1.6原神抽卡2次五星概率分布图](http://img.070077.xyz/%E5%9D%87%E5%8C%801.6%E5%8E%9F%E7%A5%9E%E6%8A%BD%E5%8D%A12%E6%AC%A1%E4%BA%94%E6%98%9F%E6%A6%82%E7%8E%87%E5%88%86%E5%B8%83%E5%9B%BE.png)\n\n\n\n一命概率分布图：![均匀1.6原神抽卡一命概率分布图](http://img.070077.xyz/%E5%9D%87%E5%8C%801.6%E5%8E%9F%E7%A5%9E%E6%8A%BD%E5%8D%A1%E4%B8%80%E5%91%BD%E6%A6%82%E7%8E%87%E5%88%86%E5%B8%83%E5%9B%BE.png)\n\n可以发现，均匀和非均匀，有利有弊吧。\n\n### 与保底前均匀机制（魔改尝试1）的对比\n\n用我比较熟悉的c++建模以下（其实更精确的值为0.88%）\n\n$$  P(x) = \\begin{cases} 0.9\\% &{x\\leqslant 89}\\\\1&{x = 90} \\end{cases} $$\n\n期望：62.06（综合概率：1.61%）\n\n分位点分布图：\n\n![魔改1.6原神抽卡概率分布图](http://img.070077.xyz/%E9%AD%94%E6%94%B91.6%E5%8E%9F%E7%A5%9E%E6%8A%BD%E5%8D%A1%E6%A6%82%E7%8E%87%E5%88%86%E5%B8%83%E5%9B%BE.png)\n\n两次五星分布图：![魔改1.6原神抽卡2次五星概率分布图](http://img.070077.xyz/%E9%AD%94%E6%94%B91.6%E5%8E%9F%E7%A5%9E%E6%8A%BD%E5%8D%A12%E6%AC%A1%E4%BA%94%E6%98%9F%E6%A6%82%E7%8E%87%E5%88%86%E5%B8%83%E5%9B%BE.png)\n\n一命概率分布图：![魔改1.6原神抽卡一命概率分布图](http://img.070077.xyz/%E9%AD%94%E6%94%B91.6%E5%8E%9F%E7%A5%9E%E6%8A%BD%E5%8D%A1%E4%B8%80%E5%91%BD%E6%A6%82%E7%8E%87%E5%88%86%E5%B8%83%E5%9B%BE.png)\n\n会让更多人吃保底~\n\n# 武器祈愿分析\n\n## 概率递增保底机制及数字特征\n\n武器祈愿的机制和角色祈愿大体一致。算法参上，在此直接给出结论。\n\n五星武器概率：\n\n$$P(x) = \\begin{cases}0.7\\% & x\\leqslant62\\\\0.7\\%+7\\%(x-62) & 63\\leqslant x \\leqslant 71\\\\ 63.7\\% + 3.5\\%(x-71) & 72\\leqslant x \\leqslant 79 \\\\ 1 & x=80\\end{cases}$$ \n\n数学期望：54.25.\n\n综合概率：1.88%\n\n分布图：![原神武器抽卡概率分布图](http://img.070077.xyz/%E5%8E%9F%E7%A5%9E%E6%AD%A6%E5%99%A8%E6%8A%BD%E5%8D%A1%E6%A6%82%E7%8E%87%E5%88%86%E5%B8%83%E5%9B%BE.png)\n\n\n\n四星武器概率\n\n$$P(x) = \\begin{cases}6\\% & x\\leqslant 7\\\\66\\% & x = 8 \\\\ 96\\% & x = 9 \\\\ 1 & x=10\\end{cases}$$\n\n数学期望：6.74.\n\n综合概率：14.84%。\n\n你会发现，分成了四段，复杂了一点。\n\n```python\n#每抽概率\ndef p_5(n):\n    if n < 62:\n        return 0.007;\n    elif n < 71:\n        return 0.007 + (n - 62) * 0.07;\n    elif n < 79:\n        return 0.637 + (n - 71) * 0.035;\n    else:\n        return 1.0;\ndef p_4(n):\n    if n < 7:\n        return 0.06\n    elif n < 8:\n        return 0.66\n    elif n < 9:\n        return 0.96;\n    else:\n        return 1;\npdf_5 = [];#第x+1抽出概率\ncdf_5 = [];\ntmp = 0.0;\n\nfor i in range (0,80):\n    tmp = p_5(i);\n    for j in range(0,i):\n        tmp = tmp * (1.0 - p_5(j))\n    pdf_5.append(tmp);\n\nfor i in range (0,80):\n    tmp = 0.0;\n    for j in range (0,i+1):\n        tmp = tmp + pdf_5[j];\n    cdf_5.append(tmp);\n    print(i+1,cdf_5[i])\n```\n\n\n\n## 定轨机制下的资源规划（假设定轨M）\n\n### 获取五星武器M的祈愿次数分析\n\n由于命定值机制，马尔可夫过程比较复杂。于是考虑动态规划：\n\n定义$dp[i][j][k]$为第j次祈愿时第i次获得五星武器M，祈愿后k：\n\n- k = 0 : 命定值为0。表示抽到了M.\n- k = 1：命定值为1且抽到了N.\n- k = 2：命定值为1且抽到的是非UP武器。\n- k = 3：命定值为2，抽出来的不是M，具体是啥在本小节中不相关。\n\n$$ dp[i][j][0] = dp[i-1][tmp][0] * \\frac{3}{8} *PDF(j-tmp) \\\\+ dp[i-1][tmp][1] * \\frac{3}{8} * PDF(j-tmp) \\\\+ dp[i-1][tmp][2] * \\frac{1}{2}*PDF(j-tmp) \\\\+ dp[i-1][tmp][3] *PDF(j-tmp)$$\n\n$$ dp[i][j][1] = dp[i][tmp][0] *\\frac{1}{4}* PDF(j-tmp)$$\n\n$$ dp[i][j][2] = dp[i][tmp][0] *\\frac{3}{8}* PDF(j-tmp)$$\n\n$$ dp[i][j][3] = dp[i][tmp][1] * ( \\frac{3}{8} + \\frac{1}{4}) *PDF(j-tmp) \\\\ + dp[i][tmp][2] * \\frac{1}{2} * PDF(j-tmp)$$\n\n运行代码：\n\n```python\nn5_cnt=2;#要抽出多少次M\nn5_tries= 207;#准备的祈愿次数\ntmp = 0;\ndp_p = np.zeros((13, 330*n5_cnt,5), dtype=float);\ndp_p[0][0][0] = 1\nfor i in range (0,n5_cnt+1):\n        for j in range (0,n5_tries + n5_cnt + 1):\n            for k in range (1,81):\n                if(i-1>=0):\n                    dp_p[i][j+k][0] += dp_p[i-1][j][0] * pdf_5[k-1] * 0.375\\\n                                + dp_p[i-1][j][1] * 0.375 * pdf_5[k-1] \\\n                                + dp_p[i-1][j][2] * 0.5 * pdf_5[k-1]\\\n                                + dp_p[i-1][j][3] * pdf_5[k-1];\n                dp_p[i][j+k][1] += dp_p[i][j][0] * 0.25 * pdf_5[k-1];\n                dp_p[i][j+k][2] += dp_p[i][j][0] * 0.375 * pdf_5[k-1];\n                dp_p[i][j+k][3] += dp_p[i][j][1] * 0.625 * pdf_5[k-1]\\\n                                + dp_p[i][j][2] * 0.5 * pdf_5[k-1];\nposs=[]\nfor i in range(0,n5_tries):\n    tmp = tmp + dp_p[n5_cnt][i][0]\n    poss.append(tmp)\nprint(tmp)\nplt.plot(poss)\n#0.49317051582855165\n```\n\n进行99次祈愿后，获得M的概率达到50%。以下是获取一次武器M的概率分布图：\n\n![原神武器m抽卡概率分布图](http://img.070077.xyz/%E5%8E%9F%E7%A5%9E%E6%AD%A6%E5%99%A8m%E6%8A%BD%E5%8D%A1%E6%A6%82%E7%8E%87%E5%88%86%E5%B8%83%E5%9B%BE.png)\n\n### 获取五星武器N的祈愿次数分析\n\n问题：我定轨了M，反而想获取五星武器N…（反向定轨）\n\n定义$dp[i][j][k]$为第j次祈愿时第i次获得五星武器N，祈愿后k：\n\n- k = 0 : 命定值为0。表示抽到了M.\n- k = 1：命定值为1且抽到了N.\n- k = 2：命定值为1且抽到的是非UP武器。\n- k = 3：命定值为2，且抽到了N.\n- k = 4：命定值为2，且抽到的是非UP武器。\n\n$$ dp[i][j][0] = dp[i][tmp][0] * \\frac{3}{8} *PDF(j-tmp) \\\\ + dp[i][tmp][1] * \\frac{3}{8} * PDF(j-tmp) \\\\+ dp[i][tmp][2] * \\frac{1}{2}*PDF(j-tmp) \\\\+ dp[i][tmp][3] * PDF(j-tmp) \\\\ + dp[i][tmp][4] * PDF(j-tmp)$$\n\n$$ dp[i][j][1] = dp[i-1][tmp][0] *\\frac{3}{8}* PDF(j-tmp)$$\n\n$$ dp[i][j][2] = dp[i][tmp][0] *\\frac{1}{4}* PDF(j-tmp)$$\n\n$$ dp[i][j][3] = dp[i-1][tmp][1] * ( \\frac{3}{8}) * PDF(j-tmp) \\\\ + dp[i-1][tmp][2] * \\frac{1}{2} * PDF(j-tmp)$$\n\n$$ dp[i][j][4] = dp[i][tmp][1] * \\frac{1}{4} * PDF(j-tmp)$$\n\n```python\nn5_cnt=1;#要抽出多少次N\nn5_tries= 106;#准备的祈愿次数\ntmp = 0;\ndp_p = np.zeros((13, 510*n5_cnt + 80,5), dtype=float);\ndp_p[0][0][0] = 1\nfor i in range (0,n5_cnt+1):\n        for j in range (0,n5_tries + n5_cnt + 1):\n            for k in range (1,81):\n                dp_p[i][j+k][0] += dp_p[i][j][0] * pdf_5[k-1] * 0.375\\\n                                + dp_p[i][j][1] * 0.375 * pdf_5[k-1] \\\n                                + dp_p[i][j][2] * 0.5 * pdf_5[k-1]\\\n                                + dp_p[i][j][3] * pdf_5[k-1]\\\n                                + dp_p[i][j][4] * pdf_5[k-1];\n                dp_p[i][j+k][1] += dp_p[i-1][j][0] * 0.375 * pdf_5[k-1];\n                dp_p[i][j+k][2] += dp_p[i][j][0] * 0.25 * pdf_5[k-1];\n                dp_p[i][j+k][3] += dp_p[i-1][j][1] * 0.375 * pdf_5[k-1]\\\n                                + dp_p[i-1][j][2] * 0.5 * pdf_5[k-1];\n                dp_p[i][j+k][4] += dp_p[i][j][1] * 0.25 * pdf_5[k-1]\nposs=[]\nfor i in range(0,n5_tries):\n    tmp = tmp + dp_p[n5_cnt][i][1] + dp_p[n5_cnt][i][3]\n    poss.append(tmp)\nprint(tmp)\n#DEMO:0.5007747697175682\n```\n\n图表\n\n​    ![原神武器n抽卡概率分布图](http://img.070077.xyz/%E5%8E%9F%E7%A5%9E%E6%AD%A6%E5%99%A8n%E6%8A%BD%E5%8D%A1%E6%A6%82%E7%8E%87%E5%88%86%E5%B8%83%E5%9B%BE.png)\n\n### 获取五星武器M、N的祈愿次数分析（To Be Updated…)\n\n问题：我定轨了M，但M、N都想要。\n\n我可能比较蠢：四维动态规划？\n\n定义$dp[h][i][j][k]$为第j次祈愿时第i次获得五星武器N，第h获得五星武器M，祈愿后k：……（同上）\n\n呃，我们先不考虑土豪了哈，我们只考虑都只获得1次的情况，只需要把`tmp = tmp + dp_p[n5_cnt][i][1] + dp_p[n5_cnt][i][3]` 再加一项 `dp_p[n5_cnt][i][0]` ？\n\n我也希望这能成功，但是这么直接地不可行，因为前面那两项的概率本身就包含了上一次抽到M的情况，再加会导致重复计算，我没想到别的方式改良之。\n\n另一种思路是分类讨论了，分为先获得M后获得N、先获得N再获得M两种情况。\n\n再者就是还是含泪：\n\n- 需要做出一定的修改，使状态转移时，不忽略h的出现次数。\n\n$$ dp[h][i][j][0] = dp[h-1][i][tmp][0] * \\frac{3}{8} *PDF(j-tmp) \\\\ + dp[h-1][i][tmp][1] * \\frac{3}{8} * PDF(j-tmp) \\\\+ dp[h-1][i][tmp][2] * \\frac{1}{2}*PDF(j-tmp) \\\\+ dp[h-1][i][tmp][3] * PDF(j-tmp) \\\\ + dp[h-1][i][tmp][4] * PDF(j-tmp)$$\n\n$$ dp[h][i][j][1] = dp[h][i-1][tmp][0] *\\frac{3}{8}* PDF(j-tmp)$$\n\n$$ dp[h][i][j][2] = dp[h][i][tmp][0] *\\frac{1}{4}* PDF(j-tmp)$$\n\n$$ dp[h][i][j][3] = dp[h][i-1][tmp][1] * ( \\frac{3}{8}) * PDF(j-tmp) \\\\ + dp[h][i-1][tmp][2] * \\frac{1}{2} * PDF(j-tmp)$$\n\n$$ dp[h][i][j][4] = dp[h][i][tmp][1] * \\frac{1}{4} * PDF(j-tmp)$$\n\n事实证明上面的方法不一定获得了正确答案。这个错误是没有价值的吗，不，他可能会给一个同样想研究这一问题的人一个参考。于是提出下面的形式：\n\n定义$dp[i][j][k]$为第j次祈愿时，i - 获得的目标种类数 , 祈愿后k同上。\n\n其实关键原因和上面的“加一项”一样，就是因为最后获取概率时，需要涵盖多个状态。以前的动态规划获取概率时，获取的状态间互相不存在依赖，而这次获取概率时，各个状态内部的转移存在相关。\n\n最近灵感较为枯竭，先赶别的ddl了。在此附上可能是错误的代码（若考虑较大次数，可能需修改码参数/概率不准确）和运行结果：\n\n```python\nn5_cnt_M=1;#要抽出多少次M,N\nn5_cnt_N=1;\nn5_cnt=n5_cnt_M + n5_cnt_N;\nn5_tries= 180*n5_cnt;#准备的祈愿次数\ntmp = 0;\ndp_p = np.zeros((13,13, 310*n5_cnt + 80,5), dtype=float);\ndp_p[0][0][0][0] = 1\n\nh = 0;\nfor h in range (0,3*n5_cnt_M +1):\n    for i in range(0,3*n5_cnt_N+1):\n        for j in range (0,n5_tries + n5_cnt + 1):\n            for k in range (1,81):\n                    dp_p[h][i][j+k][0] += dp_p[h-1][i][j][0] * pdf_5[k-1] * 0.375\\\n                                + dp_p[h-1][i][j][1] * 0.375 * pdf_5[k-1] \\\n                                + dp_p[h-1][i][j][2] * 0.5 * pdf_5[k-1]\\\n                                + dp_p[h-1][i][j][3] * pdf_5[k-1]\\\n                                + dp_p[h-1][i][j][4] * pdf_5[k-1];\n                    dp_p[h][i][j+k][1] += dp_p[h][i-1][j][0] * 0.375 * pdf_5[k-1];\n                    dp_p[h][i][j+k][2] += dp_p[h][i][j][0] * 0.25 * pdf_5[k-1];\n                    dp_p[h][i][j+k][3] += dp_p[h][i-1][j][1] * 0.375 * pdf_5[k-1]\\\n                                + dp_p[h][i-1][j][2] * 0.5 * pdf_5[k-1];\n                    dp_p[h][i][j+k][4] += dp_p[h][i][j][1] * 0.25 * pdf_5[k-1]\n\nposs=[]\nfor i in range(0,n5_tries):\n    for i1 in range (n5_cnt_M,3*n5_cnt_M+1):\n        tmp += dp_p[i1][n5_cnt_N][i][1] + dp_p[i1][n5_cnt_N][i][3]\n    for i2 in range(n5_cnt_N,3*n5_cnt_N+1):\n        tmp += dp_p[n5_cnt_M][i2][i][0];\n    poss.append(tmp)\nprint(tmp)\n#制图代码，直接cv用\nx_major_locator=MultipleLocator(20)#x分度值设置\ny_major_locator=MultipleLocator(0.1)\nax=plt.gca()\nax.xaxis.set_major_locator(x_major_locator)\nax.yaxis.set_major_locator(y_major_locator)\nplt.grid()  # 生成网格\nplt.plot(poss)\n```\n\n![原神武器m且n抽卡概率分布图](http://img.070077.xyz/%E5%8E%9F%E7%A5%9E%E6%AD%A6%E5%99%A8m%E4%B8%94n%E6%8A%BD%E5%8D%A1%E6%A6%82%E7%8E%87%E5%88%86%E5%B8%83%E5%9B%BE.png)\n\n拓展问题：我先定轨了M，获取M后定轨N（命定值清零），参考上面两个问题叠加应该可以。\n\n### 四星武器的分析\n\n和上面四星角色祈愿分析思想一致。\n\n```python\n#偷懒：p_5的内容实际是p_4\nn5_cnt=1#要抽出多少次F\nn5_tries=130 * n5_cnt;#准备的祈愿次数\ntmp = 0;\ndp_p = np.zeros((13, 150*n5_cnt + 20,3), dtype=float);\ndp_p[0][0][0] = 1\n# 0 - F 1 - UP & !F 2- !UP\nfor i in range (0,n5_cnt+1):\n        for j in range (0,n5_tries):\n            for k in range (1,11):\n                if(i-1>=0):\n                    dp_p[i][j+k][0] += dp_p[i-1][j][2] * pdf_5[k-1] * 1/5\\\n                                    + dp_p[i-1][j][1] * pdf_5[k-1] * 3/20 + dp_p[i-1][j][0] * 3/20 * pdf_5[k-1];\n                dp_p[i][j+k][1] += dp_p[i][j][0] * 3/5 * pdf_5[k-1] + dp_p[i][j][2] * 4/5 * pdf_5[k-1]\\\n                                + dp_p[i][j][1] * 3/5 * pdf_5[k-1];\n                dp_p[i][j+k][2] += dp_p[i][j][0] * 1/4 * pdf_5[k-1] + dp_p[i][j][1] * 1/4 * pdf_5[k-1];\nposs=[]\nfor i in range(0,n5_tries):\n    tmp = tmp + dp_p[n5_cnt][i][0]\n    poss.append(tmp)\nprint(tmp)\n#制图代码，直接cv用\nx_major_locator=MultipleLocator(10)#x分度值设置\ny_major_locator=MultipleLocator(0.1)\nax=plt.gca()\nax.xaxis.set_major_locator(x_major_locator)\nax.yaxis.set_major_locator(y_major_locator)\nx_values = [x for x in range(1, n5_tries)]\nplt.grid()  # 生成网格\nplt.plot(poss)  \n```\n\n![原神四星武器f抽卡概率分布图](http://img.070077.xyz/%E5%8E%9F%E7%A5%9E%E5%9B%9B%E6%98%9F%E6%AD%A6%E5%99%A8f%E6%8A%BD%E5%8D%A1%E6%A6%82%E7%8E%87%E5%88%86%E5%B8%83%E5%9B%BE.png)\n\n## 无定轨机制下武器祈愿分析\n\n和上面四星角色祈愿分析思想一致。![原神武器m不定轨抽卡概率分布图](http://img.070077.xyz/%E5%8E%9F%E7%A5%9E%E6%AD%A6%E5%99%A8m%E4%B8%8D%E5%AE%9A%E8%BD%A8%E6%8A%BD%E5%8D%A1%E6%A6%82%E7%8E%87%E5%88%86%E5%B8%83%E5%9B%BE.png)\n\n```python\n#这次下面是真的武器池概率分布p_5了哈\nn5_cnt=1#要抽出多少次M\nn5_tries=240 * n5_cnt;#准备的祈愿次数\ntmp = 0;\ndp_p = np.zeros((13, 320*n5_cnt + 20,3), dtype=float);\ndp_p[0][0][0] = 1\n# 0 - M 1 - UP & !M 2- !UP\nfor i in range (0,n5_cnt+1):\n        for j in range (0,n5_tries):\n            for k in range (1,81):\n                if(i-1>=0):\n                    dp_p[i][j+k][0] += dp_p[i-1][j][2] * pdf_5[k-1] * 1/2 \\\n                                    + dp_p[i-1][j][1] * pdf_5[k-1] * 3/8 + dp_p[i-1][j][0] * 3/8 * pdf_5[k-1];\n                dp_p[i][j+k][1] += dp_p[i][j][0] * 3/8 * pdf_5[k-1] + dp_p[i][j][2] * 1/2 * pdf_5[k-1]\\\n                                + dp_p[i][j][1] * 3/8 * pdf_5[k-1];\n                dp_p[i][j+k][2] += dp_p[i][j][0] * 1/4 * pdf_5[k-1] + dp_p[i][j][1] * 1/4 * pdf_5[k-1];\nposs=[]\nfor i in range(0,n5_tries):\n    tmp = tmp + dp_p[n5_cnt][i][0]\n    poss.append(tmp)\nprint(tmp)\n#制图代码，直接cv用\nx_major_locator=MultipleLocator(15)#x分度值设置\ny_major_locator=MultipleLocator(0.1)\nax=plt.gca()\nax.xaxis.set_major_locator(x_major_locator)\nax.yaxis.set_major_locator(y_major_locator)\nx_values = [x for x in range(1, n5_tries)]\nplt.grid()  # 生成网格\nplt.plot(poss)  \n```\n\n你如果和上面定轨时比较，会发现你想要M的话，需要投入稍微更多的抽数。而且可以看见，当投入200抽时，定轨机制下的获取M的概率已经逐步收敛至1。而不定轨机制下，获取到的概率的概率仅在80%附近，且之后收敛较慢，极端情况的发生概率并不低。\n\n有关不定轨又同时想要M和N的，TBC…\n\n# 总结\n\n概率分析还可以分析：如何配置属性让伤害最大化等问题。概率论作为一种打破人的直觉的东西，实在是让人又爱又恨。本文不仅仅局限于传统的期望范畴，结合具体概率的分布分析了对应的抽数需求。由于祈愿机制的概率不是恒定的，期望与中分位点存在区别，可以用平均GDP和中位数来感受。\n\n致谢：感谢张老师的帮助和OneBST的分享。\n\n【To Be Continued】\n\n- 同时研究多个四星的祈愿次数\n\n- 常驻祈愿结合“联动规则”的分析\n\n- 常驻祈愿与UP祈愿结合分析\n\n- 蒙特卡罗模拟与大数定律\n\n- 通过置信度研究极端情况\n\n\n\n\n\n","source":"_posts/概率论论文.md","raw":"#《原神》祈愿机制概率研究\n\n【摘要】本文以概率论、随机过程理论等工具研究游戏《原神》中的祈愿机制，主要基于动态规划，以“期望”和“概率的概率”两大分析方向进行数据处理，并根据分析结果总结了一些方便玩家规划金钱与资源的建议。由于追求多次获得五星道具的玩家基本“不差钱”，本文附有获取少量五星情况下的数据可视化。\n\n[TOC]\n\n> Version:20220105\n>\n> - 修了讲一遍时找到的笔误\n\n## 规则表述\n\n旅行者（玩家）可以通过祈愿机制获取“五星角色”“五星武器“”四星角色“”四星武器“来提高战斗力。其中，角色具有命之座机制，首次获得为0命，最高6命，命座数越高，角色越强；类似地，武器拥有精炼层数机制，首次获得为1阶，最高5阶。\n\n最近的版本更新中，《原神》的祈愿机制也发生了一定的变化。\n\n以下是《原神》两个祈愿机制的官方描述（https://ys.mihoyo.com/main/news/public）：\n\n### 角色祈愿\n\n**五星角色祈愿的基础概率为0.600%，综合概率（含保底）为1.600%**，最多90次祈愿必定能通过保底获取5星角色。\n\n当祈愿获取到5星角色时，有50.000%的概率为本期5星UP角色「A1」*（小保底）*。如果本次祈愿获取的5星角色非本期5星UP角色，下次祈愿获取的5星角色必定为本期5星UP角色*（大保底）*。\n\n**4星物品祈愿的基础概率为5.100%，4星角色祈愿的基础概率为2.550%，4星武器祈愿的基础概率为2.550%，4星物品祈愿的综合概率（含保底）为13.000%。**最多10次祈愿必定能通过保底获取4星或以上物品，通过保底获取4星物品的概率为99.400%，获取5星物品的概率为0.600%。\n\n当祈愿获取到4星物品时，有50.000%的概率为本期4星UP角色「B」、「C」、「D」中的一个。如果本次祈愿获取的4星物品非本期4星UP角色，下次祈愿获取的4星物品必定为本期4星UP角色。当祈愿获取到4星UP物品时，每个本期4星UP角色的获取概率均等。\n\n角色祈愿包括「角色活动祈愿-1」和「角色活动祈愿-2」，祈愿次数和保底完全共享，共同累计。二者区别仅在于当期UP的五星角色不同。\n\n### 武器祈愿\n\n**武器祈愿中，5星武器祈愿的基础概率为0.700%，综合概率（含保底）为1.850%，**最多80次祈愿必定能通过保底获取5星武器。\n\n当祈愿获取到5星武器时，有75.000%的概率为本期5星UP武器「M」、「N」中的一个。如果本次祈愿获取的5星武器非本期5星UP武器，下次祈愿获取的5星武器必定为本期5星UP武器。\n\n【定轨机制】命定值：玩家可以指定一把本期5星UP武器（定轨）。当获取到的5星武器为非当前定轨武器时，获得1点命定值，命定值达到满值2后，在本祈愿中获得的下一把5星武器必定为当前定轨武器。获取到当前定轨武器时，无论当前命定值是否达到满值，都将会重置为0，重新累计。在未通过命定值达到满值获取定轨武器的情况下，当祈愿获取到5星UP物品时，每把本期5星UP武器的获取概率均等。\n\n未使用「神铸定轨」定轨武器时，将不会累积命定值。\n\n**4星物品祈愿的基础概率为6.000%，4星角色祈愿的基础概率为3.000%，4星武器祈愿的基础概率为3.000%，4星物品祈愿的综合概率（含保底）为14.500%。**最多10次祈愿必定能通过保底获取4星或以上物品，通过保底获取4星物品的概率为99.300%，获取5星物品的概率为0.700%。\n\n当祈愿获取到4星物品时，有75.000%的概率为本期4星UP武器「F」、「G」、「H」、「J」、「K」中的一个。如果本次祈愿获取的4星物品非本期4星UP武器，下次祈愿获取的4星物品必定为本期4星UP武器。当祈愿获取到4星UP物品时，每把本期4星UP武器的获取概率均等。\n\n# 角色祈愿分析\n\n## 五星角色概率建模\n\n   前面的作业中，笔者通过运行代码和期望分析，对角色祈愿的机制进行了尝试1的模拟，简单回顾如下：\n\n### 尝试1：89次伯努利实验\n\n建模1：前89次祈愿，每次获得五星角色的概率均为0.6%，若前89次实验没有获得五星角色，则获取五星角色的概率为100%。\n\n则可以建模二项分布概率密度：\n\n$$ PDF(X = k) = (1-p)^{k-1}p(p = 0.6 \\%)$$\n\n$$ CDF(X = k) = (1 - p)^k$$\n\n计算每次获取五星角色的祈愿数期望：\n\n$$ E(X) = 90(1-CDF(89)) + \\sum_{i=1}^{89}iPDF(x=i)$$\n\n得到综合概率：\n\n$$P = \\frac{1}{E(X)} $$\n\n结果为：1.435%。（详见week9作业）\n\n与官方描述不符。实际上，官方提到的0.6%是基础概率，说明不是恒定概率的伯努利实验，于是提出模型2.\n\n### 尝试2：概率递增的保底机制\n\n建模2：在一定抽数都没有得到五星角色后，获得五星角色概率开始线性上升，直到第90抽达到100%。 \n\n由于具体概率密度没有官方文档，只能站在前人的分析上，根据结合数据统计的开源项目（https://github.com/OneBST/GGanalysis，本文实际上相当于模型的复现）采用的模型，第x次祈愿获得五星角色的概率如下：\n\n$$ P(x) = \\begin{cases} 0.6\\% &{x<=73}\\\\ 0.6\\% + 6\\%(x - 73) &{74<=x<=89}\\\\1&{x = 90} \\end{cases}$$\n\n由此，可以得到第x次祈愿得到五星角色的分布列（类似于几何分布）：\n\n$$ PDF(x) = P(x) * \\prod_{k = 1}^{x - 1}1-P(x) $$\n\n$$ PDF(x) = \\begin{cases} (1 - 0.6\\%)^{x-1}\\times0.6\\% &{x\\leqslant73}\\\\ (1-0.6\\%)^{73} \\times \\sum_{k = 74}^{x} (1- 6\\%(k - 73))^{k-73}(6\\%(k-73)) &{74\\leqslant x\\leqslant89}\\\\(1-0.6\\%)^{73} \\times \\sum_{k = 74}^{89} (1- 6\\%(k - 73))^{k-73}&{x = 90} \\end{cases} $$\n\n**该模型平均获取五星角色的祈愿次数为62.3。**该模型下五星角色的综合概率为1.605%。\n\n注：期望计算公式：\n\n$$ E(X) = \\sum_{i=1}^{x}PDF(x)\\times x $$\n\n## 概率递增保底机制下的数字特征\n\n### 求数据特征\n\n在这里处理一个认识误区：期望 != 概率为50%的点（中分位点）。\n\n也就是说，期望作为概率的平均值，$ CDF(EX) = 0.5 $ **是不成立的**。 注意到这一前提，才能比较正确地理解下面的结论。\n\n由于其概率密度并不是均匀分布的，差别较大，选择平均数似乎不太合适。所以我们获取中分位点。根本不应该是程序员能写出来的粗糙代码验证：\n\n```python\nimport numpy as np\nimport matplotlib as mlp\nimport matplotlib.pyplot as plt\nfrom matplotlib.pyplot import MultipleLocator\ndef p_5(n):\n    if n < 73:\n        return 0.006\n    elif n < 89:\n        return 0.006 + (n - 72) * 0.06\n    else:\n        return 1\n    \npdf_5 = [];\ncdf_5 = [];\ntmp = 0.0;\n\nfor i in range (0,90):\n    tmp = p_5(i);\n    for j in range(0,i):\n        tmp = tmp * (1 - p_5(j))\n    pdf_5.append(tmp);\n#注：下文中其他代码可能要用到p_5,p_4函数,pdf_5列表哦\n\nfor i in range (0,90):\n    tmp = 0.0;\n    for j in range (0,i+1):\n        tmp = tmp + pdf_5[j];\n    cdf_5.append(tmp);\n    print(i+1,cdf_5[i])\n# out:\n#75 0.4739047630777248\n#76 0.571758477145268\n```\n\n该模型的概率密度函数（蓝线）和分布函数（黄线）图：\n\n![img](http://img.070077.xyz/%E5%8E%9F%E7%A5%9E%E6%8A%BD%E5%8D%A1%E6%A6%82%E7%8E%87%E5%88%86%E5%B8%83%E5%9B%BE.png)\n\n我们不妨乐观一点，中分位点：75.\n\n注：最概然祈愿次数为77。也就是说，在第77次祈愿获取五星角色的概率最高。\n\n每次获得五星角色，需要的祈愿次数记为$N$. 则：\n\n- 从期望角度考虑，N = 62.3.\n- 从中分位点角度考虑，N = 75.\n\n实际理解为：需要75次祈愿，才能使获得5星角色的发生概率达到50%（实际：46.8%）。\n\n这种分布具有较强的右偏性。上面分析过，这两个数字特征具有不同的分析意义，可以理解为：\n\n+ 祈愿623次，期望获得10个五星角色。（期望值）\n+ 祈愿75次，能使获得五星角色的概率达到50%。\n\n### 由期望特征进行资源规划\n\n回到规则中，解决以下问题：\n\n#### 获得五星角色A的期望次数分析\n\n对于期望分析：注意到，对于获取当期UP五星角色，最多需要2次获得五星角色。也就是说，有50%的概率，仅需要获取一次五星角色；有50%的概率，需要获取2次五星角色。也就是说，需要获得五星角色的次数：\n\n$$ 1 \\times 50\\% + 2 \\times 50\\%  = 1.5 $$\n\n对于“获取五星角色”而言，多次获取（不论是否为当期UP角色）之间互相独立，因此需要的祈愿次数为$1.5 \\times 62.3 = 93.45$ 次。\n\n#### 获得6命座A角色的期望次数分析\n\n注意到，对于“获取五星角色”而言，多次获取（不论是否为当期UP角色）之间互相独立。考虑这个问题：对于“获取A角色”事件之间，是相互独立的吗？\n\n从期望角度考虑，可以说：是的。参考上面的思路，只需要“获取A角色”发生7次即可。因此需要的祈愿次数为 $1.5N \\times 7 = 10.5N$ 也就是 654.15 次。\n\n#### 获得四星角色B的期望次数分析\n\n由于涉及“基础概率”，我们沿用上一开源项目模型的概率递增保底机制结论：\n\n- 从第9次祈愿处开始上升。\n\n- 获得五星角色并不会重置四星保底。\n\n第x次祈愿获得四星角色的概率如下：\n\n$$ P(x) = \\begin{cases} 5.1\\% & {x\\leqslant8}\\\\ 56.1\\% &{x = 9}\\\\1&{x = 10} \\end{cases}$$\n\n$$ PDF(x) = P(x) * \\prod_{k = 1}^{x - 1}1-P(x)  = \\begin{cases} (1 - 5.1\\%)^{x-1}\\times5.1\\% & {x\\leqslant8}\\\\ (1-5.1\\%)^8\\times56.1\\% &{x=9}\\\\(1-5.1\\%)^8\\times43.9\\%&{x = 10} \\end{cases}$$ \n\n期望值：\n\n$$ E(X) = \\sum_{i=1}^{x}PDF(x)\\times x = 7.66$$ \n\n综合概率：13.05%.\n\n对于期望分析：注意到，对于获取当期UP五星角色，仅有$\\frac{1}{3}$的概率得到当期UP的四星角色中的B，且每次获得当期四星角色时，有50%的概率，仅需要获取一次四星角色；有50%的概率，需要获取2次四星角色。也就是说，获得角色B的次数期望为$1.5 \\times 3 \\times E(X) = 34.5$ 。\n\n### 由分位点特征进行分析\n\n从“概率的概率”角度分析便没有期望分析那么简单了。中位点与期望的乘积并不能得到叠加事件的中位点。基本上大部分分而治之的想法均不满足独立性要求。我们需要寻找更一般的数学模型：\n\n#### 获得多次五星角色的分位点分析\n\n接下来，由于**使获得两次五星角色的概率达到50%的祈愿次数不等于获得一次五星角色祈愿次数的中位点的2倍**，我们需要计算分布的**叠加**。\n\n我们从简单问题入手（自己编的）：\n\n(1) 一直抛硬币，直到总共出现2次正面朝上，求期望的抛硬币次数——显然是4.\n\n(2) 需要抛多少次硬币，使【至少出现2次正面朝上】的概率达到50%。\n\n(3) 需要抛多少次骰子，使【至少出现2次点数1】的概率达到50%。\n\n题目（2）（3）这类问题，可以转化成“几何分布的叠加问题”。这里的概率稳定~~比较简单~~，还可以参阅负二项分布有关资料。\n\n而对于的祈愿的建模，概率不稳定，有三种可能的思考方向：一可以用模拟动态规划处理，二是对各种情况进行全概率公式展开（~~工作量极大~~），三是离散信号的进行卷积运算:$P(Z=X+Y=z) = \\sum_1^\\infty PDF(X=z-y)P(X=y)$\n\n笔者采用第三种方法。\n\n各位修改一下代码的变量，即可获取想要的值。\n\n```python\nc5_need = 2#需要抽出几次五星角色；\nc5_poss = 0.25#想知道的概率;\nconv = pdf_5;\nfor cnt in range(0,c5_need - 1):\n    conv=np.convolve(conv,pdf_5,'full')\n    plt.plot(conv)\n    tmp = 0.0\n    for i in range (0,len(conv)):\n        tmp += conv[i]\n        if(cnt == c5_need - 2 and tmp >= c5_poss):\n            print(i+c5_need);\n            break\n    #DEMO\n    #135 -- 需要祈愿135次，才有50%的概率获得两个五星角色。\n\t#祈愿154次，有75%的概率获得两个五星角色。\n```\n\n我对获得两次的情况列了个分布图：\n\n![原神抽卡2次五星概率分布图](http://img.070077.xyz/%E5%8E%9F%E7%A5%9E%E6%8A%BD%E5%8D%A12%E6%AC%A1%E4%BA%94%E6%98%9F%E6%A6%82%E7%8E%87%E5%88%86%E5%B8%83%E5%9B%BE.png)\n\n#### 双角色池祈愿\n\n这个其实没什么太大的变化，把A2等价成A1，就可以和上文的A的结论统一了。\n\n## 保底依赖下的分位点分析\n\n### 尝试1：将“保底获得的五星”和“祈愿次数”拆成两个独立事件\n\n#### 保底之间的马尔可夫过程\n\n由于角色祈愿机制满足：本次获取五星角色是否为A的概率仅取决于上次获取的五星角色是否为A。符合马尔可夫过程（状态$i$只取决于上一次状态$i-1$，与再先前的状态相互独立。参：课本P321）的建模标准，可以做出以下状态图和概率转移矩阵：\n\n```mermaid\ngraph LR\nA --1/2--> !A\n!A --1--> A\nA --1/2--> A\n```\n$$ M = \\space \\begin{matrix}  & A & !A\\\\A & {1}\\over{2} & {1}\\over{2}\\\\!A & 1 & 0\\end{matrix}$$\n\n马尔可夫链在三门问题、经济学分析、自然语言处理等领域具有广泛的应用，在极值环境下具有平稳分布的特点。以下进行模拟分析。\n\n收敛的综合概率：$M^\\infty$。经过计算，可知A物品的综合概率为$\\frac{2}{3}$ 。这个计算结果可以理解为：任意一次获得五星角色，有$\\frac{2}{3}$的概率是A.（初始状况：刚获得A，以说明存在小保底）\n\n而对于中间情况的分析，可对应转换为矩阵的乘法和加法运算。\n\n但是我们很难把两个独立事件的概率组合到一起，以达到50%，请看下面的分析。\n\n#### 分类讨论的方式求取概率\n\n我们以抽到零命为例，对应的状态矩阵为$M$。因为初始状态（你可以理解为-1命）为A，此时可以理解为对应的概率为：$p_{11}P(获得一次五星) +p_{12}(获得二次五星)$，其中获得两次五星的概率模型可参考上面的卷积公式（由于二次五星也比较简单，大可自己分类讨论写）,如：\n\n$$ \\frac{1}{2}PDF(X) + \\frac{1}{2}PDF(Z)$$（注：x>90的部分，记为0即可，因为那部分情况已结束。）\n\n验证这一方法的正确性：\n\n```python\ntmp = 0.0\nfor i in range(0,179):\n    if(i<90): tmp += 0.5 * pdf_5[i];\n    tmp+=0.5*conv[i];\n    if(tmp>=0.5):\n        print(i);\n        break;\n//沿用上方的数组了，输出为79.\n因为列表下标是从0开始计数的，79 < 90 ，所以对应：80次祈愿可使抽到UP五星的概率达到50%。\n```\n\n如果需要制图，可以使用以下的画图模板代码\n\n```python\n#制图代码\nx_major_locator=MultipleLocator(4)#x分度值设置\ny_major_locator=MultipleLocator(0.1)\nax=plt.gca()\nax.xaxis.set_major_locator(x_major_locator)\nax.yaxis.set_major_locator(y_major_locator)\nplt.grid()  # 生成网格\nx_values = [x for x in range(1, 91)]\ny_values = [pdf_5[x] for x in range(0, 90)]\nplt.plot(x_values,y_values)\n```\n\n如果是多命，则需要更复杂的分类讨论。如：一命的情况，就需要二次转移矩阵$M^2$的各项作为转移概率了，包括(A A ， A !A A ， !A A A ， !A A !A A)四种状态对应的状态转移概率，以及多次的卷积结果。由于前面代码没有记忆，就不尝试了。\n\n### 尝试2：动态规划的角度\n\n#### 抽到多个五星角色中UP五星角色的个数概率\n\n其实上面的转移矩阵比较简单，直接可以写出状态转移方程，考虑动态规划。\n\n定义状态$dp[i][j][1]$表示第 $i$ 次获得的五星角色时得到当期UP角色A后，共获得了$j$次A角色，达到$j-1$命 （第一次获得A角色达到0命）；类似地，$dp[i][j][0]$ 表示第 $i$ 次获得的五星角色不是A。\n\n则状态转移方程：\n\n$$ dp[i][j][0] = \\frac{1}{2}dp[i-1][j][1] $$\n\n$$ dp[i][j][1] = \\frac{1}{2}dp[i-1][j-1][1] + dp[i-1][j-1][0]$$\n\n起点：$dp[0][0][1] = 1$\n\n由此可以记$dp[i][j]$为第$i$次获得五星角色后共获得$j$次（及以上）A角色的概率，则：\n\n$$ dp[i][j] = \\sum_{k=j}^{i}dp[i][k][1]+dp[i][k][0] $$\n\n\n\n尝试构造含$i,j,dp[i][j]$三个变量的图：![](http://img.070077.xyz/%E5%8E%9F%E7%A5%9E%E5%91%BD%E5%BA%A7%E6%8A%BD%E6%95%B0%E6%A6%82%E7%8E%87%E5%88%86%E5%B8%83%E5%9B%BE.png)\n\n由图中可以估计获取1~7次A角色时，使概率达到50%时，横坐标即为需要获得A角色的次数。（x，y）表示，已获得x次五星角色的情况下，y为对应的总共获取次数大于等于对应i的概率。\n\n#### 求取命座-祈愿次数概率\n\n定义：$ dp[i][j][k] $ ：第j次祈愿的结果对应k，并第i次获得A角色的概率，则状态转移方程：\n\n- 大保底状态：上次五星!A，这次必获得A；\n- 小保底状态：上次五星是A（初始状态），这次只有50%的概率获得A。\n- k = 0 ： 获得五星角色A\n- k = 1 ： 获得五星角色且!A\n\n（临时变量：tmp：上次获得五星的祈愿次数）\n\n- 注意：要明确状态转移的结果“from to”。循环遍历时，由j逐步+k确定后续值并进行迭代赋值，会导致一个点的值多次计入概率，所以最后取概率只需要取[0]\n\n$$ dp[i][j][0] = dp[i-1][tmp][1] * PDF(j-tmp) + dp[i-1][tmp][0] * \\frac{1}{2} * PDF(j-tmp)$$\n\n$$ dp[i][j][1] = dp[i][tmp][0] * \\frac{1}{2} * PDF(j-tmp)$$\n\n```python\nn5_cnt=1;#要抽出多少次A\nn5_tries=180;#准备的祈愿次数\ntmp = 0;\ndp_p = np.zeros((13, 180*n5_cnt+90,2), dtype=float);\ndp_p[0][0][0] = 1\nfor i in range (0,n5_cnt+1):\n        for j in range (0,n5_tries):\n            for k in range (1,91):\n                if(i-1>=0):\n                    dp_p[i][j+k][0] += dp_p[i-1][j][1] * pdf_5[k-1] + dp_p[i-1][j][0] * 0.5 * pdf_5[k-1];\n                dp_p[i][j+k][1] += dp_p[i][j][0] * 0.5 * pdf_5[k-1]\nposs=[]\nfor i in range(0,n5_tries):\n    tmp = tmp + dp_p[n5_cnt][i][0]\n    poss.append(tmp)\nprint(tmp)\nplt.plot(poss)\n#DEMO:0.4762677010731945\n```\n\n 与上面的卷积验证是一致的。\n\n0命概率图：![原神抽卡2次五星概率分布图.1png](http://img.070077.xyz/%E5%8E%9F%E7%A5%9E%E6%8A%BD%E5%8D%A12%E6%AC%A1%E4%BA%94%E6%98%9F%E6%A6%82%E7%8E%87%E5%88%86%E5%B8%83%E5%9B%BE.1png.png)\n\n#### 非默认状态开始的动态规划（To Be Continued…）\n\n如果开始状态为大保底状态，或已经有一定的祈愿次数呢？以后再写。\n\n## 四星角色祈愿分析\n\n预设：获取到五星时，不会重置四星角色的保底。且，以下策略，如果出了五星角色，先笑一笑，算法就当没祈愿哈~\n\n### 概览\n\n四星的分析只需要将上面的p_5相关改成p_4即可，在此省略不表，给出一定结论：![原神四星角色pdfcdf](http://img.070077.xyz/%E5%8E%9F%E7%A5%9E%E5%9B%9B%E6%98%9F%E8%A7%92%E8%89%B2pdfcdf.png)\n\n0命图：![原神4星0命抽数概率分布图](http://img.070077.xyz/%E5%8E%9F%E7%A5%9E4%E6%98%9F0%E5%91%BD%E6%8A%BD%E6%95%B0%E6%A6%82%E7%8E%87%E5%88%86%E5%B8%83%E5%9B%BE.png)\n\n### 算法\n\n定义：$ dp[i][j][k] $ ：第j次祈愿的结果对应k，并第i次获得B角色的概率，则状态转移方程：\n\n- 保底状态：上次四星!UP，这次必获得UP角色\n- k = 0 ： 获得想要的四星角色B\n- k = 1 ： 获得UP四星角色但不是B\n- k = 2：获得非UP四星角色\n\n（临时变量：tmp：上次获得四星的祈愿次数）\n\n$$ dp[i][j][0] = dp[i-1][tmp][1] * PDF(j-tmp) * \\frac{1}{6} \\\\+ dp[i-1][tmp][0] * \\frac{1}{6} * PDF(j-tmp) \\\\+ dp[i-1][tmp][1] * PDF(j-tmp) * \\frac{1}{3}$$\n\n$$ dp[i][j][1] = dp[i][tmp][0] * \\frac{1}{3} * PDF(j-tmp) \\\\+ dp[i][tmp][1] * PDF(j-tmp) * \\frac{1}{3} \\\\+  dp[i][tmp][2] * \\frac{2}{3} * PDF(j-tmp)$$\n\n$$ dp[i][j][2] = dp[i][tmp][0] * \\frac{1}{2} * PDF(j-tmp) + dp[i][tmp][1] * \\frac{1}{2} * PDF(j-tmp)$$\n\n任意代码：（原理与下方“无定轨机制武器祈愿”类似，这里人比较懒，直接对p_5移花接木了）\n\n```python\n#每抽概率\n#这是研究四星的，但是为了偷懒，捏：\ndef p_5(n):\n    if n < 8:\n        return 0.051;\n    elif n < 9:\n        return 0.561;\n    else:\n        return 1;\n        \npdf_5 = [];\ncdf_5 = [];\ntmp = 0.0;\n\nfor i in range (0,10):\n    tmp = p_5(i);\n    for j in range(0,i):\n        tmp = tmp * (1 - p_5(j))\n    pdf_5.append(tmp);\n\nfor i in range (0,10):\n    tmp = 0.0;\n    for j in range (0,i+1):\n        tmp = tmp + pdf_5[j];\n    cdf_5.append(tmp);\n    print(i+1,cdf_5[i])\n \nn5_cnt=1#要抽出多少次B\nn5_tries=130 * n5_cnt;#准备的祈愿次数\ntmp = 0;\ndp_p = np.zeros((13, 150*n5_cnt + 20,3), dtype=float);\ndp_p[0][0][0] = 1\n# 0 - B 1 - UP & !B 2- !UP\nfor i in range (0,n5_cnt+1):\n        for j in range (0,n5_tries):\n            for k in range (1,11):\n                if(i-1>=0):\n                    dp_p[i][j+k][0] += dp_p[i-1][j][2] * pdf_5[k-1] * 1/3\\\n                                    + dp_p[i-1][j][1] * pdf_5[k-1] * 1/6 + dp_p[i-1][j][0] * 1/6 * pdf_5[k-1];\n                dp_p[i][j+k][1] += dp_p[i][j][0] * 1/3 * pdf_5[k-1] + dp_p[i][j][2] * 2/3 * pdf_5[k-1]\\\n                                + dp_p[i][j][1] * 1/3 * pdf_5[k-1];\n                dp_p[i][j+k][2] += dp_p[i][j][0] * 1/2 * pdf_5[k-1] + dp_p[i][j][1] * 1/2 * pdf_5[k-1];\nposs=[]\nfor i in range(0,n5_tries):\n    tmp = tmp + dp_p[n5_cnt][i][0]\n    poss.append(tmp)\nprint(tmp)\n#制图代码，直接cv用\nx_major_locator=MultipleLocator(10)#x分度值设置\ny_major_locator=MultipleLocator(0.1)\nax=plt.gca()\nax.xaxis.set_major_locator(x_major_locator)\nax.yaxis.set_major_locator(y_major_locator)\nx_values = [x for x in range(1, n5_tries)]\nplt.grid()  # 生成网格\nplt.plot(poss)  \n```\n\n\n\n## 不同模型对比研究\n\n### 与无保底机制（均匀1.6%）的对比\n\n​\t修改\n\n```\ndef p_5(n):\n\treturn 0.016;\n```\n\n期望：不变；\n\n分位点图：![均匀1.6原神抽卡概率分布图](http://img.070077.xyz/%E5%9D%87%E5%8C%801.6%E5%8E%9F%E7%A5%9E%E6%8A%BD%E5%8D%A1%E6%A6%82%E7%8E%87%E5%88%86%E5%B8%83%E5%9B%BE.png)\n\n极端情况上升了~\n\n两次五星分布图：![均匀1.6原神抽卡2次五星概率分布图](http://img.070077.xyz/%E5%9D%87%E5%8C%801.6%E5%8E%9F%E7%A5%9E%E6%8A%BD%E5%8D%A12%E6%AC%A1%E4%BA%94%E6%98%9F%E6%A6%82%E7%8E%87%E5%88%86%E5%B8%83%E5%9B%BE.png)\n\n\n\n一命概率分布图：![均匀1.6原神抽卡一命概率分布图](http://img.070077.xyz/%E5%9D%87%E5%8C%801.6%E5%8E%9F%E7%A5%9E%E6%8A%BD%E5%8D%A1%E4%B8%80%E5%91%BD%E6%A6%82%E7%8E%87%E5%88%86%E5%B8%83%E5%9B%BE.png)\n\n可以发现，均匀和非均匀，有利有弊吧。\n\n### 与保底前均匀机制（魔改尝试1）的对比\n\n用我比较熟悉的c++建模以下（其实更精确的值为0.88%）\n\n$$  P(x) = \\begin{cases} 0.9\\% &{x\\leqslant 89}\\\\1&{x = 90} \\end{cases} $$\n\n期望：62.06（综合概率：1.61%）\n\n分位点分布图：\n\n![魔改1.6原神抽卡概率分布图](http://img.070077.xyz/%E9%AD%94%E6%94%B91.6%E5%8E%9F%E7%A5%9E%E6%8A%BD%E5%8D%A1%E6%A6%82%E7%8E%87%E5%88%86%E5%B8%83%E5%9B%BE.png)\n\n两次五星分布图：![魔改1.6原神抽卡2次五星概率分布图](http://img.070077.xyz/%E9%AD%94%E6%94%B91.6%E5%8E%9F%E7%A5%9E%E6%8A%BD%E5%8D%A12%E6%AC%A1%E4%BA%94%E6%98%9F%E6%A6%82%E7%8E%87%E5%88%86%E5%B8%83%E5%9B%BE.png)\n\n一命概率分布图：![魔改1.6原神抽卡一命概率分布图](http://img.070077.xyz/%E9%AD%94%E6%94%B91.6%E5%8E%9F%E7%A5%9E%E6%8A%BD%E5%8D%A1%E4%B8%80%E5%91%BD%E6%A6%82%E7%8E%87%E5%88%86%E5%B8%83%E5%9B%BE.png)\n\n会让更多人吃保底~\n\n# 武器祈愿分析\n\n## 概率递增保底机制及数字特征\n\n武器祈愿的机制和角色祈愿大体一致。算法参上，在此直接给出结论。\n\n五星武器概率：\n\n$$P(x) = \\begin{cases}0.7\\% & x\\leqslant62\\\\0.7\\%+7\\%(x-62) & 63\\leqslant x \\leqslant 71\\\\ 63.7\\% + 3.5\\%(x-71) & 72\\leqslant x \\leqslant 79 \\\\ 1 & x=80\\end{cases}$$ \n\n数学期望：54.25.\n\n综合概率：1.88%\n\n分布图：![原神武器抽卡概率分布图](http://img.070077.xyz/%E5%8E%9F%E7%A5%9E%E6%AD%A6%E5%99%A8%E6%8A%BD%E5%8D%A1%E6%A6%82%E7%8E%87%E5%88%86%E5%B8%83%E5%9B%BE.png)\n\n\n\n四星武器概率\n\n$$P(x) = \\begin{cases}6\\% & x\\leqslant 7\\\\66\\% & x = 8 \\\\ 96\\% & x = 9 \\\\ 1 & x=10\\end{cases}$$\n\n数学期望：6.74.\n\n综合概率：14.84%。\n\n你会发现，分成了四段，复杂了一点。\n\n```python\n#每抽概率\ndef p_5(n):\n    if n < 62:\n        return 0.007;\n    elif n < 71:\n        return 0.007 + (n - 62) * 0.07;\n    elif n < 79:\n        return 0.637 + (n - 71) * 0.035;\n    else:\n        return 1.0;\ndef p_4(n):\n    if n < 7:\n        return 0.06\n    elif n < 8:\n        return 0.66\n    elif n < 9:\n        return 0.96;\n    else:\n        return 1;\npdf_5 = [];#第x+1抽出概率\ncdf_5 = [];\ntmp = 0.0;\n\nfor i in range (0,80):\n    tmp = p_5(i);\n    for j in range(0,i):\n        tmp = tmp * (1.0 - p_5(j))\n    pdf_5.append(tmp);\n\nfor i in range (0,80):\n    tmp = 0.0;\n    for j in range (0,i+1):\n        tmp = tmp + pdf_5[j];\n    cdf_5.append(tmp);\n    print(i+1,cdf_5[i])\n```\n\n\n\n## 定轨机制下的资源规划（假设定轨M）\n\n### 获取五星武器M的祈愿次数分析\n\n由于命定值机制，马尔可夫过程比较复杂。于是考虑动态规划：\n\n定义$dp[i][j][k]$为第j次祈愿时第i次获得五星武器M，祈愿后k：\n\n- k = 0 : 命定值为0。表示抽到了M.\n- k = 1：命定值为1且抽到了N.\n- k = 2：命定值为1且抽到的是非UP武器。\n- k = 3：命定值为2，抽出来的不是M，具体是啥在本小节中不相关。\n\n$$ dp[i][j][0] = dp[i-1][tmp][0] * \\frac{3}{8} *PDF(j-tmp) \\\\+ dp[i-1][tmp][1] * \\frac{3}{8} * PDF(j-tmp) \\\\+ dp[i-1][tmp][2] * \\frac{1}{2}*PDF(j-tmp) \\\\+ dp[i-1][tmp][3] *PDF(j-tmp)$$\n\n$$ dp[i][j][1] = dp[i][tmp][0] *\\frac{1}{4}* PDF(j-tmp)$$\n\n$$ dp[i][j][2] = dp[i][tmp][0] *\\frac{3}{8}* PDF(j-tmp)$$\n\n$$ dp[i][j][3] = dp[i][tmp][1] * ( \\frac{3}{8} + \\frac{1}{4}) *PDF(j-tmp) \\\\ + dp[i][tmp][2] * \\frac{1}{2} * PDF(j-tmp)$$\n\n运行代码：\n\n```python\nn5_cnt=2;#要抽出多少次M\nn5_tries= 207;#准备的祈愿次数\ntmp = 0;\ndp_p = np.zeros((13, 330*n5_cnt,5), dtype=float);\ndp_p[0][0][0] = 1\nfor i in range (0,n5_cnt+1):\n        for j in range (0,n5_tries + n5_cnt + 1):\n            for k in range (1,81):\n                if(i-1>=0):\n                    dp_p[i][j+k][0] += dp_p[i-1][j][0] * pdf_5[k-1] * 0.375\\\n                                + dp_p[i-1][j][1] * 0.375 * pdf_5[k-1] \\\n                                + dp_p[i-1][j][2] * 0.5 * pdf_5[k-1]\\\n                                + dp_p[i-1][j][3] * pdf_5[k-1];\n                dp_p[i][j+k][1] += dp_p[i][j][0] * 0.25 * pdf_5[k-1];\n                dp_p[i][j+k][2] += dp_p[i][j][0] * 0.375 * pdf_5[k-1];\n                dp_p[i][j+k][3] += dp_p[i][j][1] * 0.625 * pdf_5[k-1]\\\n                                + dp_p[i][j][2] * 0.5 * pdf_5[k-1];\nposs=[]\nfor i in range(0,n5_tries):\n    tmp = tmp + dp_p[n5_cnt][i][0]\n    poss.append(tmp)\nprint(tmp)\nplt.plot(poss)\n#0.49317051582855165\n```\n\n进行99次祈愿后，获得M的概率达到50%。以下是获取一次武器M的概率分布图：\n\n![原神武器m抽卡概率分布图](http://img.070077.xyz/%E5%8E%9F%E7%A5%9E%E6%AD%A6%E5%99%A8m%E6%8A%BD%E5%8D%A1%E6%A6%82%E7%8E%87%E5%88%86%E5%B8%83%E5%9B%BE.png)\n\n### 获取五星武器N的祈愿次数分析\n\n问题：我定轨了M，反而想获取五星武器N…（反向定轨）\n\n定义$dp[i][j][k]$为第j次祈愿时第i次获得五星武器N，祈愿后k：\n\n- k = 0 : 命定值为0。表示抽到了M.\n- k = 1：命定值为1且抽到了N.\n- k = 2：命定值为1且抽到的是非UP武器。\n- k = 3：命定值为2，且抽到了N.\n- k = 4：命定值为2，且抽到的是非UP武器。\n\n$$ dp[i][j][0] = dp[i][tmp][0] * \\frac{3}{8} *PDF(j-tmp) \\\\ + dp[i][tmp][1] * \\frac{3}{8} * PDF(j-tmp) \\\\+ dp[i][tmp][2] * \\frac{1}{2}*PDF(j-tmp) \\\\+ dp[i][tmp][3] * PDF(j-tmp) \\\\ + dp[i][tmp][4] * PDF(j-tmp)$$\n\n$$ dp[i][j][1] = dp[i-1][tmp][0] *\\frac{3}{8}* PDF(j-tmp)$$\n\n$$ dp[i][j][2] = dp[i][tmp][0] *\\frac{1}{4}* PDF(j-tmp)$$\n\n$$ dp[i][j][3] = dp[i-1][tmp][1] * ( \\frac{3}{8}) * PDF(j-tmp) \\\\ + dp[i-1][tmp][2] * \\frac{1}{2} * PDF(j-tmp)$$\n\n$$ dp[i][j][4] = dp[i][tmp][1] * \\frac{1}{4} * PDF(j-tmp)$$\n\n```python\nn5_cnt=1;#要抽出多少次N\nn5_tries= 106;#准备的祈愿次数\ntmp = 0;\ndp_p = np.zeros((13, 510*n5_cnt + 80,5), dtype=float);\ndp_p[0][0][0] = 1\nfor i in range (0,n5_cnt+1):\n        for j in range (0,n5_tries + n5_cnt + 1):\n            for k in range (1,81):\n                dp_p[i][j+k][0] += dp_p[i][j][0] * pdf_5[k-1] * 0.375\\\n                                + dp_p[i][j][1] * 0.375 * pdf_5[k-1] \\\n                                + dp_p[i][j][2] * 0.5 * pdf_5[k-1]\\\n                                + dp_p[i][j][3] * pdf_5[k-1]\\\n                                + dp_p[i][j][4] * pdf_5[k-1];\n                dp_p[i][j+k][1] += dp_p[i-1][j][0] * 0.375 * pdf_5[k-1];\n                dp_p[i][j+k][2] += dp_p[i][j][0] * 0.25 * pdf_5[k-1];\n                dp_p[i][j+k][3] += dp_p[i-1][j][1] * 0.375 * pdf_5[k-1]\\\n                                + dp_p[i-1][j][2] * 0.5 * pdf_5[k-1];\n                dp_p[i][j+k][4] += dp_p[i][j][1] * 0.25 * pdf_5[k-1]\nposs=[]\nfor i in range(0,n5_tries):\n    tmp = tmp + dp_p[n5_cnt][i][1] + dp_p[n5_cnt][i][3]\n    poss.append(tmp)\nprint(tmp)\n#DEMO:0.5007747697175682\n```\n\n图表\n\n​    ![原神武器n抽卡概率分布图](http://img.070077.xyz/%E5%8E%9F%E7%A5%9E%E6%AD%A6%E5%99%A8n%E6%8A%BD%E5%8D%A1%E6%A6%82%E7%8E%87%E5%88%86%E5%B8%83%E5%9B%BE.png)\n\n### 获取五星武器M、N的祈愿次数分析（To Be Updated…)\n\n问题：我定轨了M，但M、N都想要。\n\n我可能比较蠢：四维动态规划？\n\n定义$dp[h][i][j][k]$为第j次祈愿时第i次获得五星武器N，第h获得五星武器M，祈愿后k：……（同上）\n\n呃，我们先不考虑土豪了哈，我们只考虑都只获得1次的情况，只需要把`tmp = tmp + dp_p[n5_cnt][i][1] + dp_p[n5_cnt][i][3]` 再加一项 `dp_p[n5_cnt][i][0]` ？\n\n我也希望这能成功，但是这么直接地不可行，因为前面那两项的概率本身就包含了上一次抽到M的情况，再加会导致重复计算，我没想到别的方式改良之。\n\n另一种思路是分类讨论了，分为先获得M后获得N、先获得N再获得M两种情况。\n\n再者就是还是含泪：\n\n- 需要做出一定的修改，使状态转移时，不忽略h的出现次数。\n\n$$ dp[h][i][j][0] = dp[h-1][i][tmp][0] * \\frac{3}{8} *PDF(j-tmp) \\\\ + dp[h-1][i][tmp][1] * \\frac{3}{8} * PDF(j-tmp) \\\\+ dp[h-1][i][tmp][2] * \\frac{1}{2}*PDF(j-tmp) \\\\+ dp[h-1][i][tmp][3] * PDF(j-tmp) \\\\ + dp[h-1][i][tmp][4] * PDF(j-tmp)$$\n\n$$ dp[h][i][j][1] = dp[h][i-1][tmp][0] *\\frac{3}{8}* PDF(j-tmp)$$\n\n$$ dp[h][i][j][2] = dp[h][i][tmp][0] *\\frac{1}{4}* PDF(j-tmp)$$\n\n$$ dp[h][i][j][3] = dp[h][i-1][tmp][1] * ( \\frac{3}{8}) * PDF(j-tmp) \\\\ + dp[h][i-1][tmp][2] * \\frac{1}{2} * PDF(j-tmp)$$\n\n$$ dp[h][i][j][4] = dp[h][i][tmp][1] * \\frac{1}{4} * PDF(j-tmp)$$\n\n事实证明上面的方法不一定获得了正确答案。这个错误是没有价值的吗，不，他可能会给一个同样想研究这一问题的人一个参考。于是提出下面的形式：\n\n定义$dp[i][j][k]$为第j次祈愿时，i - 获得的目标种类数 , 祈愿后k同上。\n\n其实关键原因和上面的“加一项”一样，就是因为最后获取概率时，需要涵盖多个状态。以前的动态规划获取概率时，获取的状态间互相不存在依赖，而这次获取概率时，各个状态内部的转移存在相关。\n\n最近灵感较为枯竭，先赶别的ddl了。在此附上可能是错误的代码（若考虑较大次数，可能需修改码参数/概率不准确）和运行结果：\n\n```python\nn5_cnt_M=1;#要抽出多少次M,N\nn5_cnt_N=1;\nn5_cnt=n5_cnt_M + n5_cnt_N;\nn5_tries= 180*n5_cnt;#准备的祈愿次数\ntmp = 0;\ndp_p = np.zeros((13,13, 310*n5_cnt + 80,5), dtype=float);\ndp_p[0][0][0][0] = 1\n\nh = 0;\nfor h in range (0,3*n5_cnt_M +1):\n    for i in range(0,3*n5_cnt_N+1):\n        for j in range (0,n5_tries + n5_cnt + 1):\n            for k in range (1,81):\n                    dp_p[h][i][j+k][0] += dp_p[h-1][i][j][0] * pdf_5[k-1] * 0.375\\\n                                + dp_p[h-1][i][j][1] * 0.375 * pdf_5[k-1] \\\n                                + dp_p[h-1][i][j][2] * 0.5 * pdf_5[k-1]\\\n                                + dp_p[h-1][i][j][3] * pdf_5[k-1]\\\n                                + dp_p[h-1][i][j][4] * pdf_5[k-1];\n                    dp_p[h][i][j+k][1] += dp_p[h][i-1][j][0] * 0.375 * pdf_5[k-1];\n                    dp_p[h][i][j+k][2] += dp_p[h][i][j][0] * 0.25 * pdf_5[k-1];\n                    dp_p[h][i][j+k][3] += dp_p[h][i-1][j][1] * 0.375 * pdf_5[k-1]\\\n                                + dp_p[h][i-1][j][2] * 0.5 * pdf_5[k-1];\n                    dp_p[h][i][j+k][4] += dp_p[h][i][j][1] * 0.25 * pdf_5[k-1]\n\nposs=[]\nfor i in range(0,n5_tries):\n    for i1 in range (n5_cnt_M,3*n5_cnt_M+1):\n        tmp += dp_p[i1][n5_cnt_N][i][1] + dp_p[i1][n5_cnt_N][i][3]\n    for i2 in range(n5_cnt_N,3*n5_cnt_N+1):\n        tmp += dp_p[n5_cnt_M][i2][i][0];\n    poss.append(tmp)\nprint(tmp)\n#制图代码，直接cv用\nx_major_locator=MultipleLocator(20)#x分度值设置\ny_major_locator=MultipleLocator(0.1)\nax=plt.gca()\nax.xaxis.set_major_locator(x_major_locator)\nax.yaxis.set_major_locator(y_major_locator)\nplt.grid()  # 生成网格\nplt.plot(poss)\n```\n\n![原神武器m且n抽卡概率分布图](http://img.070077.xyz/%E5%8E%9F%E7%A5%9E%E6%AD%A6%E5%99%A8m%E4%B8%94n%E6%8A%BD%E5%8D%A1%E6%A6%82%E7%8E%87%E5%88%86%E5%B8%83%E5%9B%BE.png)\n\n拓展问题：我先定轨了M，获取M后定轨N（命定值清零），参考上面两个问题叠加应该可以。\n\n### 四星武器的分析\n\n和上面四星角色祈愿分析思想一致。\n\n```python\n#偷懒：p_5的内容实际是p_4\nn5_cnt=1#要抽出多少次F\nn5_tries=130 * n5_cnt;#准备的祈愿次数\ntmp = 0;\ndp_p = np.zeros((13, 150*n5_cnt + 20,3), dtype=float);\ndp_p[0][0][0] = 1\n# 0 - F 1 - UP & !F 2- !UP\nfor i in range (0,n5_cnt+1):\n        for j in range (0,n5_tries):\n            for k in range (1,11):\n                if(i-1>=0):\n                    dp_p[i][j+k][0] += dp_p[i-1][j][2] * pdf_5[k-1] * 1/5\\\n                                    + dp_p[i-1][j][1] * pdf_5[k-1] * 3/20 + dp_p[i-1][j][0] * 3/20 * pdf_5[k-1];\n                dp_p[i][j+k][1] += dp_p[i][j][0] * 3/5 * pdf_5[k-1] + dp_p[i][j][2] * 4/5 * pdf_5[k-1]\\\n                                + dp_p[i][j][1] * 3/5 * pdf_5[k-1];\n                dp_p[i][j+k][2] += dp_p[i][j][0] * 1/4 * pdf_5[k-1] + dp_p[i][j][1] * 1/4 * pdf_5[k-1];\nposs=[]\nfor i in range(0,n5_tries):\n    tmp = tmp + dp_p[n5_cnt][i][0]\n    poss.append(tmp)\nprint(tmp)\n#制图代码，直接cv用\nx_major_locator=MultipleLocator(10)#x分度值设置\ny_major_locator=MultipleLocator(0.1)\nax=plt.gca()\nax.xaxis.set_major_locator(x_major_locator)\nax.yaxis.set_major_locator(y_major_locator)\nx_values = [x for x in range(1, n5_tries)]\nplt.grid()  # 生成网格\nplt.plot(poss)  \n```\n\n![原神四星武器f抽卡概率分布图](http://img.070077.xyz/%E5%8E%9F%E7%A5%9E%E5%9B%9B%E6%98%9F%E6%AD%A6%E5%99%A8f%E6%8A%BD%E5%8D%A1%E6%A6%82%E7%8E%87%E5%88%86%E5%B8%83%E5%9B%BE.png)\n\n## 无定轨机制下武器祈愿分析\n\n和上面四星角色祈愿分析思想一致。![原神武器m不定轨抽卡概率分布图](http://img.070077.xyz/%E5%8E%9F%E7%A5%9E%E6%AD%A6%E5%99%A8m%E4%B8%8D%E5%AE%9A%E8%BD%A8%E6%8A%BD%E5%8D%A1%E6%A6%82%E7%8E%87%E5%88%86%E5%B8%83%E5%9B%BE.png)\n\n```python\n#这次下面是真的武器池概率分布p_5了哈\nn5_cnt=1#要抽出多少次M\nn5_tries=240 * n5_cnt;#准备的祈愿次数\ntmp = 0;\ndp_p = np.zeros((13, 320*n5_cnt + 20,3), dtype=float);\ndp_p[0][0][0] = 1\n# 0 - M 1 - UP & !M 2- !UP\nfor i in range (0,n5_cnt+1):\n        for j in range (0,n5_tries):\n            for k in range (1,81):\n                if(i-1>=0):\n                    dp_p[i][j+k][0] += dp_p[i-1][j][2] * pdf_5[k-1] * 1/2 \\\n                                    + dp_p[i-1][j][1] * pdf_5[k-1] * 3/8 + dp_p[i-1][j][0] * 3/8 * pdf_5[k-1];\n                dp_p[i][j+k][1] += dp_p[i][j][0] * 3/8 * pdf_5[k-1] + dp_p[i][j][2] * 1/2 * pdf_5[k-1]\\\n                                + dp_p[i][j][1] * 3/8 * pdf_5[k-1];\n                dp_p[i][j+k][2] += dp_p[i][j][0] * 1/4 * pdf_5[k-1] + dp_p[i][j][1] * 1/4 * pdf_5[k-1];\nposs=[]\nfor i in range(0,n5_tries):\n    tmp = tmp + dp_p[n5_cnt][i][0]\n    poss.append(tmp)\nprint(tmp)\n#制图代码，直接cv用\nx_major_locator=MultipleLocator(15)#x分度值设置\ny_major_locator=MultipleLocator(0.1)\nax=plt.gca()\nax.xaxis.set_major_locator(x_major_locator)\nax.yaxis.set_major_locator(y_major_locator)\nx_values = [x for x in range(1, n5_tries)]\nplt.grid()  # 生成网格\nplt.plot(poss)  \n```\n\n你如果和上面定轨时比较，会发现你想要M的话，需要投入稍微更多的抽数。而且可以看见，当投入200抽时，定轨机制下的获取M的概率已经逐步收敛至1。而不定轨机制下，获取到的概率的概率仅在80%附近，且之后收敛较慢，极端情况的发生概率并不低。\n\n有关不定轨又同时想要M和N的，TBC…\n\n# 总结\n\n概率分析还可以分析：如何配置属性让伤害最大化等问题。概率论作为一种打破人的直觉的东西，实在是让人又爱又恨。本文不仅仅局限于传统的期望范畴，结合具体概率的分布分析了对应的抽数需求。由于祈愿机制的概率不是恒定的，期望与中分位点存在区别，可以用平均GDP和中位数来感受。\n\n致谢：感谢张老师的帮助和OneBST的分享。\n\n【To Be Continued】\n\n- 同时研究多个四星的祈愿次数\n\n- 常驻祈愿结合“联动规则”的分析\n\n- 常驻祈愿与UP祈愿结合分析\n\n- 蒙特卡罗模拟与大数定律\n\n- 通过置信度研究极端情况\n\n\n\n\n\n","slug":"概率论论文","published":1,"date":"2022-02-03T12:49:05.194Z","updated":"2022-02-03T10:54:47.829Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"ckz6z6e0x000lfovvhzfthq93","content":"<p>#《原神》祈愿机制概率研究</p>\n<p>【摘要】本文以概率论、随机过程理论等工具研究游戏《原神》中的祈愿机制，主要基于动态规划，以“期望”和“概率的概率”两大分析方向进行数据处理，并根据分析结果总结了一些方便玩家规划金钱与资源的建议。由于追求多次获得五星道具的玩家基本“不差钱”，本文附有获取少量五星情况下的数据可视化。</p>\n<p>[TOC]</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>Version:20220105</p>\n<ul>\n<li>修了讲一遍时找到的笔误</li>\n</ul></blockquote>\n<h2 id=\"规则表述\"><a href=\"#规则表述\" class=\"headerlink\" title=\"规则表述\"></a>规则表述</h2><p>旅行者（玩家）可以通过祈愿机制获取“五星角色”“五星武器“”四星角色“”四星武器“来提高战斗力。其中，角色具有命之座机制，首次获得为0命，最高6命，命座数越高，角色越强；类似地，武器拥有精炼层数机制，首次获得为1阶，最高5阶。</p>\n<p>最近的版本更新中，《原神》的祈愿机制也发生了一定的变化。</p>\n<p>以下是《原神》两个祈愿机制的官方描述（<a href=\"https://ys.mihoyo.com/main/news/public%EF%BC%89%EF%BC%9A\">https://ys.mihoyo.com/main/news/public）：</a></p>\n<h3 id=\"角色祈愿\"><a href=\"#角色祈愿\" class=\"headerlink\" title=\"角色祈愿\"></a>角色祈愿</h3><p>**五星角色祈愿的基础概率为0.600%，综合概率（含保底）为1.600%**，最多90次祈愿必定能通过保底获取5星角色。</p>\n<p>当祈愿获取到5星角色时，有50.000%的概率为本期5星UP角色「A1」<em>（小保底）</em>。如果本次祈愿获取的5星角色非本期5星UP角色，下次祈愿获取的5星角色必定为本期5星UP角色<em>（大保底）</em>。</p>\n<p><strong>4星物品祈愿的基础概率为5.100%，4星角色祈愿的基础概率为2.550%，4星武器祈愿的基础概率为2.550%，4星物品祈愿的综合概率（含保底）为13.000%。</strong>最多10次祈愿必定能通过保底获取4星或以上物品，通过保底获取4星物品的概率为99.400%，获取5星物品的概率为0.600%。</p>\n<p>当祈愿获取到4星物品时，有50.000%的概率为本期4星UP角色「B」、「C」、「D」中的一个。如果本次祈愿获取的4星物品非本期4星UP角色，下次祈愿获取的4星物品必定为本期4星UP角色。当祈愿获取到4星UP物品时，每个本期4星UP角色的获取概率均等。</p>\n<p>角色祈愿包括「角色活动祈愿-1」和「角色活动祈愿-2」，祈愿次数和保底完全共享，共同累计。二者区别仅在于当期UP的五星角色不同。</p>\n<h3 id=\"武器祈愿\"><a href=\"#武器祈愿\" class=\"headerlink\" title=\"武器祈愿\"></a>武器祈愿</h3><p><strong>武器祈愿中，5星武器祈愿的基础概率为0.700%，综合概率（含保底）为1.850%，</strong>最多80次祈愿必定能通过保底获取5星武器。</p>\n<p>当祈愿获取到5星武器时，有75.000%的概率为本期5星UP武器「M」、「N」中的一个。如果本次祈愿获取的5星武器非本期5星UP武器，下次祈愿获取的5星武器必定为本期5星UP武器。</p>\n<p>【定轨机制】命定值：玩家可以指定一把本期5星UP武器（定轨）。当获取到的5星武器为非当前定轨武器时，获得1点命定值，命定值达到满值2后，在本祈愿中获得的下一把5星武器必定为当前定轨武器。获取到当前定轨武器时，无论当前命定值是否达到满值，都将会重置为0，重新累计。在未通过命定值达到满值获取定轨武器的情况下，当祈愿获取到5星UP物品时，每把本期5星UP武器的获取概率均等。</p>\n<p>未使用「神铸定轨」定轨武器时，将不会累积命定值。</p>\n<p><strong>4星物品祈愿的基础概率为6.000%，4星角色祈愿的基础概率为3.000%，4星武器祈愿的基础概率为3.000%，4星物品祈愿的综合概率（含保底）为14.500%。</strong>最多10次祈愿必定能通过保底获取4星或以上物品，通过保底获取4星物品的概率为99.300%，获取5星物品的概率为0.700%。</p>\n<p>当祈愿获取到4星物品时，有75.000%的概率为本期4星UP武器「F」、「G」、「H」、「J」、「K」中的一个。如果本次祈愿获取的4星物品非本期4星UP武器，下次祈愿获取的4星物品必定为本期4星UP武器。当祈愿获取到4星UP物品时，每把本期4星UP武器的获取概率均等。</p>\n<h1 id=\"角色祈愿分析\"><a href=\"#角色祈愿分析\" class=\"headerlink\" title=\"角色祈愿分析\"></a>角色祈愿分析</h1><h2 id=\"五星角色概率建模\"><a href=\"#五星角色概率建模\" class=\"headerlink\" title=\"五星角色概率建模\"></a>五星角色概率建模</h2><p>   前面的作业中，笔者通过运行代码和期望分析，对角色祈愿的机制进行了尝试1的模拟，简单回顾如下：</p>\n<h3 id=\"尝试1：89次伯努利实验\"><a href=\"#尝试1：89次伯努利实验\" class=\"headerlink\" title=\"尝试1：89次伯努利实验\"></a>尝试1：89次伯努利实验</h3><p>建模1：前89次祈愿，每次获得五星角色的概率均为0.6%，若前89次实验没有获得五星角色，则获取五星角色的概率为100%。</p>\n<p>则可以建模二项分布概率密度：</p>\n<p>$$ PDF(X = k) = (1-p)^{k-1}p(p = 0.6 %)$$</p>\n<p>$$ CDF(X = k) = (1 - p)^k$$</p>\n<p>计算每次获取五星角色的祈愿数期望：</p>\n<p>$$ E(X) = 90(1-CDF(89)) + \\sum_{i=1}^{89}iPDF(x=i)$$</p>\n<p>得到综合概率：</p>\n<p>$$P = \\frac{1}{E(X)} $$</p>\n<p>结果为：1.435%。（详见week9作业）</p>\n<p>与官方描述不符。实际上，官方提到的0.6%是基础概率，说明不是恒定概率的伯努利实验，于是提出模型2.</p>\n<h3 id=\"尝试2：概率递增的保底机制\"><a href=\"#尝试2：概率递增的保底机制\" class=\"headerlink\" title=\"尝试2：概率递增的保底机制\"></a>尝试2：概率递增的保底机制</h3><p>建模2：在一定抽数都没有得到五星角色后，获得五星角色概率开始线性上升，直到第90抽达到100%。 </p>\n<p>由于具体概率密度没有官方文档，只能站在前人的分析上，根据结合数据统计的开源项目（<a href=\"https://github.com/OneBST/GGanalysis%EF%BC%8C%E6%9C%AC%E6%96%87%E5%AE%9E%E9%99%85%E4%B8%8A%E7%9B%B8%E5%BD%93%E4%BA%8E%E6%A8%A1%E5%9E%8B%E7%9A%84%E5%A4%8D%E7%8E%B0%EF%BC%89%E9%87%87%E7%94%A8%E7%9A%84%E6%A8%A1%E5%9E%8B%EF%BC%8C%E7%AC%ACx%E6%AC%A1%E7%A5%88%E6%84%BF%E8%8E%B7%E5%BE%97%E4%BA%94%E6%98%9F%E8%A7%92%E8%89%B2%E7%9A%84%E6%A6%82%E7%8E%87%E5%A6%82%E4%B8%8B%EF%BC%9A\">https://github.com/OneBST/GGanalysis，本文实际上相当于模型的复现）采用的模型，第x次祈愿获得五星角色的概率如下：</a></p>\n<p>$$ P(x) = \\begin{cases} 0.6% &amp;{x&lt;=73}\\ 0.6% + 6%(x - 73) &amp;{74&lt;=x&lt;=89}\\1&amp;{x = 90} \\end{cases}$$</p>\n<p>由此，可以得到第x次祈愿得到五星角色的分布列（类似于几何分布）：</p>\n<p>$$ PDF(x) = P(x) * \\prod_{k = 1}^{x - 1}1-P(x) $$</p>\n<p>$$ PDF(x) = \\begin{cases} (1 - 0.6%)^{x-1}\\times0.6% &amp;{x\\leqslant73}\\ (1-0.6%)^{73} \\times \\sum_{k = 74}^{x} (1- 6%(k - 73))^{k-73}(6%(k-73)) &amp;{74\\leqslant x\\leqslant89}\\(1-0.6%)^{73} \\times \\sum_{k = 74}^{89} (1- 6%(k - 73))^{k-73}&amp;{x = 90} \\end{cases} $$</p>\n<p><strong>该模型平均获取五星角色的祈愿次数为62.3。</strong>该模型下五星角色的综合概率为1.605%。</p>\n<p>注：期望计算公式：</p>\n<p>$$ E(X) = \\sum_{i=1}^{x}PDF(x)\\times x $$</p>\n<h2 id=\"概率递增保底机制下的数字特征\"><a href=\"#概率递增保底机制下的数字特征\" class=\"headerlink\" title=\"概率递增保底机制下的数字特征\"></a>概率递增保底机制下的数字特征</h2><h3 id=\"求数据特征\"><a href=\"#求数据特征\" class=\"headerlink\" title=\"求数据特征\"></a>求数据特征</h3><p>在这里处理一个认识误区：期望 != 概率为50%的点（中分位点）。</p>\n<p>也就是说，期望作为概率的平均值，$ CDF(EX) = 0.5 $ <strong>是不成立的</strong>。 注意到这一前提，才能比较正确地理解下面的结论。</p>\n<p>由于其概率密度并不是均匀分布的，差别较大，选择平均数似乎不太合适。所以我们获取中分位点。根本不应该是程序员能写出来的粗糙代码验证：</p>\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">import numpy as np\nimport matplotlib as mlp\nimport matplotlib.pyplot as plt\nfrom matplotlib.pyplot import MultipleLocator\ndef p_5(n):\n    if n &lt; 73:\n        return 0.006\n    elif n &lt; 89:\n        return 0.006 + (n - 72) * 0.06\n    else:\n        return 1\n    \npdf_5 &#x3D; [];\ncdf_5 &#x3D; [];\ntmp &#x3D; 0.0;\n\nfor i in range (0,90):\n    tmp &#x3D; p_5(i);\n    for j in range(0,i):\n        tmp &#x3D; tmp * (1 - p_5(j))\n    pdf_5.append(tmp);\n#注：下文中其他代码可能要用到p_5,p_4函数,pdf_5列表哦\n\nfor i in range (0,90):\n    tmp &#x3D; 0.0;\n    for j in range (0,i+1):\n        tmp &#x3D; tmp + pdf_5[j];\n    cdf_5.append(tmp);\n    print(i+1,cdf_5[i])\n# out:\n#75 0.4739047630777248\n#76 0.571758477145268</code></pre>\n\n<p>该模型的概率密度函数（蓝线）和分布函数（黄线）图：</p>\n<p><img src=\"http://img.070077.xyz/%E5%8E%9F%E7%A5%9E%E6%8A%BD%E5%8D%A1%E6%A6%82%E7%8E%87%E5%88%86%E5%B8%83%E5%9B%BE.png\" alt=\"img\"></p>\n<p>我们不妨乐观一点，中分位点：75.</p>\n<p>注：最概然祈愿次数为77。也就是说，在第77次祈愿获取五星角色的概率最高。</p>\n<p>每次获得五星角色，需要的祈愿次数记为$N$. 则：</p>\n<ul>\n<li>从期望角度考虑，N = 62.3.</li>\n<li>从中分位点角度考虑，N = 75.</li>\n</ul>\n<p>实际理解为：需要75次祈愿，才能使获得5星角色的发生概率达到50%（实际：46.8%）。</p>\n<p>这种分布具有较强的右偏性。上面分析过，这两个数字特征具有不同的分析意义，可以理解为：</p>\n<ul>\n<li>祈愿623次，期望获得10个五星角色。（期望值）</li>\n<li>祈愿75次，能使获得五星角色的概率达到50%。</li>\n</ul>\n<h3 id=\"由期望特征进行资源规划\"><a href=\"#由期望特征进行资源规划\" class=\"headerlink\" title=\"由期望特征进行资源规划\"></a>由期望特征进行资源规划</h3><p>回到规则中，解决以下问题：</p>\n<h4 id=\"获得五星角色A的期望次数分析\"><a href=\"#获得五星角色A的期望次数分析\" class=\"headerlink\" title=\"获得五星角色A的期望次数分析\"></a>获得五星角色A的期望次数分析</h4><p>对于期望分析：注意到，对于获取当期UP五星角色，最多需要2次获得五星角色。也就是说，有50%的概率，仅需要获取一次五星角色；有50%的概率，需要获取2次五星角色。也就是说，需要获得五星角色的次数：</p>\n<p>$$ 1 \\times 50% + 2 \\times 50%  = 1.5 $$</p>\n<p>对于“获取五星角色”而言，多次获取（不论是否为当期UP角色）之间互相独立，因此需要的祈愿次数为$1.5 \\times 62.3 = 93.45$ 次。</p>\n<h4 id=\"获得6命座A角色的期望次数分析\"><a href=\"#获得6命座A角色的期望次数分析\" class=\"headerlink\" title=\"获得6命座A角色的期望次数分析\"></a>获得6命座A角色的期望次数分析</h4><p>注意到，对于“获取五星角色”而言，多次获取（不论是否为当期UP角色）之间互相独立。考虑这个问题：对于“获取A角色”事件之间，是相互独立的吗？</p>\n<p>从期望角度考虑，可以说：是的。参考上面的思路，只需要“获取A角色”发生7次即可。因此需要的祈愿次数为 $1.5N \\times 7 = 10.5N$ 也就是 654.15 次。</p>\n<h4 id=\"获得四星角色B的期望次数分析\"><a href=\"#获得四星角色B的期望次数分析\" class=\"headerlink\" title=\"获得四星角色B的期望次数分析\"></a>获得四星角色B的期望次数分析</h4><p>由于涉及“基础概率”，我们沿用上一开源项目模型的概率递增保底机制结论：</p>\n<ul>\n<li><p>从第9次祈愿处开始上升。</p>\n</li>\n<li><p>获得五星角色并不会重置四星保底。</p>\n</li>\n</ul>\n<p>第x次祈愿获得四星角色的概率如下：</p>\n<p>$$ P(x) = \\begin{cases} 5.1% &amp; {x\\leqslant8}\\ 56.1% &amp;{x = 9}\\1&amp;{x = 10} \\end{cases}$$</p>\n<p>$$ PDF(x) = P(x) * \\prod_{k = 1}^{x - 1}1-P(x)  = \\begin{cases} (1 - 5.1%)^{x-1}\\times5.1% &amp; {x\\leqslant8}\\ (1-5.1%)^8\\times56.1% &amp;{x=9}\\(1-5.1%)^8\\times43.9%&amp;{x = 10} \\end{cases}$$ </p>\n<p>期望值：</p>\n<p>$$ E(X) = \\sum_{i=1}^{x}PDF(x)\\times x = 7.66$$ </p>\n<p>综合概率：13.05%.</p>\n<p>对于期望分析：注意到，对于获取当期UP五星角色，仅有$\\frac{1}{3}$的概率得到当期UP的四星角色中的B，且每次获得当期四星角色时，有50%的概率，仅需要获取一次四星角色；有50%的概率，需要获取2次四星角色。也就是说，获得角色B的次数期望为$1.5 \\times 3 \\times E(X) = 34.5$ 。</p>\n<h3 id=\"由分位点特征进行分析\"><a href=\"#由分位点特征进行分析\" class=\"headerlink\" title=\"由分位点特征进行分析\"></a>由分位点特征进行分析</h3><p>从“概率的概率”角度分析便没有期望分析那么简单了。中位点与期望的乘积并不能得到叠加事件的中位点。基本上大部分分而治之的想法均不满足独立性要求。我们需要寻找更一般的数学模型：</p>\n<h4 id=\"获得多次五星角色的分位点分析\"><a href=\"#获得多次五星角色的分位点分析\" class=\"headerlink\" title=\"获得多次五星角色的分位点分析\"></a>获得多次五星角色的分位点分析</h4><p>接下来，由于<strong>使获得两次五星角色的概率达到50%的祈愿次数不等于获得一次五星角色祈愿次数的中位点的2倍</strong>，我们需要计算分布的<strong>叠加</strong>。</p>\n<p>我们从简单问题入手（自己编的）：</p>\n<p>(1) 一直抛硬币，直到总共出现2次正面朝上，求期望的抛硬币次数——显然是4.</p>\n<p>(2) 需要抛多少次硬币，使【至少出现2次正面朝上】的概率达到50%。</p>\n<p>(3) 需要抛多少次骰子，使【至少出现2次点数1】的概率达到50%。</p>\n<p>题目（2）（3）这类问题，可以转化成“几何分布的叠加问题”。这里的概率稳定<del>比较简单</del>，还可以参阅负二项分布有关资料。</p>\n<p>而对于的祈愿的建模，概率不稳定，有三种可能的思考方向：一可以用模拟动态规划处理，二是对各种情况进行全概率公式展开（<del>工作量极大</del>），三是离散信号的进行卷积运算:$P(Z=X+Y=z) = \\sum_1^\\infty PDF(X=z-y)P(X=y)$</p>\n<p>笔者采用第三种方法。</p>\n<p>各位修改一下代码的变量，即可获取想要的值。</p>\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">c5_need &#x3D; 2#需要抽出几次五星角色；\nc5_poss &#x3D; 0.25#想知道的概率;\nconv &#x3D; pdf_5;\nfor cnt in range(0,c5_need - 1):\n    conv&#x3D;np.convolve(conv,pdf_5,&#39;full&#39;)\n    plt.plot(conv)\n    tmp &#x3D; 0.0\n    for i in range (0,len(conv)):\n        tmp +&#x3D; conv[i]\n        if(cnt &#x3D;&#x3D; c5_need - 2 and tmp &gt;&#x3D; c5_poss):\n            print(i+c5_need);\n            break\n    #DEMO\n    #135 -- 需要祈愿135次，才有50%的概率获得两个五星角色。\n\t#祈愿154次，有75%的概率获得两个五星角色。</code></pre>\n\n<p>我对获得两次的情况列了个分布图：</p>\n<p><img src=\"http://img.070077.xyz/%E5%8E%9F%E7%A5%9E%E6%8A%BD%E5%8D%A12%E6%AC%A1%E4%BA%94%E6%98%9F%E6%A6%82%E7%8E%87%E5%88%86%E5%B8%83%E5%9B%BE.png\" alt=\"原神抽卡2次五星概率分布图\"></p>\n<h4 id=\"双角色池祈愿\"><a href=\"#双角色池祈愿\" class=\"headerlink\" title=\"双角色池祈愿\"></a>双角色池祈愿</h4><p>这个其实没什么太大的变化，把A2等价成A1，就可以和上文的A的结论统一了。</p>\n<h2 id=\"保底依赖下的分位点分析\"><a href=\"#保底依赖下的分位点分析\" class=\"headerlink\" title=\"保底依赖下的分位点分析\"></a>保底依赖下的分位点分析</h2><h3 id=\"尝试1：将“保底获得的五星”和“祈愿次数”拆成两个独立事件\"><a href=\"#尝试1：将“保底获得的五星”和“祈愿次数”拆成两个独立事件\" class=\"headerlink\" title=\"尝试1：将“保底获得的五星”和“祈愿次数”拆成两个独立事件\"></a>尝试1：将“保底获得的五星”和“祈愿次数”拆成两个独立事件</h3><h4 id=\"保底之间的马尔可夫过程\"><a href=\"#保底之间的马尔可夫过程\" class=\"headerlink\" title=\"保底之间的马尔可夫过程\"></a>保底之间的马尔可夫过程</h4><p>由于角色祈愿机制满足：本次获取五星角色是否为A的概率仅取决于上次获取的五星角色是否为A。符合马尔可夫过程（状态$i$只取决于上一次状态$i-1$，与再先前的状态相互独立。参：课本P321）的建模标准，可以做出以下状态图和概率转移矩阵：</p>\n<pre class=\"line-numbers language-mermaid\" data-language=\"mermaid\"><code class=\"language-mermaid\">graph LR\nA --1&#x2F;2--&gt; !A\n!A --1--&gt; A\nA --1&#x2F;2--&gt; A</code></pre>\n<p>$$ M = \\space \\begin{matrix}  &amp; A &amp; !A\\A &amp; {1}\\over{2} &amp; {1}\\over{2}\\!A &amp; 1 &amp; 0\\end{matrix}$$</p>\n<p>马尔可夫链在三门问题、经济学分析、自然语言处理等领域具有广泛的应用，在极值环境下具有平稳分布的特点。以下进行模拟分析。</p>\n<p>收敛的综合概率：$M^\\infty$。经过计算，可知A物品的综合概率为$\\frac{2}{3}$ 。这个计算结果可以理解为：任意一次获得五星角色，有$\\frac{2}{3}$的概率是A.（初始状况：刚获得A，以说明存在小保底）</p>\n<p>而对于中间情况的分析，可对应转换为矩阵的乘法和加法运算。</p>\n<p>但是我们很难把两个独立事件的概率组合到一起，以达到50%，请看下面的分析。</p>\n<h4 id=\"分类讨论的方式求取概率\"><a href=\"#分类讨论的方式求取概率\" class=\"headerlink\" title=\"分类讨论的方式求取概率\"></a>分类讨论的方式求取概率</h4><p>我们以抽到零命为例，对应的状态矩阵为$M$。因为初始状态（你可以理解为-1命）为A，此时可以理解为对应的概率为：$p_{11}P(获得一次五星) +p_{12}(获得二次五星)$，其中获得两次五星的概率模型可参考上面的卷积公式（由于二次五星也比较简单，大可自己分类讨论写）,如：</p>\n<p>$$ \\frac{1}{2}PDF(X) + \\frac{1}{2}PDF(Z)$$（注：x&gt;90的部分，记为0即可，因为那部分情况已结束。）</p>\n<p>验证这一方法的正确性：</p>\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">tmp &#x3D; 0.0\nfor i in range(0,179):\n    if(i&lt;90): tmp +&#x3D; 0.5 * pdf_5[i];\n    tmp+&#x3D;0.5*conv[i];\n    if(tmp&gt;&#x3D;0.5):\n        print(i);\n        break;\n&#x2F;&#x2F;沿用上方的数组了，输出为79.\n因为列表下标是从0开始计数的，79 &lt; 90 ，所以对应：80次祈愿可使抽到UP五星的概率达到50%。</code></pre>\n\n<p>如果需要制图，可以使用以下的画图模板代码</p>\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">#制图代码\nx_major_locator&#x3D;MultipleLocator(4)#x分度值设置\ny_major_locator&#x3D;MultipleLocator(0.1)\nax&#x3D;plt.gca()\nax.xaxis.set_major_locator(x_major_locator)\nax.yaxis.set_major_locator(y_major_locator)\nplt.grid()  # 生成网格\nx_values &#x3D; [x for x in range(1, 91)]\ny_values &#x3D; [pdf_5[x] for x in range(0, 90)]\nplt.plot(x_values,y_values)</code></pre>\n\n<p>如果是多命，则需要更复杂的分类讨论。如：一命的情况，就需要二次转移矩阵$M^2$的各项作为转移概率了，包括(A A ， A !A A ， !A A A ， !A A !A A)四种状态对应的状态转移概率，以及多次的卷积结果。由于前面代码没有记忆，就不尝试了。</p>\n<h3 id=\"尝试2：动态规划的角度\"><a href=\"#尝试2：动态规划的角度\" class=\"headerlink\" title=\"尝试2：动态规划的角度\"></a>尝试2：动态规划的角度</h3><h4 id=\"抽到多个五星角色中UP五星角色的个数概率\"><a href=\"#抽到多个五星角色中UP五星角色的个数概率\" class=\"headerlink\" title=\"抽到多个五星角色中UP五星角色的个数概率\"></a>抽到多个五星角色中UP五星角色的个数概率</h4><p>其实上面的转移矩阵比较简单，直接可以写出状态转移方程，考虑动态规划。</p>\n<p>定义状态$dp[i][j][1]$表示第 $i$ 次获得的五星角色时得到当期UP角色A后，共获得了$j$次A角色，达到$j-1$命 （第一次获得A角色达到0命）；类似地，$dp[i][j][0]$ 表示第 $i$ 次获得的五星角色不是A。</p>\n<p>则状态转移方程：</p>\n<p>$$ dp[i][j][0] = \\frac{1}{2}dp[i-1][j][1] $$</p>\n<p>$$ dp[i][j][1] = \\frac{1}{2}dp[i-1][j-1][1] + dp[i-1][j-1][0]$$</p>\n<p>起点：$dp[0][0][1] = 1$</p>\n<p>由此可以记$dp[i][j]$为第$i$次获得五星角色后共获得$j$次（及以上）A角色的概率，则：</p>\n<p>$$ dp[i][j] = \\sum_{k=j}^{i}dp[i][k][1]+dp[i][k][0] $$</p>\n<p>尝试构造含$i,j,dp[i][j]$三个变量的图：<img src=\"http://img.070077.xyz/%E5%8E%9F%E7%A5%9E%E5%91%BD%E5%BA%A7%E6%8A%BD%E6%95%B0%E6%A6%82%E7%8E%87%E5%88%86%E5%B8%83%E5%9B%BE.png\"></p>\n<p>由图中可以估计获取1~7次A角色时，使概率达到50%时，横坐标即为需要获得A角色的次数。（x，y）表示，已获得x次五星角色的情况下，y为对应的总共获取次数大于等于对应i的概率。</p>\n<h4 id=\"求取命座-祈愿次数概率\"><a href=\"#求取命座-祈愿次数概率\" class=\"headerlink\" title=\"求取命座-祈愿次数概率\"></a>求取命座-祈愿次数概率</h4><p>定义：$ dp[i][j][k] $ ：第j次祈愿的结果对应k，并第i次获得A角色的概率，则状态转移方程：</p>\n<ul>\n<li>大保底状态：上次五星!A，这次必获得A；</li>\n<li>小保底状态：上次五星是A（初始状态），这次只有50%的概率获得A。</li>\n<li>k = 0 ： 获得五星角色A</li>\n<li>k = 1 ： 获得五星角色且!A</li>\n</ul>\n<p>（临时变量：tmp：上次获得五星的祈愿次数）</p>\n<ul>\n<li>注意：要明确状态转移的结果“from to”。循环遍历时，由j逐步+k确定后续值并进行迭代赋值，会导致一个点的值多次计入概率，所以最后取概率只需要取[0]</li>\n</ul>\n<p>$$ dp[i][j][0] = dp[i-1][tmp][1] * PDF(j-tmp) + dp[i-1][tmp][0] * \\frac{1}{2} * PDF(j-tmp)$$</p>\n<p>$$ dp[i][j][1] = dp[i][tmp][0] * \\frac{1}{2} * PDF(j-tmp)$$</p>\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">n5_cnt&#x3D;1;#要抽出多少次A\nn5_tries&#x3D;180;#准备的祈愿次数\ntmp &#x3D; 0;\ndp_p &#x3D; np.zeros((13, 180*n5_cnt+90,2), dtype&#x3D;float);\ndp_p[0][0][0] &#x3D; 1\nfor i in range (0,n5_cnt+1):\n        for j in range (0,n5_tries):\n            for k in range (1,91):\n                if(i-1&gt;&#x3D;0):\n                    dp_p[i][j+k][0] +&#x3D; dp_p[i-1][j][1] * pdf_5[k-1] + dp_p[i-1][j][0] * 0.5 * pdf_5[k-1];\n                dp_p[i][j+k][1] +&#x3D; dp_p[i][j][0] * 0.5 * pdf_5[k-1]\nposs&#x3D;[]\nfor i in range(0,n5_tries):\n    tmp &#x3D; tmp + dp_p[n5_cnt][i][0]\n    poss.append(tmp)\nprint(tmp)\nplt.plot(poss)\n#DEMO:0.4762677010731945</code></pre>\n\n<p> 与上面的卷积验证是一致的。</p>\n<p>0命概率图：<img src=\"http://img.070077.xyz/%E5%8E%9F%E7%A5%9E%E6%8A%BD%E5%8D%A12%E6%AC%A1%E4%BA%94%E6%98%9F%E6%A6%82%E7%8E%87%E5%88%86%E5%B8%83%E5%9B%BE.1png.png\" alt=\"原神抽卡2次五星概率分布图.1png\"></p>\n<h4 id=\"非默认状态开始的动态规划（To-Be-Continued…）\"><a href=\"#非默认状态开始的动态规划（To-Be-Continued…）\" class=\"headerlink\" title=\"非默认状态开始的动态规划（To Be Continued…）\"></a>非默认状态开始的动态规划（To Be Continued…）</h4><p>如果开始状态为大保底状态，或已经有一定的祈愿次数呢？以后再写。</p>\n<h2 id=\"四星角色祈愿分析\"><a href=\"#四星角色祈愿分析\" class=\"headerlink\" title=\"四星角色祈愿分析\"></a>四星角色祈愿分析</h2><p>预设：获取到五星时，不会重置四星角色的保底。且，以下策略，如果出了五星角色，先笑一笑，算法就当没祈愿哈~</p>\n<h3 id=\"概览\"><a href=\"#概览\" class=\"headerlink\" title=\"概览\"></a>概览</h3><p>四星的分析只需要将上面的p_5相关改成p_4即可，在此省略不表，给出一定结论：<img src=\"http://img.070077.xyz/%E5%8E%9F%E7%A5%9E%E5%9B%9B%E6%98%9F%E8%A7%92%E8%89%B2pdfcdf.png\" alt=\"原神四星角色pdfcdf\"></p>\n<p>0命图：<img src=\"http://img.070077.xyz/%E5%8E%9F%E7%A5%9E4%E6%98%9F0%E5%91%BD%E6%8A%BD%E6%95%B0%E6%A6%82%E7%8E%87%E5%88%86%E5%B8%83%E5%9B%BE.png\" alt=\"原神4星0命抽数概率分布图\"></p>\n<h3 id=\"算法\"><a href=\"#算法\" class=\"headerlink\" title=\"算法\"></a>算法</h3><p>定义：$ dp[i][j][k] $ ：第j次祈愿的结果对应k，并第i次获得B角色的概率，则状态转移方程：</p>\n<ul>\n<li>保底状态：上次四星!UP，这次必获得UP角色</li>\n<li>k = 0 ： 获得想要的四星角色B</li>\n<li>k = 1 ： 获得UP四星角色但不是B</li>\n<li>k = 2：获得非UP四星角色</li>\n</ul>\n<p>（临时变量：tmp：上次获得四星的祈愿次数）</p>\n<p>$$ dp[i][j][0] = dp[i-1][tmp][1] * PDF(j-tmp) * \\frac{1}{6} \\+ dp[i-1][tmp][0] * \\frac{1}{6} * PDF(j-tmp) \\+ dp[i-1][tmp][1] * PDF(j-tmp) * \\frac{1}{3}$$</p>\n<p>$$ dp[i][j][1] = dp[i][tmp][0] * \\frac{1}{3} * PDF(j-tmp) \\+ dp[i][tmp][1] * PDF(j-tmp) * \\frac{1}{3} \\+  dp[i][tmp][2] * \\frac{2}{3} * PDF(j-tmp)$$</p>\n<p>$$ dp[i][j][2] = dp[i][tmp][0] * \\frac{1}{2} * PDF(j-tmp) + dp[i][tmp][1] * \\frac{1}{2} * PDF(j-tmp)$$</p>\n<p>任意代码：（原理与下方“无定轨机制武器祈愿”类似，这里人比较懒，直接对p_5移花接木了）</p>\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">#每抽概率\n#这是研究四星的，但是为了偷懒，捏：\ndef p_5(n):\n    if n &lt; 8:\n        return 0.051;\n    elif n &lt; 9:\n        return 0.561;\n    else:\n        return 1;\n        \npdf_5 &#x3D; [];\ncdf_5 &#x3D; [];\ntmp &#x3D; 0.0;\n\nfor i in range (0,10):\n    tmp &#x3D; p_5(i);\n    for j in range(0,i):\n        tmp &#x3D; tmp * (1 - p_5(j))\n    pdf_5.append(tmp);\n\nfor i in range (0,10):\n    tmp &#x3D; 0.0;\n    for j in range (0,i+1):\n        tmp &#x3D; tmp + pdf_5[j];\n    cdf_5.append(tmp);\n    print(i+1,cdf_5[i])\n \nn5_cnt&#x3D;1#要抽出多少次B\nn5_tries&#x3D;130 * n5_cnt;#准备的祈愿次数\ntmp &#x3D; 0;\ndp_p &#x3D; np.zeros((13, 150*n5_cnt + 20,3), dtype&#x3D;float);\ndp_p[0][0][0] &#x3D; 1\n# 0 - B 1 - UP &amp; !B 2- !UP\nfor i in range (0,n5_cnt+1):\n        for j in range (0,n5_tries):\n            for k in range (1,11):\n                if(i-1&gt;&#x3D;0):\n                    dp_p[i][j+k][0] +&#x3D; dp_p[i-1][j][2] * pdf_5[k-1] * 1&#x2F;3\\\n                                    + dp_p[i-1][j][1] * pdf_5[k-1] * 1&#x2F;6 + dp_p[i-1][j][0] * 1&#x2F;6 * pdf_5[k-1];\n                dp_p[i][j+k][1] +&#x3D; dp_p[i][j][0] * 1&#x2F;3 * pdf_5[k-1] + dp_p[i][j][2] * 2&#x2F;3 * pdf_5[k-1]\\\n                                + dp_p[i][j][1] * 1&#x2F;3 * pdf_5[k-1];\n                dp_p[i][j+k][2] +&#x3D; dp_p[i][j][0] * 1&#x2F;2 * pdf_5[k-1] + dp_p[i][j][1] * 1&#x2F;2 * pdf_5[k-1];\nposs&#x3D;[]\nfor i in range(0,n5_tries):\n    tmp &#x3D; tmp + dp_p[n5_cnt][i][0]\n    poss.append(tmp)\nprint(tmp)\n#制图代码，直接cv用\nx_major_locator&#x3D;MultipleLocator(10)#x分度值设置\ny_major_locator&#x3D;MultipleLocator(0.1)\nax&#x3D;plt.gca()\nax.xaxis.set_major_locator(x_major_locator)\nax.yaxis.set_major_locator(y_major_locator)\nx_values &#x3D; [x for x in range(1, n5_tries)]\nplt.grid()  # 生成网格\nplt.plot(poss)  </code></pre>\n\n\n\n<h2 id=\"不同模型对比研究\"><a href=\"#不同模型对比研究\" class=\"headerlink\" title=\"不同模型对比研究\"></a>不同模型对比研究</h2><h3 id=\"与无保底机制（均匀1-6-）的对比\"><a href=\"#与无保底机制（均匀1-6-）的对比\" class=\"headerlink\" title=\"与无保底机制（均匀1.6%）的对比\"></a>与无保底机制（均匀1.6%）的对比</h3><p>​    修改</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">def p_5(n):\n\treturn 0.016;</code></pre>\n\n<p>期望：不变；</p>\n<p>分位点图：<img src=\"http://img.070077.xyz/%E5%9D%87%E5%8C%801.6%E5%8E%9F%E7%A5%9E%E6%8A%BD%E5%8D%A1%E6%A6%82%E7%8E%87%E5%88%86%E5%B8%83%E5%9B%BE.png\" alt=\"均匀1.6原神抽卡概率分布图\"></p>\n<p>极端情况上升了~</p>\n<p>两次五星分布图：<img src=\"http://img.070077.xyz/%E5%9D%87%E5%8C%801.6%E5%8E%9F%E7%A5%9E%E6%8A%BD%E5%8D%A12%E6%AC%A1%E4%BA%94%E6%98%9F%E6%A6%82%E7%8E%87%E5%88%86%E5%B8%83%E5%9B%BE.png\" alt=\"均匀1.6原神抽卡2次五星概率分布图\"></p>\n<p>一命概率分布图：<img src=\"http://img.070077.xyz/%E5%9D%87%E5%8C%801.6%E5%8E%9F%E7%A5%9E%E6%8A%BD%E5%8D%A1%E4%B8%80%E5%91%BD%E6%A6%82%E7%8E%87%E5%88%86%E5%B8%83%E5%9B%BE.png\" alt=\"均匀1.6原神抽卡一命概率分布图\"></p>\n<p>可以发现，均匀和非均匀，有利有弊吧。</p>\n<h3 id=\"与保底前均匀机制（魔改尝试1）的对比\"><a href=\"#与保底前均匀机制（魔改尝试1）的对比\" class=\"headerlink\" title=\"与保底前均匀机制（魔改尝试1）的对比\"></a>与保底前均匀机制（魔改尝试1）的对比</h3><p>用我比较熟悉的c++建模以下（其实更精确的值为0.88%）</p>\n<p>$$  P(x) = \\begin{cases} 0.9% &amp;{x\\leqslant 89}\\1&amp;{x = 90} \\end{cases} $$</p>\n<p>期望：62.06（综合概率：1.61%）</p>\n<p>分位点分布图：</p>\n<p><img src=\"http://img.070077.xyz/%E9%AD%94%E6%94%B91.6%E5%8E%9F%E7%A5%9E%E6%8A%BD%E5%8D%A1%E6%A6%82%E7%8E%87%E5%88%86%E5%B8%83%E5%9B%BE.png\" alt=\"魔改1.6原神抽卡概率分布图\"></p>\n<p>两次五星分布图：<img src=\"http://img.070077.xyz/%E9%AD%94%E6%94%B91.6%E5%8E%9F%E7%A5%9E%E6%8A%BD%E5%8D%A12%E6%AC%A1%E4%BA%94%E6%98%9F%E6%A6%82%E7%8E%87%E5%88%86%E5%B8%83%E5%9B%BE.png\" alt=\"魔改1.6原神抽卡2次五星概率分布图\"></p>\n<p>一命概率分布图：<img src=\"http://img.070077.xyz/%E9%AD%94%E6%94%B91.6%E5%8E%9F%E7%A5%9E%E6%8A%BD%E5%8D%A1%E4%B8%80%E5%91%BD%E6%A6%82%E7%8E%87%E5%88%86%E5%B8%83%E5%9B%BE.png\" alt=\"魔改1.6原神抽卡一命概率分布图\"></p>\n<p>会让更多人吃保底~</p>\n<h1 id=\"武器祈愿分析\"><a href=\"#武器祈愿分析\" class=\"headerlink\" title=\"武器祈愿分析\"></a>武器祈愿分析</h1><h2 id=\"概率递增保底机制及数字特征\"><a href=\"#概率递增保底机制及数字特征\" class=\"headerlink\" title=\"概率递增保底机制及数字特征\"></a>概率递增保底机制及数字特征</h2><p>武器祈愿的机制和角色祈愿大体一致。算法参上，在此直接给出结论。</p>\n<p>五星武器概率：</p>\n<p>$$P(x) = \\begin{cases}0.7% &amp; x\\leqslant62\\0.7%+7%(x-62) &amp; 63\\leqslant x \\leqslant 71\\ 63.7% + 3.5%(x-71) &amp; 72\\leqslant x \\leqslant 79 \\ 1 &amp; x=80\\end{cases}$$ </p>\n<p>数学期望：54.25.</p>\n<p>综合概率：1.88%</p>\n<p>分布图：<img src=\"http://img.070077.xyz/%E5%8E%9F%E7%A5%9E%E6%AD%A6%E5%99%A8%E6%8A%BD%E5%8D%A1%E6%A6%82%E7%8E%87%E5%88%86%E5%B8%83%E5%9B%BE.png\" alt=\"原神武器抽卡概率分布图\"></p>\n<p>四星武器概率</p>\n<p>$$P(x) = \\begin{cases}6% &amp; x\\leqslant 7\\66% &amp; x = 8 \\ 96% &amp; x = 9 \\ 1 &amp; x=10\\end{cases}$$</p>\n<p>数学期望：6.74.</p>\n<p>综合概率：14.84%。</p>\n<p>你会发现，分成了四段，复杂了一点。</p>\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">#每抽概率\ndef p_5(n):\n    if n &lt; 62:\n        return 0.007;\n    elif n &lt; 71:\n        return 0.007 + (n - 62) * 0.07;\n    elif n &lt; 79:\n        return 0.637 + (n - 71) * 0.035;\n    else:\n        return 1.0;\ndef p_4(n):\n    if n &lt; 7:\n        return 0.06\n    elif n &lt; 8:\n        return 0.66\n    elif n &lt; 9:\n        return 0.96;\n    else:\n        return 1;\npdf_5 &#x3D; [];#第x+1抽出概率\ncdf_5 &#x3D; [];\ntmp &#x3D; 0.0;\n\nfor i in range (0,80):\n    tmp &#x3D; p_5(i);\n    for j in range(0,i):\n        tmp &#x3D; tmp * (1.0 - p_5(j))\n    pdf_5.append(tmp);\n\nfor i in range (0,80):\n    tmp &#x3D; 0.0;\n    for j in range (0,i+1):\n        tmp &#x3D; tmp + pdf_5[j];\n    cdf_5.append(tmp);\n    print(i+1,cdf_5[i])</code></pre>\n\n\n\n<h2 id=\"定轨机制下的资源规划（假设定轨M）\"><a href=\"#定轨机制下的资源规划（假设定轨M）\" class=\"headerlink\" title=\"定轨机制下的资源规划（假设定轨M）\"></a>定轨机制下的资源规划（假设定轨M）</h2><h3 id=\"获取五星武器M的祈愿次数分析\"><a href=\"#获取五星武器M的祈愿次数分析\" class=\"headerlink\" title=\"获取五星武器M的祈愿次数分析\"></a>获取五星武器M的祈愿次数分析</h3><p>由于命定值机制，马尔可夫过程比较复杂。于是考虑动态规划：</p>\n<p>定义$dp[i][j][k]$为第j次祈愿时第i次获得五星武器M，祈愿后k：</p>\n<ul>\n<li>k = 0 : 命定值为0。表示抽到了M.</li>\n<li>k = 1：命定值为1且抽到了N.</li>\n<li>k = 2：命定值为1且抽到的是非UP武器。</li>\n<li>k = 3：命定值为2，抽出来的不是M，具体是啥在本小节中不相关。</li>\n</ul>\n<p>$$ dp[i][j][0] = dp[i-1][tmp][0] * \\frac{3}{8} *PDF(j-tmp) \\+ dp[i-1][tmp][1] * \\frac{3}{8} * PDF(j-tmp) \\+ dp[i-1][tmp][2] * \\frac{1}{2}*PDF(j-tmp) \\+ dp[i-1][tmp][3] *PDF(j-tmp)$$</p>\n<p>$$ dp[i][j][1] = dp[i][tmp][0] <em>\\frac{1}{4}</em> PDF(j-tmp)$$</p>\n<p>$$ dp[i][j][2] = dp[i][tmp][0] <em>\\frac{3}{8}</em> PDF(j-tmp)$$</p>\n<p>$$ dp[i][j][3] = dp[i][tmp][1] * ( \\frac{3}{8} + \\frac{1}{4}) *PDF(j-tmp) \\ + dp[i][tmp][2] * \\frac{1}{2} * PDF(j-tmp)$$</p>\n<p>运行代码：</p>\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">n5_cnt&#x3D;2;#要抽出多少次M\nn5_tries&#x3D; 207;#准备的祈愿次数\ntmp &#x3D; 0;\ndp_p &#x3D; np.zeros((13, 330*n5_cnt,5), dtype&#x3D;float);\ndp_p[0][0][0] &#x3D; 1\nfor i in range (0,n5_cnt+1):\n        for j in range (0,n5_tries + n5_cnt + 1):\n            for k in range (1,81):\n                if(i-1&gt;&#x3D;0):\n                    dp_p[i][j+k][0] +&#x3D; dp_p[i-1][j][0] * pdf_5[k-1] * 0.375\\\n                                + dp_p[i-1][j][1] * 0.375 * pdf_5[k-1] \\\n                                + dp_p[i-1][j][2] * 0.5 * pdf_5[k-1]\\\n                                + dp_p[i-1][j][3] * pdf_5[k-1];\n                dp_p[i][j+k][1] +&#x3D; dp_p[i][j][0] * 0.25 * pdf_5[k-1];\n                dp_p[i][j+k][2] +&#x3D; dp_p[i][j][0] * 0.375 * pdf_5[k-1];\n                dp_p[i][j+k][3] +&#x3D; dp_p[i][j][1] * 0.625 * pdf_5[k-1]\\\n                                + dp_p[i][j][2] * 0.5 * pdf_5[k-1];\nposs&#x3D;[]\nfor i in range(0,n5_tries):\n    tmp &#x3D; tmp + dp_p[n5_cnt][i][0]\n    poss.append(tmp)\nprint(tmp)\nplt.plot(poss)\n#0.49317051582855165</code></pre>\n\n<p>进行99次祈愿后，获得M的概率达到50%。以下是获取一次武器M的概率分布图：</p>\n<p><img src=\"http://img.070077.xyz/%E5%8E%9F%E7%A5%9E%E6%AD%A6%E5%99%A8m%E6%8A%BD%E5%8D%A1%E6%A6%82%E7%8E%87%E5%88%86%E5%B8%83%E5%9B%BE.png\" alt=\"原神武器m抽卡概率分布图\"></p>\n<h3 id=\"获取五星武器N的祈愿次数分析\"><a href=\"#获取五星武器N的祈愿次数分析\" class=\"headerlink\" title=\"获取五星武器N的祈愿次数分析\"></a>获取五星武器N的祈愿次数分析</h3><p>问题：我定轨了M，反而想获取五星武器N…（反向定轨）</p>\n<p>定义$dp[i][j][k]$为第j次祈愿时第i次获得五星武器N，祈愿后k：</p>\n<ul>\n<li>k = 0 : 命定值为0。表示抽到了M.</li>\n<li>k = 1：命定值为1且抽到了N.</li>\n<li>k = 2：命定值为1且抽到的是非UP武器。</li>\n<li>k = 3：命定值为2，且抽到了N.</li>\n<li>k = 4：命定值为2，且抽到的是非UP武器。</li>\n</ul>\n<p>$$ dp[i][j][0] = dp[i][tmp][0] * \\frac{3}{8} *PDF(j-tmp) \\ + dp[i][tmp][1] * \\frac{3}{8} * PDF(j-tmp) \\+ dp[i][tmp][2] * \\frac{1}{2}*PDF(j-tmp) \\+ dp[i][tmp][3] * PDF(j-tmp) \\ + dp[i][tmp][4] * PDF(j-tmp)$$</p>\n<p>$$ dp[i][j][1] = dp[i-1][tmp][0] <em>\\frac{3}{8}</em> PDF(j-tmp)$$</p>\n<p>$$ dp[i][j][2] = dp[i][tmp][0] <em>\\frac{1}{4}</em> PDF(j-tmp)$$</p>\n<p>$$ dp[i][j][3] = dp[i-1][tmp][1] * ( \\frac{3}{8}) * PDF(j-tmp) \\ + dp[i-1][tmp][2] * \\frac{1}{2} * PDF(j-tmp)$$</p>\n<p>$$ dp[i][j][4] = dp[i][tmp][1] * \\frac{1}{4} * PDF(j-tmp)$$</p>\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">n5_cnt&#x3D;1;#要抽出多少次N\nn5_tries&#x3D; 106;#准备的祈愿次数\ntmp &#x3D; 0;\ndp_p &#x3D; np.zeros((13, 510*n5_cnt + 80,5), dtype&#x3D;float);\ndp_p[0][0][0] &#x3D; 1\nfor i in range (0,n5_cnt+1):\n        for j in range (0,n5_tries + n5_cnt + 1):\n            for k in range (1,81):\n                dp_p[i][j+k][0] +&#x3D; dp_p[i][j][0] * pdf_5[k-1] * 0.375\\\n                                + dp_p[i][j][1] * 0.375 * pdf_5[k-1] \\\n                                + dp_p[i][j][2] * 0.5 * pdf_5[k-1]\\\n                                + dp_p[i][j][3] * pdf_5[k-1]\\\n                                + dp_p[i][j][4] * pdf_5[k-1];\n                dp_p[i][j+k][1] +&#x3D; dp_p[i-1][j][0] * 0.375 * pdf_5[k-1];\n                dp_p[i][j+k][2] +&#x3D; dp_p[i][j][0] * 0.25 * pdf_5[k-1];\n                dp_p[i][j+k][3] +&#x3D; dp_p[i-1][j][1] * 0.375 * pdf_5[k-1]\\\n                                + dp_p[i-1][j][2] * 0.5 * pdf_5[k-1];\n                dp_p[i][j+k][4] +&#x3D; dp_p[i][j][1] * 0.25 * pdf_5[k-1]\nposs&#x3D;[]\nfor i in range(0,n5_tries):\n    tmp &#x3D; tmp + dp_p[n5_cnt][i][1] + dp_p[n5_cnt][i][3]\n    poss.append(tmp)\nprint(tmp)\n#DEMO:0.5007747697175682</code></pre>\n\n<p>图表</p>\n<p>​    <img src=\"http://img.070077.xyz/%E5%8E%9F%E7%A5%9E%E6%AD%A6%E5%99%A8n%E6%8A%BD%E5%8D%A1%E6%A6%82%E7%8E%87%E5%88%86%E5%B8%83%E5%9B%BE.png\" alt=\"原神武器n抽卡概率分布图\"></p>\n<h3 id=\"获取五星武器M、N的祈愿次数分析（To-Be-Updated…\"><a href=\"#获取五星武器M、N的祈愿次数分析（To-Be-Updated…\" class=\"headerlink\" title=\"获取五星武器M、N的祈愿次数分析（To Be Updated…)\"></a>获取五星武器M、N的祈愿次数分析（To Be Updated…)</h3><p>问题：我定轨了M，但M、N都想要。</p>\n<p>我可能比较蠢：四维动态规划？</p>\n<p>定义$dp[h][i][j][k]$为第j次祈愿时第i次获得五星武器N，第h获得五星武器M，祈愿后k：……（同上）</p>\n<p>呃，我们先不考虑土豪了哈，我们只考虑都只获得1次的情况，只需要把<code>tmp = tmp + dp_p[n5_cnt][i][1] + dp_p[n5_cnt][i][3]</code> 再加一项 <code>dp_p[n5_cnt][i][0]</code> ？</p>\n<p>我也希望这能成功，但是这么直接地不可行，因为前面那两项的概率本身就包含了上一次抽到M的情况，再加会导致重复计算，我没想到别的方式改良之。</p>\n<p>另一种思路是分类讨论了，分为先获得M后获得N、先获得N再获得M两种情况。</p>\n<p>再者就是还是含泪：</p>\n<ul>\n<li>需要做出一定的修改，使状态转移时，不忽略h的出现次数。</li>\n</ul>\n<p>$$ dp[h][i][j][0] = dp[h-1][i][tmp][0] * \\frac{3}{8} *PDF(j-tmp) \\ + dp[h-1][i][tmp][1] * \\frac{3}{8} * PDF(j-tmp) \\+ dp[h-1][i][tmp][2] * \\frac{1}{2}*PDF(j-tmp) \\+ dp[h-1][i][tmp][3] * PDF(j-tmp) \\ + dp[h-1][i][tmp][4] * PDF(j-tmp)$$</p>\n<p>$$ dp[h][i][j][1] = dp[h][i-1][tmp][0] <em>\\frac{3}{8}</em> PDF(j-tmp)$$</p>\n<p>$$ dp[h][i][j][2] = dp[h][i][tmp][0] <em>\\frac{1}{4}</em> PDF(j-tmp)$$</p>\n<p>$$ dp[h][i][j][3] = dp[h][i-1][tmp][1] * ( \\frac{3}{8}) * PDF(j-tmp) \\ + dp[h][i-1][tmp][2] * \\frac{1}{2} * PDF(j-tmp)$$</p>\n<p>$$ dp[h][i][j][4] = dp[h][i][tmp][1] * \\frac{1}{4} * PDF(j-tmp)$$</p>\n<p>事实证明上面的方法不一定获得了正确答案。这个错误是没有价值的吗，不，他可能会给一个同样想研究这一问题的人一个参考。于是提出下面的形式：</p>\n<p>定义$dp[i][j][k]$为第j次祈愿时，i - 获得的目标种类数 , 祈愿后k同上。</p>\n<p>其实关键原因和上面的“加一项”一样，就是因为最后获取概率时，需要涵盖多个状态。以前的动态规划获取概率时，获取的状态间互相不存在依赖，而这次获取概率时，各个状态内部的转移存在相关。</p>\n<p>最近灵感较为枯竭，先赶别的ddl了。在此附上可能是错误的代码（若考虑较大次数，可能需修改码参数/概率不准确）和运行结果：</p>\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">n5_cnt_M&#x3D;1;#要抽出多少次M,N\nn5_cnt_N&#x3D;1;\nn5_cnt&#x3D;n5_cnt_M + n5_cnt_N;\nn5_tries&#x3D; 180*n5_cnt;#准备的祈愿次数\ntmp &#x3D; 0;\ndp_p &#x3D; np.zeros((13,13, 310*n5_cnt + 80,5), dtype&#x3D;float);\ndp_p[0][0][0][0] &#x3D; 1\n\nh &#x3D; 0;\nfor h in range (0,3*n5_cnt_M +1):\n    for i in range(0,3*n5_cnt_N+1):\n        for j in range (0,n5_tries + n5_cnt + 1):\n            for k in range (1,81):\n                    dp_p[h][i][j+k][0] +&#x3D; dp_p[h-1][i][j][0] * pdf_5[k-1] * 0.375\\\n                                + dp_p[h-1][i][j][1] * 0.375 * pdf_5[k-1] \\\n                                + dp_p[h-1][i][j][2] * 0.5 * pdf_5[k-1]\\\n                                + dp_p[h-1][i][j][3] * pdf_5[k-1]\\\n                                + dp_p[h-1][i][j][4] * pdf_5[k-1];\n                    dp_p[h][i][j+k][1] +&#x3D; dp_p[h][i-1][j][0] * 0.375 * pdf_5[k-1];\n                    dp_p[h][i][j+k][2] +&#x3D; dp_p[h][i][j][0] * 0.25 * pdf_5[k-1];\n                    dp_p[h][i][j+k][3] +&#x3D; dp_p[h][i-1][j][1] * 0.375 * pdf_5[k-1]\\\n                                + dp_p[h][i-1][j][2] * 0.5 * pdf_5[k-1];\n                    dp_p[h][i][j+k][4] +&#x3D; dp_p[h][i][j][1] * 0.25 * pdf_5[k-1]\n\nposs&#x3D;[]\nfor i in range(0,n5_tries):\n    for i1 in range (n5_cnt_M,3*n5_cnt_M+1):\n        tmp +&#x3D; dp_p[i1][n5_cnt_N][i][1] + dp_p[i1][n5_cnt_N][i][3]\n    for i2 in range(n5_cnt_N,3*n5_cnt_N+1):\n        tmp +&#x3D; dp_p[n5_cnt_M][i2][i][0];\n    poss.append(tmp)\nprint(tmp)\n#制图代码，直接cv用\nx_major_locator&#x3D;MultipleLocator(20)#x分度值设置\ny_major_locator&#x3D;MultipleLocator(0.1)\nax&#x3D;plt.gca()\nax.xaxis.set_major_locator(x_major_locator)\nax.yaxis.set_major_locator(y_major_locator)\nplt.grid()  # 生成网格\nplt.plot(poss)</code></pre>\n\n<p><img src=\"http://img.070077.xyz/%E5%8E%9F%E7%A5%9E%E6%AD%A6%E5%99%A8m%E4%B8%94n%E6%8A%BD%E5%8D%A1%E6%A6%82%E7%8E%87%E5%88%86%E5%B8%83%E5%9B%BE.png\" alt=\"原神武器m且n抽卡概率分布图\"></p>\n<p>拓展问题：我先定轨了M，获取M后定轨N（命定值清零），参考上面两个问题叠加应该可以。</p>\n<h3 id=\"四星武器的分析\"><a href=\"#四星武器的分析\" class=\"headerlink\" title=\"四星武器的分析\"></a>四星武器的分析</h3><p>和上面四星角色祈愿分析思想一致。</p>\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">#偷懒：p_5的内容实际是p_4\nn5_cnt&#x3D;1#要抽出多少次F\nn5_tries&#x3D;130 * n5_cnt;#准备的祈愿次数\ntmp &#x3D; 0;\ndp_p &#x3D; np.zeros((13, 150*n5_cnt + 20,3), dtype&#x3D;float);\ndp_p[0][0][0] &#x3D; 1\n# 0 - F 1 - UP &amp; !F 2- !UP\nfor i in range (0,n5_cnt+1):\n        for j in range (0,n5_tries):\n            for k in range (1,11):\n                if(i-1&gt;&#x3D;0):\n                    dp_p[i][j+k][0] +&#x3D; dp_p[i-1][j][2] * pdf_5[k-1] * 1&#x2F;5\\\n                                    + dp_p[i-1][j][1] * pdf_5[k-1] * 3&#x2F;20 + dp_p[i-1][j][0] * 3&#x2F;20 * pdf_5[k-1];\n                dp_p[i][j+k][1] +&#x3D; dp_p[i][j][0] * 3&#x2F;5 * pdf_5[k-1] + dp_p[i][j][2] * 4&#x2F;5 * pdf_5[k-1]\\\n                                + dp_p[i][j][1] * 3&#x2F;5 * pdf_5[k-1];\n                dp_p[i][j+k][2] +&#x3D; dp_p[i][j][0] * 1&#x2F;4 * pdf_5[k-1] + dp_p[i][j][1] * 1&#x2F;4 * pdf_5[k-1];\nposs&#x3D;[]\nfor i in range(0,n5_tries):\n    tmp &#x3D; tmp + dp_p[n5_cnt][i][0]\n    poss.append(tmp)\nprint(tmp)\n#制图代码，直接cv用\nx_major_locator&#x3D;MultipleLocator(10)#x分度值设置\ny_major_locator&#x3D;MultipleLocator(0.1)\nax&#x3D;plt.gca()\nax.xaxis.set_major_locator(x_major_locator)\nax.yaxis.set_major_locator(y_major_locator)\nx_values &#x3D; [x for x in range(1, n5_tries)]\nplt.grid()  # 生成网格\nplt.plot(poss)  </code></pre>\n\n<p><img src=\"http://img.070077.xyz/%E5%8E%9F%E7%A5%9E%E5%9B%9B%E6%98%9F%E6%AD%A6%E5%99%A8f%E6%8A%BD%E5%8D%A1%E6%A6%82%E7%8E%87%E5%88%86%E5%B8%83%E5%9B%BE.png\" alt=\"原神四星武器f抽卡概率分布图\"></p>\n<h2 id=\"无定轨机制下武器祈愿分析\"><a href=\"#无定轨机制下武器祈愿分析\" class=\"headerlink\" title=\"无定轨机制下武器祈愿分析\"></a>无定轨机制下武器祈愿分析</h2><p>和上面四星角色祈愿分析思想一致。<img src=\"http://img.070077.xyz/%E5%8E%9F%E7%A5%9E%E6%AD%A6%E5%99%A8m%E4%B8%8D%E5%AE%9A%E8%BD%A8%E6%8A%BD%E5%8D%A1%E6%A6%82%E7%8E%87%E5%88%86%E5%B8%83%E5%9B%BE.png\" alt=\"原神武器m不定轨抽卡概率分布图\"></p>\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">#这次下面是真的武器池概率分布p_5了哈\nn5_cnt&#x3D;1#要抽出多少次M\nn5_tries&#x3D;240 * n5_cnt;#准备的祈愿次数\ntmp &#x3D; 0;\ndp_p &#x3D; np.zeros((13, 320*n5_cnt + 20,3), dtype&#x3D;float);\ndp_p[0][0][0] &#x3D; 1\n# 0 - M 1 - UP &amp; !M 2- !UP\nfor i in range (0,n5_cnt+1):\n        for j in range (0,n5_tries):\n            for k in range (1,81):\n                if(i-1&gt;&#x3D;0):\n                    dp_p[i][j+k][0] +&#x3D; dp_p[i-1][j][2] * pdf_5[k-1] * 1&#x2F;2 \\\n                                    + dp_p[i-1][j][1] * pdf_5[k-1] * 3&#x2F;8 + dp_p[i-1][j][0] * 3&#x2F;8 * pdf_5[k-1];\n                dp_p[i][j+k][1] +&#x3D; dp_p[i][j][0] * 3&#x2F;8 * pdf_5[k-1] + dp_p[i][j][2] * 1&#x2F;2 * pdf_5[k-1]\\\n                                + dp_p[i][j][1] * 3&#x2F;8 * pdf_5[k-1];\n                dp_p[i][j+k][2] +&#x3D; dp_p[i][j][0] * 1&#x2F;4 * pdf_5[k-1] + dp_p[i][j][1] * 1&#x2F;4 * pdf_5[k-1];\nposs&#x3D;[]\nfor i in range(0,n5_tries):\n    tmp &#x3D; tmp + dp_p[n5_cnt][i][0]\n    poss.append(tmp)\nprint(tmp)\n#制图代码，直接cv用\nx_major_locator&#x3D;MultipleLocator(15)#x分度值设置\ny_major_locator&#x3D;MultipleLocator(0.1)\nax&#x3D;plt.gca()\nax.xaxis.set_major_locator(x_major_locator)\nax.yaxis.set_major_locator(y_major_locator)\nx_values &#x3D; [x for x in range(1, n5_tries)]\nplt.grid()  # 生成网格\nplt.plot(poss)  </code></pre>\n\n<p>你如果和上面定轨时比较，会发现你想要M的话，需要投入稍微更多的抽数。而且可以看见，当投入200抽时，定轨机制下的获取M的概率已经逐步收敛至1。而不定轨机制下，获取到的概率的概率仅在80%附近，且之后收敛较慢，极端情况的发生概率并不低。</p>\n<p>有关不定轨又同时想要M和N的，TBC…</p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>概率分析还可以分析：如何配置属性让伤害最大化等问题。概率论作为一种打破人的直觉的东西，实在是让人又爱又恨。本文不仅仅局限于传统的期望范畴，结合具体概率的分布分析了对应的抽数需求。由于祈愿机制的概率不是恒定的，期望与中分位点存在区别，可以用平均GDP和中位数来感受。</p>\n<p>致谢：感谢张老师的帮助和OneBST的分享。</p>\n<p>【To Be Continued】</p>\n<ul>\n<li><p>同时研究多个四星的祈愿次数</p>\n</li>\n<li><p>常驻祈愿结合“联动规则”的分析</p>\n</li>\n<li><p>常驻祈愿与UP祈愿结合分析</p>\n</li>\n<li><p>蒙特卡罗模拟与大数定律</p>\n</li>\n<li><p>通过置信度研究极端情况</p>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p>#《原神》祈愿机制概率研究</p>\n<p>【摘要】本文以概率论、随机过程理论等工具研究游戏《原神》中的祈愿机制，主要基于动态规划，以“期望”和“概率的概率”两大分析方向进行数据处理，并根据分析结果总结了一些方便玩家规划金钱与资源的建议。由于追求多次获得五星道具的玩家基本“不差钱”，本文附有获取少量五星情况下的数据可视化。</p>\n<p>[TOC]</p>\n<blockquote>\n<p>Version:20220105</p>\n<ul>\n<li>修了讲一遍时找到的笔误</li>\n</ul>\n</blockquote>\n<h2 id=\"规则表述\"><a href=\"#规则表述\" class=\"headerlink\" title=\"规则表述\"></a>规则表述</h2><p>旅行者（玩家）可以通过祈愿机制获取“五星角色”“五星武器“”四星角色“”四星武器“来提高战斗力。其中，角色具有命之座机制，首次获得为0命，最高6命，命座数越高，角色越强；类似地，武器拥有精炼层数机制，首次获得为1阶，最高5阶。</p>\n<p>最近的版本更新中，《原神》的祈愿机制也发生了一定的变化。</p>\n<p>以下是《原神》两个祈愿机制的官方描述（<a href=\"https://ys.mihoyo.com/main/news/public%EF%BC%89%EF%BC%9A\">https://ys.mihoyo.com/main/news/public）：</a></p>\n<h3 id=\"角色祈愿\"><a href=\"#角色祈愿\" class=\"headerlink\" title=\"角色祈愿\"></a>角色祈愿</h3><p>**五星角色祈愿的基础概率为0.600%，综合概率（含保底）为1.600%**，最多90次祈愿必定能通过保底获取5星角色。</p>\n<p>当祈愿获取到5星角色时，有50.000%的概率为本期5星UP角色「A1」<em>（小保底）</em>。如果本次祈愿获取的5星角色非本期5星UP角色，下次祈愿获取的5星角色必定为本期5星UP角色<em>（大保底）</em>。</p>\n<p><strong>4星物品祈愿的基础概率为5.100%，4星角色祈愿的基础概率为2.550%，4星武器祈愿的基础概率为2.550%，4星物品祈愿的综合概率（含保底）为13.000%。</strong>最多10次祈愿必定能通过保底获取4星或以上物品，通过保底获取4星物品的概率为99.400%，获取5星物品的概率为0.600%。</p>\n<p>当祈愿获取到4星物品时，有50.000%的概率为本期4星UP角色「B」、「C」、「D」中的一个。如果本次祈愿获取的4星物品非本期4星UP角色，下次祈愿获取的4星物品必定为本期4星UP角色。当祈愿获取到4星UP物品时，每个本期4星UP角色的获取概率均等。</p>\n<p>角色祈愿包括「角色活动祈愿-1」和「角色活动祈愿-2」，祈愿次数和保底完全共享，共同累计。二者区别仅在于当期UP的五星角色不同。</p>\n<h3 id=\"武器祈愿\"><a href=\"#武器祈愿\" class=\"headerlink\" title=\"武器祈愿\"></a>武器祈愿</h3><p><strong>武器祈愿中，5星武器祈愿的基础概率为0.700%，综合概率（含保底）为1.850%，</strong>最多80次祈愿必定能通过保底获取5星武器。</p>\n<p>当祈愿获取到5星武器时，有75.000%的概率为本期5星UP武器「M」、「N」中的一个。如果本次祈愿获取的5星武器非本期5星UP武器，下次祈愿获取的5星武器必定为本期5星UP武器。</p>\n<p>【定轨机制】命定值：玩家可以指定一把本期5星UP武器（定轨）。当获取到的5星武器为非当前定轨武器时，获得1点命定值，命定值达到满值2后，在本祈愿中获得的下一把5星武器必定为当前定轨武器。获取到当前定轨武器时，无论当前命定值是否达到满值，都将会重置为0，重新累计。在未通过命定值达到满值获取定轨武器的情况下，当祈愿获取到5星UP物品时，每把本期5星UP武器的获取概率均等。</p>\n<p>未使用「神铸定轨」定轨武器时，将不会累积命定值。</p>\n<p><strong>4星物品祈愿的基础概率为6.000%，4星角色祈愿的基础概率为3.000%，4星武器祈愿的基础概率为3.000%，4星物品祈愿的综合概率（含保底）为14.500%。</strong>最多10次祈愿必定能通过保底获取4星或以上物品，通过保底获取4星物品的概率为99.300%，获取5星物品的概率为0.700%。</p>\n<p>当祈愿获取到4星物品时，有75.000%的概率为本期4星UP武器「F」、「G」、「H」、「J」、「K」中的一个。如果本次祈愿获取的4星物品非本期4星UP武器，下次祈愿获取的4星物品必定为本期4星UP武器。当祈愿获取到4星UP物品时，每把本期4星UP武器的获取概率均等。</p>\n<h1 id=\"角色祈愿分析\"><a href=\"#角色祈愿分析\" class=\"headerlink\" title=\"角色祈愿分析\"></a>角色祈愿分析</h1><h2 id=\"五星角色概率建模\"><a href=\"#五星角色概率建模\" class=\"headerlink\" title=\"五星角色概率建模\"></a>五星角色概率建模</h2><p>   前面的作业中，笔者通过运行代码和期望分析，对角色祈愿的机制进行了尝试1的模拟，简单回顾如下：</p>\n<h3 id=\"尝试1：89次伯努利实验\"><a href=\"#尝试1：89次伯努利实验\" class=\"headerlink\" title=\"尝试1：89次伯努利实验\"></a>尝试1：89次伯努利实验</h3><p>建模1：前89次祈愿，每次获得五星角色的概率均为0.6%，若前89次实验没有获得五星角色，则获取五星角色的概率为100%。</p>\n<p>则可以建模二项分布概率密度：</p>\n<p>$$ PDF(X = k) = (1-p)^{k-1}p(p = 0.6 %)$$</p>\n<p>$$ CDF(X = k) = (1 - p)^k$$</p>\n<p>计算每次获取五星角色的祈愿数期望：</p>\n<p>$$ E(X) = 90(1-CDF(89)) + \\sum_{i=1}^{89}iPDF(x=i)$$</p>\n<p>得到综合概率：</p>\n<p>$$P = \\frac{1}{E(X)} $$</p>\n<p>结果为：1.435%。（详见week9作业）</p>\n<p>与官方描述不符。实际上，官方提到的0.6%是基础概率，说明不是恒定概率的伯努利实验，于是提出模型2.</p>\n<h3 id=\"尝试2：概率递增的保底机制\"><a href=\"#尝试2：概率递增的保底机制\" class=\"headerlink\" title=\"尝试2：概率递增的保底机制\"></a>尝试2：概率递增的保底机制</h3><p>建模2：在一定抽数都没有得到五星角色后，获得五星角色概率开始线性上升，直到第90抽达到100%。 </p>\n<p>由于具体概率密度没有官方文档，只能站在前人的分析上，根据结合数据统计的开源项目（<a href=\"https://github.com/OneBST/GGanalysis%EF%BC%8C%E6%9C%AC%E6%96%87%E5%AE%9E%E9%99%85%E4%B8%8A%E7%9B%B8%E5%BD%93%E4%BA%8E%E6%A8%A1%E5%9E%8B%E7%9A%84%E5%A4%8D%E7%8E%B0%EF%BC%89%E9%87%87%E7%94%A8%E7%9A%84%E6%A8%A1%E5%9E%8B%EF%BC%8C%E7%AC%ACx%E6%AC%A1%E7%A5%88%E6%84%BF%E8%8E%B7%E5%BE%97%E4%BA%94%E6%98%9F%E8%A7%92%E8%89%B2%E7%9A%84%E6%A6%82%E7%8E%87%E5%A6%82%E4%B8%8B%EF%BC%9A\">https://github.com/OneBST/GGanalysis，本文实际上相当于模型的复现）采用的模型，第x次祈愿获得五星角色的概率如下：</a></p>\n<p>$$ P(x) = \\begin{cases} 0.6% &amp;{x&lt;=73}\\ 0.6% + 6%(x - 73) &amp;{74&lt;=x&lt;=89}\\1&amp;{x = 90} \\end{cases}$$</p>\n<p>由此，可以得到第x次祈愿得到五星角色的分布列（类似于几何分布）：</p>\n<p>$$ PDF(x) = P(x) * \\prod_{k = 1}^{x - 1}1-P(x) $$</p>\n<p>$$ PDF(x) = \\begin{cases} (1 - 0.6%)^{x-1}\\times0.6% &amp;{x\\leqslant73}\\ (1-0.6%)^{73} \\times \\sum_{k = 74}^{x} (1- 6%(k - 73))^{k-73}(6%(k-73)) &amp;{74\\leqslant x\\leqslant89}\\(1-0.6%)^{73} \\times \\sum_{k = 74}^{89} (1- 6%(k - 73))^{k-73}&amp;{x = 90} \\end{cases} $$</p>\n<p><strong>该模型平均获取五星角色的祈愿次数为62.3。</strong>该模型下五星角色的综合概率为1.605%。</p>\n<p>注：期望计算公式：</p>\n<p>$$ E(X) = \\sum_{i=1}^{x}PDF(x)\\times x $$</p>\n<h2 id=\"概率递增保底机制下的数字特征\"><a href=\"#概率递增保底机制下的数字特征\" class=\"headerlink\" title=\"概率递增保底机制下的数字特征\"></a>概率递增保底机制下的数字特征</h2><h3 id=\"求数据特征\"><a href=\"#求数据特征\" class=\"headerlink\" title=\"求数据特征\"></a>求数据特征</h3><p>在这里处理一个认识误区：期望 != 概率为50%的点（中分位点）。</p>\n<p>也就是说，期望作为概率的平均值，$ CDF(EX) = 0.5 $ <strong>是不成立的</strong>。 注意到这一前提，才能比较正确地理解下面的结论。</p>\n<p>由于其概率密度并不是均匀分布的，差别较大，选择平均数似乎不太合适。所以我们获取中分位点。根本不应该是程序员能写出来的粗糙代码验证：</p>\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">import numpy as np\nimport matplotlib as mlp\nimport matplotlib.pyplot as plt\nfrom matplotlib.pyplot import MultipleLocator\ndef p_5(n):\n    if n &lt; 73:\n        return 0.006\n    elif n &lt; 89:\n        return 0.006 + (n - 72) * 0.06\n    else:\n        return 1\n    \npdf_5 &#x3D; [];\ncdf_5 &#x3D; [];\ntmp &#x3D; 0.0;\n\nfor i in range (0,90):\n    tmp &#x3D; p_5(i);\n    for j in range(0,i):\n        tmp &#x3D; tmp * (1 - p_5(j))\n    pdf_5.append(tmp);\n#注：下文中其他代码可能要用到p_5,p_4函数,pdf_5列表哦\n\nfor i in range (0,90):\n    tmp &#x3D; 0.0;\n    for j in range (0,i+1):\n        tmp &#x3D; tmp + pdf_5[j];\n    cdf_5.append(tmp);\n    print(i+1,cdf_5[i])\n# out:\n#75 0.4739047630777248\n#76 0.571758477145268</code></pre>\n\n<p>该模型的概率密度函数（蓝线）和分布函数（黄线）图：</p>\n<p><img src=\"http://img.070077.xyz/%E5%8E%9F%E7%A5%9E%E6%8A%BD%E5%8D%A1%E6%A6%82%E7%8E%87%E5%88%86%E5%B8%83%E5%9B%BE.png\" alt=\"img\"></p>\n<p>我们不妨乐观一点，中分位点：75.</p>\n<p>注：最概然祈愿次数为77。也就是说，在第77次祈愿获取五星角色的概率最高。</p>\n<p>每次获得五星角色，需要的祈愿次数记为$N$. 则：</p>\n<ul>\n<li>从期望角度考虑，N = 62.3.</li>\n<li>从中分位点角度考虑，N = 75.</li>\n</ul>\n<p>实际理解为：需要75次祈愿，才能使获得5星角色的发生概率达到50%（实际：46.8%）。</p>\n<p>这种分布具有较强的右偏性。上面分析过，这两个数字特征具有不同的分析意义，可以理解为：</p>\n<ul>\n<li>祈愿623次，期望获得10个五星角色。（期望值）</li>\n<li>祈愿75次，能使获得五星角色的概率达到50%。</li>\n</ul>\n<h3 id=\"由期望特征进行资源规划\"><a href=\"#由期望特征进行资源规划\" class=\"headerlink\" title=\"由期望特征进行资源规划\"></a>由期望特征进行资源规划</h3><p>回到规则中，解决以下问题：</p>\n<h4 id=\"获得五星角色A的期望次数分析\"><a href=\"#获得五星角色A的期望次数分析\" class=\"headerlink\" title=\"获得五星角色A的期望次数分析\"></a>获得五星角色A的期望次数分析</h4><p>对于期望分析：注意到，对于获取当期UP五星角色，最多需要2次获得五星角色。也就是说，有50%的概率，仅需要获取一次五星角色；有50%的概率，需要获取2次五星角色。也就是说，需要获得五星角色的次数：</p>\n<p>$$ 1 \\times 50% + 2 \\times 50%  = 1.5 $$</p>\n<p>对于“获取五星角色”而言，多次获取（不论是否为当期UP角色）之间互相独立，因此需要的祈愿次数为$1.5 \\times 62.3 = 93.45$ 次。</p>\n<h4 id=\"获得6命座A角色的期望次数分析\"><a href=\"#获得6命座A角色的期望次数分析\" class=\"headerlink\" title=\"获得6命座A角色的期望次数分析\"></a>获得6命座A角色的期望次数分析</h4><p>注意到，对于“获取五星角色”而言，多次获取（不论是否为当期UP角色）之间互相独立。考虑这个问题：对于“获取A角色”事件之间，是相互独立的吗？</p>\n<p>从期望角度考虑，可以说：是的。参考上面的思路，只需要“获取A角色”发生7次即可。因此需要的祈愿次数为 $1.5N \\times 7 = 10.5N$ 也就是 654.15 次。</p>\n<h4 id=\"获得四星角色B的期望次数分析\"><a href=\"#获得四星角色B的期望次数分析\" class=\"headerlink\" title=\"获得四星角色B的期望次数分析\"></a>获得四星角色B的期望次数分析</h4><p>由于涉及“基础概率”，我们沿用上一开源项目模型的概率递增保底机制结论：</p>\n<ul>\n<li><p>从第9次祈愿处开始上升。</p>\n</li>\n<li><p>获得五星角色并不会重置四星保底。</p>\n</li>\n</ul>\n<p>第x次祈愿获得四星角色的概率如下：</p>\n<p>$$ P(x) = \\begin{cases} 5.1% &amp; {x\\leqslant8}\\ 56.1% &amp;{x = 9}\\1&amp;{x = 10} \\end{cases}$$</p>\n<p>$$ PDF(x) = P(x) * \\prod_{k = 1}^{x - 1}1-P(x)  = \\begin{cases} (1 - 5.1%)^{x-1}\\times5.1% &amp; {x\\leqslant8}\\ (1-5.1%)^8\\times56.1% &amp;{x=9}\\(1-5.1%)^8\\times43.9%&amp;{x = 10} \\end{cases}$$ </p>\n<p>期望值：</p>\n<p>$$ E(X) = \\sum_{i=1}^{x}PDF(x)\\times x = 7.66$$ </p>\n<p>综合概率：13.05%.</p>\n<p>对于期望分析：注意到，对于获取当期UP五星角色，仅有$\\frac{1}{3}$的概率得到当期UP的四星角色中的B，且每次获得当期四星角色时，有50%的概率，仅需要获取一次四星角色；有50%的概率，需要获取2次四星角色。也就是说，获得角色B的次数期望为$1.5 \\times 3 \\times E(X) = 34.5$ 。</p>\n<h3 id=\"由分位点特征进行分析\"><a href=\"#由分位点特征进行分析\" class=\"headerlink\" title=\"由分位点特征进行分析\"></a>由分位点特征进行分析</h3><p>从“概率的概率”角度分析便没有期望分析那么简单了。中位点与期望的乘积并不能得到叠加事件的中位点。基本上大部分分而治之的想法均不满足独立性要求。我们需要寻找更一般的数学模型：</p>\n<h4 id=\"获得多次五星角色的分位点分析\"><a href=\"#获得多次五星角色的分位点分析\" class=\"headerlink\" title=\"获得多次五星角色的分位点分析\"></a>获得多次五星角色的分位点分析</h4><p>接下来，由于<strong>使获得两次五星角色的概率达到50%的祈愿次数不等于获得一次五星角色祈愿次数的中位点的2倍</strong>，我们需要计算分布的<strong>叠加</strong>。</p>\n<p>我们从简单问题入手（自己编的）：</p>\n<p>(1) 一直抛硬币，直到总共出现2次正面朝上，求期望的抛硬币次数——显然是4.</p>\n<p>(2) 需要抛多少次硬币，使【至少出现2次正面朝上】的概率达到50%。</p>\n<p>(3) 需要抛多少次骰子，使【至少出现2次点数1】的概率达到50%。</p>\n<p>题目（2）（3）这类问题，可以转化成“几何分布的叠加问题”。这里的概率稳定<del>比较简单</del>，还可以参阅负二项分布有关资料。</p>\n<p>而对于的祈愿的建模，概率不稳定，有三种可能的思考方向：一可以用模拟动态规划处理，二是对各种情况进行全概率公式展开（<del>工作量极大</del>），三是离散信号的进行卷积运算:$P(Z=X+Y=z) = \\sum_1^\\infty PDF(X=z-y)P(X=y)$</p>\n<p>笔者采用第三种方法。</p>\n<p>各位修改一下代码的变量，即可获取想要的值。</p>\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">c5_need &#x3D; 2#需要抽出几次五星角色；\nc5_poss &#x3D; 0.25#想知道的概率;\nconv &#x3D; pdf_5;\nfor cnt in range(0,c5_need - 1):\n    conv&#x3D;np.convolve(conv,pdf_5,&#39;full&#39;)\n    plt.plot(conv)\n    tmp &#x3D; 0.0\n    for i in range (0,len(conv)):\n        tmp +&#x3D; conv[i]\n        if(cnt &#x3D;&#x3D; c5_need - 2 and tmp &gt;&#x3D; c5_poss):\n            print(i+c5_need);\n            break\n    #DEMO\n    #135 -- 需要祈愿135次，才有50%的概率获得两个五星角色。\n\t#祈愿154次，有75%的概率获得两个五星角色。</code></pre>\n\n<p>我对获得两次的情况列了个分布图：</p>\n<p><img src=\"http://img.070077.xyz/%E5%8E%9F%E7%A5%9E%E6%8A%BD%E5%8D%A12%E6%AC%A1%E4%BA%94%E6%98%9F%E6%A6%82%E7%8E%87%E5%88%86%E5%B8%83%E5%9B%BE.png\" alt=\"原神抽卡2次五星概率分布图\"></p>\n<h4 id=\"双角色池祈愿\"><a href=\"#双角色池祈愿\" class=\"headerlink\" title=\"双角色池祈愿\"></a>双角色池祈愿</h4><p>这个其实没什么太大的变化，把A2等价成A1，就可以和上文的A的结论统一了。</p>\n<h2 id=\"保底依赖下的分位点分析\"><a href=\"#保底依赖下的分位点分析\" class=\"headerlink\" title=\"保底依赖下的分位点分析\"></a>保底依赖下的分位点分析</h2><h3 id=\"尝试1：将“保底获得的五星”和“祈愿次数”拆成两个独立事件\"><a href=\"#尝试1：将“保底获得的五星”和“祈愿次数”拆成两个独立事件\" class=\"headerlink\" title=\"尝试1：将“保底获得的五星”和“祈愿次数”拆成两个独立事件\"></a>尝试1：将“保底获得的五星”和“祈愿次数”拆成两个独立事件</h3><h4 id=\"保底之间的马尔可夫过程\"><a href=\"#保底之间的马尔可夫过程\" class=\"headerlink\" title=\"保底之间的马尔可夫过程\"></a>保底之间的马尔可夫过程</h4><p>由于角色祈愿机制满足：本次获取五星角色是否为A的概率仅取决于上次获取的五星角色是否为A。符合马尔可夫过程（状态$i$只取决于上一次状态$i-1$，与再先前的状态相互独立。参：课本P321）的建模标准，可以做出以下状态图和概率转移矩阵：</p>\n<pre class=\"line-numbers language-mermaid\" data-language=\"mermaid\"><code class=\"language-mermaid\">graph LR\nA --1&#x2F;2--&gt; !A\n!A --1--&gt; A\nA --1&#x2F;2--&gt; A</code></pre>\n<p>$$ M = \\space \\begin{matrix}  &amp; A &amp; !A\\A &amp; {1}\\over{2} &amp; {1}\\over{2}\\!A &amp; 1 &amp; 0\\end{matrix}$$</p>\n<p>马尔可夫链在三门问题、经济学分析、自然语言处理等领域具有广泛的应用，在极值环境下具有平稳分布的特点。以下进行模拟分析。</p>\n<p>收敛的综合概率：$M^\\infty$。经过计算，可知A物品的综合概率为$\\frac{2}{3}$ 。这个计算结果可以理解为：任意一次获得五星角色，有$\\frac{2}{3}$的概率是A.（初始状况：刚获得A，以说明存在小保底）</p>\n<p>而对于中间情况的分析，可对应转换为矩阵的乘法和加法运算。</p>\n<p>但是我们很难把两个独立事件的概率组合到一起，以达到50%，请看下面的分析。</p>\n<h4 id=\"分类讨论的方式求取概率\"><a href=\"#分类讨论的方式求取概率\" class=\"headerlink\" title=\"分类讨论的方式求取概率\"></a>分类讨论的方式求取概率</h4><p>我们以抽到零命为例，对应的状态矩阵为$M$。因为初始状态（你可以理解为-1命）为A，此时可以理解为对应的概率为：$p_{11}P(获得一次五星) +p_{12}(获得二次五星)$，其中获得两次五星的概率模型可参考上面的卷积公式（由于二次五星也比较简单，大可自己分类讨论写）,如：</p>\n<p>$$ \\frac{1}{2}PDF(X) + \\frac{1}{2}PDF(Z)$$（注：x&gt;90的部分，记为0即可，因为那部分情况已结束。）</p>\n<p>验证这一方法的正确性：</p>\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">tmp &#x3D; 0.0\nfor i in range(0,179):\n    if(i&lt;90): tmp +&#x3D; 0.5 * pdf_5[i];\n    tmp+&#x3D;0.5*conv[i];\n    if(tmp&gt;&#x3D;0.5):\n        print(i);\n        break;\n&#x2F;&#x2F;沿用上方的数组了，输出为79.\n因为列表下标是从0开始计数的，79 &lt; 90 ，所以对应：80次祈愿可使抽到UP五星的概率达到50%。</code></pre>\n\n<p>如果需要制图，可以使用以下的画图模板代码</p>\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">#制图代码\nx_major_locator&#x3D;MultipleLocator(4)#x分度值设置\ny_major_locator&#x3D;MultipleLocator(0.1)\nax&#x3D;plt.gca()\nax.xaxis.set_major_locator(x_major_locator)\nax.yaxis.set_major_locator(y_major_locator)\nplt.grid()  # 生成网格\nx_values &#x3D; [x for x in range(1, 91)]\ny_values &#x3D; [pdf_5[x] for x in range(0, 90)]\nplt.plot(x_values,y_values)</code></pre>\n\n<p>如果是多命，则需要更复杂的分类讨论。如：一命的情况，就需要二次转移矩阵$M^2$的各项作为转移概率了，包括(A A ， A !A A ， !A A A ， !A A !A A)四种状态对应的状态转移概率，以及多次的卷积结果。由于前面代码没有记忆，就不尝试了。</p>\n<h3 id=\"尝试2：动态规划的角度\"><a href=\"#尝试2：动态规划的角度\" class=\"headerlink\" title=\"尝试2：动态规划的角度\"></a>尝试2：动态规划的角度</h3><h4 id=\"抽到多个五星角色中UP五星角色的个数概率\"><a href=\"#抽到多个五星角色中UP五星角色的个数概率\" class=\"headerlink\" title=\"抽到多个五星角色中UP五星角色的个数概率\"></a>抽到多个五星角色中UP五星角色的个数概率</h4><p>其实上面的转移矩阵比较简单，直接可以写出状态转移方程，考虑动态规划。</p>\n<p>定义状态$dp[i][j][1]$表示第 $i$ 次获得的五星角色时得到当期UP角色A后，共获得了$j$次A角色，达到$j-1$命 （第一次获得A角色达到0命）；类似地，$dp[i][j][0]$ 表示第 $i$ 次获得的五星角色不是A。</p>\n<p>则状态转移方程：</p>\n<p>$$ dp[i][j][0] = \\frac{1}{2}dp[i-1][j][1] $$</p>\n<p>$$ dp[i][j][1] = \\frac{1}{2}dp[i-1][j-1][1] + dp[i-1][j-1][0]$$</p>\n<p>起点：$dp[0][0][1] = 1$</p>\n<p>由此可以记$dp[i][j]$为第$i$次获得五星角色后共获得$j$次（及以上）A角色的概率，则：</p>\n<p>$$ dp[i][j] = \\sum_{k=j}^{i}dp[i][k][1]+dp[i][k][0] $$</p>\n<p>尝试构造含$i,j,dp[i][j]$三个变量的图：<img src=\"http://img.070077.xyz/%E5%8E%9F%E7%A5%9E%E5%91%BD%E5%BA%A7%E6%8A%BD%E6%95%B0%E6%A6%82%E7%8E%87%E5%88%86%E5%B8%83%E5%9B%BE.png\"></p>\n<p>由图中可以估计获取1~7次A角色时，使概率达到50%时，横坐标即为需要获得A角色的次数。（x，y）表示，已获得x次五星角色的情况下，y为对应的总共获取次数大于等于对应i的概率。</p>\n<h4 id=\"求取命座-祈愿次数概率\"><a href=\"#求取命座-祈愿次数概率\" class=\"headerlink\" title=\"求取命座-祈愿次数概率\"></a>求取命座-祈愿次数概率</h4><p>定义：$ dp[i][j][k] $ ：第j次祈愿的结果对应k，并第i次获得A角色的概率，则状态转移方程：</p>\n<ul>\n<li>大保底状态：上次五星!A，这次必获得A；</li>\n<li>小保底状态：上次五星是A（初始状态），这次只有50%的概率获得A。</li>\n<li>k = 0 ： 获得五星角色A</li>\n<li>k = 1 ： 获得五星角色且!A</li>\n</ul>\n<p>（临时变量：tmp：上次获得五星的祈愿次数）</p>\n<ul>\n<li>注意：要明确状态转移的结果“from to”。循环遍历时，由j逐步+k确定后续值并进行迭代赋值，会导致一个点的值多次计入概率，所以最后取概率只需要取[0]</li>\n</ul>\n<p>$$ dp[i][j][0] = dp[i-1][tmp][1] * PDF(j-tmp) + dp[i-1][tmp][0] * \\frac{1}{2} * PDF(j-tmp)$$</p>\n<p>$$ dp[i][j][1] = dp[i][tmp][0] * \\frac{1}{2} * PDF(j-tmp)$$</p>\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">n5_cnt&#x3D;1;#要抽出多少次A\nn5_tries&#x3D;180;#准备的祈愿次数\ntmp &#x3D; 0;\ndp_p &#x3D; np.zeros((13, 180*n5_cnt+90,2), dtype&#x3D;float);\ndp_p[0][0][0] &#x3D; 1\nfor i in range (0,n5_cnt+1):\n        for j in range (0,n5_tries):\n            for k in range (1,91):\n                if(i-1&gt;&#x3D;0):\n                    dp_p[i][j+k][0] +&#x3D; dp_p[i-1][j][1] * pdf_5[k-1] + dp_p[i-1][j][0] * 0.5 * pdf_5[k-1];\n                dp_p[i][j+k][1] +&#x3D; dp_p[i][j][0] * 0.5 * pdf_5[k-1]\nposs&#x3D;[]\nfor i in range(0,n5_tries):\n    tmp &#x3D; tmp + dp_p[n5_cnt][i][0]\n    poss.append(tmp)\nprint(tmp)\nplt.plot(poss)\n#DEMO:0.4762677010731945</code></pre>\n\n<p> 与上面的卷积验证是一致的。</p>\n<p>0命概率图：<img src=\"http://img.070077.xyz/%E5%8E%9F%E7%A5%9E%E6%8A%BD%E5%8D%A12%E6%AC%A1%E4%BA%94%E6%98%9F%E6%A6%82%E7%8E%87%E5%88%86%E5%B8%83%E5%9B%BE.1png.png\" alt=\"原神抽卡2次五星概率分布图.1png\"></p>\n<h4 id=\"非默认状态开始的动态规划（To-Be-Continued…）\"><a href=\"#非默认状态开始的动态规划（To-Be-Continued…）\" class=\"headerlink\" title=\"非默认状态开始的动态规划（To Be Continued…）\"></a>非默认状态开始的动态规划（To Be Continued…）</h4><p>如果开始状态为大保底状态，或已经有一定的祈愿次数呢？以后再写。</p>\n<h2 id=\"四星角色祈愿分析\"><a href=\"#四星角色祈愿分析\" class=\"headerlink\" title=\"四星角色祈愿分析\"></a>四星角色祈愿分析</h2><p>预设：获取到五星时，不会重置四星角色的保底。且，以下策略，如果出了五星角色，先笑一笑，算法就当没祈愿哈~</p>\n<h3 id=\"概览\"><a href=\"#概览\" class=\"headerlink\" title=\"概览\"></a>概览</h3><p>四星的分析只需要将上面的p_5相关改成p_4即可，在此省略不表，给出一定结论：<img src=\"http://img.070077.xyz/%E5%8E%9F%E7%A5%9E%E5%9B%9B%E6%98%9F%E8%A7%92%E8%89%B2pdfcdf.png\" alt=\"原神四星角色pdfcdf\"></p>\n<p>0命图：<img src=\"http://img.070077.xyz/%E5%8E%9F%E7%A5%9E4%E6%98%9F0%E5%91%BD%E6%8A%BD%E6%95%B0%E6%A6%82%E7%8E%87%E5%88%86%E5%B8%83%E5%9B%BE.png\" alt=\"原神4星0命抽数概率分布图\"></p>\n<h3 id=\"算法\"><a href=\"#算法\" class=\"headerlink\" title=\"算法\"></a>算法</h3><p>定义：$ dp[i][j][k] $ ：第j次祈愿的结果对应k，并第i次获得B角色的概率，则状态转移方程：</p>\n<ul>\n<li>保底状态：上次四星!UP，这次必获得UP角色</li>\n<li>k = 0 ： 获得想要的四星角色B</li>\n<li>k = 1 ： 获得UP四星角色但不是B</li>\n<li>k = 2：获得非UP四星角色</li>\n</ul>\n<p>（临时变量：tmp：上次获得四星的祈愿次数）</p>\n<p>$$ dp[i][j][0] = dp[i-1][tmp][1] * PDF(j-tmp) * \\frac{1}{6} \\+ dp[i-1][tmp][0] * \\frac{1}{6} * PDF(j-tmp) \\+ dp[i-1][tmp][1] * PDF(j-tmp) * \\frac{1}{3}$$</p>\n<p>$$ dp[i][j][1] = dp[i][tmp][0] * \\frac{1}{3} * PDF(j-tmp) \\+ dp[i][tmp][1] * PDF(j-tmp) * \\frac{1}{3} \\+  dp[i][tmp][2] * \\frac{2}{3} * PDF(j-tmp)$$</p>\n<p>$$ dp[i][j][2] = dp[i][tmp][0] * \\frac{1}{2} * PDF(j-tmp) + dp[i][tmp][1] * \\frac{1}{2} * PDF(j-tmp)$$</p>\n<p>任意代码：（原理与下方“无定轨机制武器祈愿”类似，这里人比较懒，直接对p_5移花接木了）</p>\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">#每抽概率\n#这是研究四星的，但是为了偷懒，捏：\ndef p_5(n):\n    if n &lt; 8:\n        return 0.051;\n    elif n &lt; 9:\n        return 0.561;\n    else:\n        return 1;\n        \npdf_5 &#x3D; [];\ncdf_5 &#x3D; [];\ntmp &#x3D; 0.0;\n\nfor i in range (0,10):\n    tmp &#x3D; p_5(i);\n    for j in range(0,i):\n        tmp &#x3D; tmp * (1 - p_5(j))\n    pdf_5.append(tmp);\n\nfor i in range (0,10):\n    tmp &#x3D; 0.0;\n    for j in range (0,i+1):\n        tmp &#x3D; tmp + pdf_5[j];\n    cdf_5.append(tmp);\n    print(i+1,cdf_5[i])\n \nn5_cnt&#x3D;1#要抽出多少次B\nn5_tries&#x3D;130 * n5_cnt;#准备的祈愿次数\ntmp &#x3D; 0;\ndp_p &#x3D; np.zeros((13, 150*n5_cnt + 20,3), dtype&#x3D;float);\ndp_p[0][0][0] &#x3D; 1\n# 0 - B 1 - UP &amp; !B 2- !UP\nfor i in range (0,n5_cnt+1):\n        for j in range (0,n5_tries):\n            for k in range (1,11):\n                if(i-1&gt;&#x3D;0):\n                    dp_p[i][j+k][0] +&#x3D; dp_p[i-1][j][2] * pdf_5[k-1] * 1&#x2F;3\\\n                                    + dp_p[i-1][j][1] * pdf_5[k-1] * 1&#x2F;6 + dp_p[i-1][j][0] * 1&#x2F;6 * pdf_5[k-1];\n                dp_p[i][j+k][1] +&#x3D; dp_p[i][j][0] * 1&#x2F;3 * pdf_5[k-1] + dp_p[i][j][2] * 2&#x2F;3 * pdf_5[k-1]\\\n                                + dp_p[i][j][1] * 1&#x2F;3 * pdf_5[k-1];\n                dp_p[i][j+k][2] +&#x3D; dp_p[i][j][0] * 1&#x2F;2 * pdf_5[k-1] + dp_p[i][j][1] * 1&#x2F;2 * pdf_5[k-1];\nposs&#x3D;[]\nfor i in range(0,n5_tries):\n    tmp &#x3D; tmp + dp_p[n5_cnt][i][0]\n    poss.append(tmp)\nprint(tmp)\n#制图代码，直接cv用\nx_major_locator&#x3D;MultipleLocator(10)#x分度值设置\ny_major_locator&#x3D;MultipleLocator(0.1)\nax&#x3D;plt.gca()\nax.xaxis.set_major_locator(x_major_locator)\nax.yaxis.set_major_locator(y_major_locator)\nx_values &#x3D; [x for x in range(1, n5_tries)]\nplt.grid()  # 生成网格\nplt.plot(poss)  </code></pre>\n\n\n\n<h2 id=\"不同模型对比研究\"><a href=\"#不同模型对比研究\" class=\"headerlink\" title=\"不同模型对比研究\"></a>不同模型对比研究</h2><h3 id=\"与无保底机制（均匀1-6-）的对比\"><a href=\"#与无保底机制（均匀1-6-）的对比\" class=\"headerlink\" title=\"与无保底机制（均匀1.6%）的对比\"></a>与无保底机制（均匀1.6%）的对比</h3><p>​    修改</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">def p_5(n):\n\treturn 0.016;</code></pre>\n\n<p>期望：不变；</p>\n<p>分位点图：<img src=\"http://img.070077.xyz/%E5%9D%87%E5%8C%801.6%E5%8E%9F%E7%A5%9E%E6%8A%BD%E5%8D%A1%E6%A6%82%E7%8E%87%E5%88%86%E5%B8%83%E5%9B%BE.png\" alt=\"均匀1.6原神抽卡概率分布图\"></p>\n<p>极端情况上升了~</p>\n<p>两次五星分布图：<img src=\"http://img.070077.xyz/%E5%9D%87%E5%8C%801.6%E5%8E%9F%E7%A5%9E%E6%8A%BD%E5%8D%A12%E6%AC%A1%E4%BA%94%E6%98%9F%E6%A6%82%E7%8E%87%E5%88%86%E5%B8%83%E5%9B%BE.png\" alt=\"均匀1.6原神抽卡2次五星概率分布图\"></p>\n<p>一命概率分布图：<img src=\"http://img.070077.xyz/%E5%9D%87%E5%8C%801.6%E5%8E%9F%E7%A5%9E%E6%8A%BD%E5%8D%A1%E4%B8%80%E5%91%BD%E6%A6%82%E7%8E%87%E5%88%86%E5%B8%83%E5%9B%BE.png\" alt=\"均匀1.6原神抽卡一命概率分布图\"></p>\n<p>可以发现，均匀和非均匀，有利有弊吧。</p>\n<h3 id=\"与保底前均匀机制（魔改尝试1）的对比\"><a href=\"#与保底前均匀机制（魔改尝试1）的对比\" class=\"headerlink\" title=\"与保底前均匀机制（魔改尝试1）的对比\"></a>与保底前均匀机制（魔改尝试1）的对比</h3><p>用我比较熟悉的c++建模以下（其实更精确的值为0.88%）</p>\n<p>$$  P(x) = \\begin{cases} 0.9% &amp;{x\\leqslant 89}\\1&amp;{x = 90} \\end{cases} $$</p>\n<p>期望：62.06（综合概率：1.61%）</p>\n<p>分位点分布图：</p>\n<p><img src=\"http://img.070077.xyz/%E9%AD%94%E6%94%B91.6%E5%8E%9F%E7%A5%9E%E6%8A%BD%E5%8D%A1%E6%A6%82%E7%8E%87%E5%88%86%E5%B8%83%E5%9B%BE.png\" alt=\"魔改1.6原神抽卡概率分布图\"></p>\n<p>两次五星分布图：<img src=\"http://img.070077.xyz/%E9%AD%94%E6%94%B91.6%E5%8E%9F%E7%A5%9E%E6%8A%BD%E5%8D%A12%E6%AC%A1%E4%BA%94%E6%98%9F%E6%A6%82%E7%8E%87%E5%88%86%E5%B8%83%E5%9B%BE.png\" alt=\"魔改1.6原神抽卡2次五星概率分布图\"></p>\n<p>一命概率分布图：<img src=\"http://img.070077.xyz/%E9%AD%94%E6%94%B91.6%E5%8E%9F%E7%A5%9E%E6%8A%BD%E5%8D%A1%E4%B8%80%E5%91%BD%E6%A6%82%E7%8E%87%E5%88%86%E5%B8%83%E5%9B%BE.png\" alt=\"魔改1.6原神抽卡一命概率分布图\"></p>\n<p>会让更多人吃保底~</p>\n<h1 id=\"武器祈愿分析\"><a href=\"#武器祈愿分析\" class=\"headerlink\" title=\"武器祈愿分析\"></a>武器祈愿分析</h1><h2 id=\"概率递增保底机制及数字特征\"><a href=\"#概率递增保底机制及数字特征\" class=\"headerlink\" title=\"概率递增保底机制及数字特征\"></a>概率递增保底机制及数字特征</h2><p>武器祈愿的机制和角色祈愿大体一致。算法参上，在此直接给出结论。</p>\n<p>五星武器概率：</p>\n<p>$$P(x) = \\begin{cases}0.7% &amp; x\\leqslant62\\0.7%+7%(x-62) &amp; 63\\leqslant x \\leqslant 71\\ 63.7% + 3.5%(x-71) &amp; 72\\leqslant x \\leqslant 79 \\ 1 &amp; x=80\\end{cases}$$ </p>\n<p>数学期望：54.25.</p>\n<p>综合概率：1.88%</p>\n<p>分布图：<img src=\"http://img.070077.xyz/%E5%8E%9F%E7%A5%9E%E6%AD%A6%E5%99%A8%E6%8A%BD%E5%8D%A1%E6%A6%82%E7%8E%87%E5%88%86%E5%B8%83%E5%9B%BE.png\" alt=\"原神武器抽卡概率分布图\"></p>\n<p>四星武器概率</p>\n<p>$$P(x) = \\begin{cases}6% &amp; x\\leqslant 7\\66% &amp; x = 8 \\ 96% &amp; x = 9 \\ 1 &amp; x=10\\end{cases}$$</p>\n<p>数学期望：6.74.</p>\n<p>综合概率：14.84%。</p>\n<p>你会发现，分成了四段，复杂了一点。</p>\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">#每抽概率\ndef p_5(n):\n    if n &lt; 62:\n        return 0.007;\n    elif n &lt; 71:\n        return 0.007 + (n - 62) * 0.07;\n    elif n &lt; 79:\n        return 0.637 + (n - 71) * 0.035;\n    else:\n        return 1.0;\ndef p_4(n):\n    if n &lt; 7:\n        return 0.06\n    elif n &lt; 8:\n        return 0.66\n    elif n &lt; 9:\n        return 0.96;\n    else:\n        return 1;\npdf_5 &#x3D; [];#第x+1抽出概率\ncdf_5 &#x3D; [];\ntmp &#x3D; 0.0;\n\nfor i in range (0,80):\n    tmp &#x3D; p_5(i);\n    for j in range(0,i):\n        tmp &#x3D; tmp * (1.0 - p_5(j))\n    pdf_5.append(tmp);\n\nfor i in range (0,80):\n    tmp &#x3D; 0.0;\n    for j in range (0,i+1):\n        tmp &#x3D; tmp + pdf_5[j];\n    cdf_5.append(tmp);\n    print(i+1,cdf_5[i])</code></pre>\n\n\n\n<h2 id=\"定轨机制下的资源规划（假设定轨M）\"><a href=\"#定轨机制下的资源规划（假设定轨M）\" class=\"headerlink\" title=\"定轨机制下的资源规划（假设定轨M）\"></a>定轨机制下的资源规划（假设定轨M）</h2><h3 id=\"获取五星武器M的祈愿次数分析\"><a href=\"#获取五星武器M的祈愿次数分析\" class=\"headerlink\" title=\"获取五星武器M的祈愿次数分析\"></a>获取五星武器M的祈愿次数分析</h3><p>由于命定值机制，马尔可夫过程比较复杂。于是考虑动态规划：</p>\n<p>定义$dp[i][j][k]$为第j次祈愿时第i次获得五星武器M，祈愿后k：</p>\n<ul>\n<li>k = 0 : 命定值为0。表示抽到了M.</li>\n<li>k = 1：命定值为1且抽到了N.</li>\n<li>k = 2：命定值为1且抽到的是非UP武器。</li>\n<li>k = 3：命定值为2，抽出来的不是M，具体是啥在本小节中不相关。</li>\n</ul>\n<p>$$ dp[i][j][0] = dp[i-1][tmp][0] * \\frac{3}{8} *PDF(j-tmp) \\+ dp[i-1][tmp][1] * \\frac{3}{8} * PDF(j-tmp) \\+ dp[i-1][tmp][2] * \\frac{1}{2}*PDF(j-tmp) \\+ dp[i-1][tmp][3] *PDF(j-tmp)$$</p>\n<p>$$ dp[i][j][1] = dp[i][tmp][0] <em>\\frac{1}{4}</em> PDF(j-tmp)$$</p>\n<p>$$ dp[i][j][2] = dp[i][tmp][0] <em>\\frac{3}{8}</em> PDF(j-tmp)$$</p>\n<p>$$ dp[i][j][3] = dp[i][tmp][1] * ( \\frac{3}{8} + \\frac{1}{4}) *PDF(j-tmp) \\ + dp[i][tmp][2] * \\frac{1}{2} * PDF(j-tmp)$$</p>\n<p>运行代码：</p>\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">n5_cnt&#x3D;2;#要抽出多少次M\nn5_tries&#x3D; 207;#准备的祈愿次数\ntmp &#x3D; 0;\ndp_p &#x3D; np.zeros((13, 330*n5_cnt,5), dtype&#x3D;float);\ndp_p[0][0][0] &#x3D; 1\nfor i in range (0,n5_cnt+1):\n        for j in range (0,n5_tries + n5_cnt + 1):\n            for k in range (1,81):\n                if(i-1&gt;&#x3D;0):\n                    dp_p[i][j+k][0] +&#x3D; dp_p[i-1][j][0] * pdf_5[k-1] * 0.375\\\n                                + dp_p[i-1][j][1] * 0.375 * pdf_5[k-1] \\\n                                + dp_p[i-1][j][2] * 0.5 * pdf_5[k-1]\\\n                                + dp_p[i-1][j][3] * pdf_5[k-1];\n                dp_p[i][j+k][1] +&#x3D; dp_p[i][j][0] * 0.25 * pdf_5[k-1];\n                dp_p[i][j+k][2] +&#x3D; dp_p[i][j][0] * 0.375 * pdf_5[k-1];\n                dp_p[i][j+k][3] +&#x3D; dp_p[i][j][1] * 0.625 * pdf_5[k-1]\\\n                                + dp_p[i][j][2] * 0.5 * pdf_5[k-1];\nposs&#x3D;[]\nfor i in range(0,n5_tries):\n    tmp &#x3D; tmp + dp_p[n5_cnt][i][0]\n    poss.append(tmp)\nprint(tmp)\nplt.plot(poss)\n#0.49317051582855165</code></pre>\n\n<p>进行99次祈愿后，获得M的概率达到50%。以下是获取一次武器M的概率分布图：</p>\n<p><img src=\"http://img.070077.xyz/%E5%8E%9F%E7%A5%9E%E6%AD%A6%E5%99%A8m%E6%8A%BD%E5%8D%A1%E6%A6%82%E7%8E%87%E5%88%86%E5%B8%83%E5%9B%BE.png\" alt=\"原神武器m抽卡概率分布图\"></p>\n<h3 id=\"获取五星武器N的祈愿次数分析\"><a href=\"#获取五星武器N的祈愿次数分析\" class=\"headerlink\" title=\"获取五星武器N的祈愿次数分析\"></a>获取五星武器N的祈愿次数分析</h3><p>问题：我定轨了M，反而想获取五星武器N…（反向定轨）</p>\n<p>定义$dp[i][j][k]$为第j次祈愿时第i次获得五星武器N，祈愿后k：</p>\n<ul>\n<li>k = 0 : 命定值为0。表示抽到了M.</li>\n<li>k = 1：命定值为1且抽到了N.</li>\n<li>k = 2：命定值为1且抽到的是非UP武器。</li>\n<li>k = 3：命定值为2，且抽到了N.</li>\n<li>k = 4：命定值为2，且抽到的是非UP武器。</li>\n</ul>\n<p>$$ dp[i][j][0] = dp[i][tmp][0] * \\frac{3}{8} *PDF(j-tmp) \\ + dp[i][tmp][1] * \\frac{3}{8} * PDF(j-tmp) \\+ dp[i][tmp][2] * \\frac{1}{2}*PDF(j-tmp) \\+ dp[i][tmp][3] * PDF(j-tmp) \\ + dp[i][tmp][4] * PDF(j-tmp)$$</p>\n<p>$$ dp[i][j][1] = dp[i-1][tmp][0] <em>\\frac{3}{8}</em> PDF(j-tmp)$$</p>\n<p>$$ dp[i][j][2] = dp[i][tmp][0] <em>\\frac{1}{4}</em> PDF(j-tmp)$$</p>\n<p>$$ dp[i][j][3] = dp[i-1][tmp][1] * ( \\frac{3}{8}) * PDF(j-tmp) \\ + dp[i-1][tmp][2] * \\frac{1}{2} * PDF(j-tmp)$$</p>\n<p>$$ dp[i][j][4] = dp[i][tmp][1] * \\frac{1}{4} * PDF(j-tmp)$$</p>\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">n5_cnt&#x3D;1;#要抽出多少次N\nn5_tries&#x3D; 106;#准备的祈愿次数\ntmp &#x3D; 0;\ndp_p &#x3D; np.zeros((13, 510*n5_cnt + 80,5), dtype&#x3D;float);\ndp_p[0][0][0] &#x3D; 1\nfor i in range (0,n5_cnt+1):\n        for j in range (0,n5_tries + n5_cnt + 1):\n            for k in range (1,81):\n                dp_p[i][j+k][0] +&#x3D; dp_p[i][j][0] * pdf_5[k-1] * 0.375\\\n                                + dp_p[i][j][1] * 0.375 * pdf_5[k-1] \\\n                                + dp_p[i][j][2] * 0.5 * pdf_5[k-1]\\\n                                + dp_p[i][j][3] * pdf_5[k-1]\\\n                                + dp_p[i][j][4] * pdf_5[k-1];\n                dp_p[i][j+k][1] +&#x3D; dp_p[i-1][j][0] * 0.375 * pdf_5[k-1];\n                dp_p[i][j+k][2] +&#x3D; dp_p[i][j][0] * 0.25 * pdf_5[k-1];\n                dp_p[i][j+k][3] +&#x3D; dp_p[i-1][j][1] * 0.375 * pdf_5[k-1]\\\n                                + dp_p[i-1][j][2] * 0.5 * pdf_5[k-1];\n                dp_p[i][j+k][4] +&#x3D; dp_p[i][j][1] * 0.25 * pdf_5[k-1]\nposs&#x3D;[]\nfor i in range(0,n5_tries):\n    tmp &#x3D; tmp + dp_p[n5_cnt][i][1] + dp_p[n5_cnt][i][3]\n    poss.append(tmp)\nprint(tmp)\n#DEMO:0.5007747697175682</code></pre>\n\n<p>图表</p>\n<p>​    <img src=\"http://img.070077.xyz/%E5%8E%9F%E7%A5%9E%E6%AD%A6%E5%99%A8n%E6%8A%BD%E5%8D%A1%E6%A6%82%E7%8E%87%E5%88%86%E5%B8%83%E5%9B%BE.png\" alt=\"原神武器n抽卡概率分布图\"></p>\n<h3 id=\"获取五星武器M、N的祈愿次数分析（To-Be-Updated…\"><a href=\"#获取五星武器M、N的祈愿次数分析（To-Be-Updated…\" class=\"headerlink\" title=\"获取五星武器M、N的祈愿次数分析（To Be Updated…)\"></a>获取五星武器M、N的祈愿次数分析（To Be Updated…)</h3><p>问题：我定轨了M，但M、N都想要。</p>\n<p>我可能比较蠢：四维动态规划？</p>\n<p>定义$dp[h][i][j][k]$为第j次祈愿时第i次获得五星武器N，第h获得五星武器M，祈愿后k：……（同上）</p>\n<p>呃，我们先不考虑土豪了哈，我们只考虑都只获得1次的情况，只需要把<code>tmp = tmp + dp_p[n5_cnt][i][1] + dp_p[n5_cnt][i][3]</code> 再加一项 <code>dp_p[n5_cnt][i][0]</code> ？</p>\n<p>我也希望这能成功，但是这么直接地不可行，因为前面那两项的概率本身就包含了上一次抽到M的情况，再加会导致重复计算，我没想到别的方式改良之。</p>\n<p>另一种思路是分类讨论了，分为先获得M后获得N、先获得N再获得M两种情况。</p>\n<p>再者就是还是含泪：</p>\n<ul>\n<li>需要做出一定的修改，使状态转移时，不忽略h的出现次数。</li>\n</ul>\n<p>$$ dp[h][i][j][0] = dp[h-1][i][tmp][0] * \\frac{3}{8} *PDF(j-tmp) \\ + dp[h-1][i][tmp][1] * \\frac{3}{8} * PDF(j-tmp) \\+ dp[h-1][i][tmp][2] * \\frac{1}{2}*PDF(j-tmp) \\+ dp[h-1][i][tmp][3] * PDF(j-tmp) \\ + dp[h-1][i][tmp][4] * PDF(j-tmp)$$</p>\n<p>$$ dp[h][i][j][1] = dp[h][i-1][tmp][0] <em>\\frac{3}{8}</em> PDF(j-tmp)$$</p>\n<p>$$ dp[h][i][j][2] = dp[h][i][tmp][0] <em>\\frac{1}{4}</em> PDF(j-tmp)$$</p>\n<p>$$ dp[h][i][j][3] = dp[h][i-1][tmp][1] * ( \\frac{3}{8}) * PDF(j-tmp) \\ + dp[h][i-1][tmp][2] * \\frac{1}{2} * PDF(j-tmp)$$</p>\n<p>$$ dp[h][i][j][4] = dp[h][i][tmp][1] * \\frac{1}{4} * PDF(j-tmp)$$</p>\n<p>事实证明上面的方法不一定获得了正确答案。这个错误是没有价值的吗，不，他可能会给一个同样想研究这一问题的人一个参考。于是提出下面的形式：</p>\n<p>定义$dp[i][j][k]$为第j次祈愿时，i - 获得的目标种类数 , 祈愿后k同上。</p>\n<p>其实关键原因和上面的“加一项”一样，就是因为最后获取概率时，需要涵盖多个状态。以前的动态规划获取概率时，获取的状态间互相不存在依赖，而这次获取概率时，各个状态内部的转移存在相关。</p>\n<p>最近灵感较为枯竭，先赶别的ddl了。在此附上可能是错误的代码（若考虑较大次数，可能需修改码参数/概率不准确）和运行结果：</p>\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">n5_cnt_M&#x3D;1;#要抽出多少次M,N\nn5_cnt_N&#x3D;1;\nn5_cnt&#x3D;n5_cnt_M + n5_cnt_N;\nn5_tries&#x3D; 180*n5_cnt;#准备的祈愿次数\ntmp &#x3D; 0;\ndp_p &#x3D; np.zeros((13,13, 310*n5_cnt + 80,5), dtype&#x3D;float);\ndp_p[0][0][0][0] &#x3D; 1\n\nh &#x3D; 0;\nfor h in range (0,3*n5_cnt_M +1):\n    for i in range(0,3*n5_cnt_N+1):\n        for j in range (0,n5_tries + n5_cnt + 1):\n            for k in range (1,81):\n                    dp_p[h][i][j+k][0] +&#x3D; dp_p[h-1][i][j][0] * pdf_5[k-1] * 0.375\\\n                                + dp_p[h-1][i][j][1] * 0.375 * pdf_5[k-1] \\\n                                + dp_p[h-1][i][j][2] * 0.5 * pdf_5[k-1]\\\n                                + dp_p[h-1][i][j][3] * pdf_5[k-1]\\\n                                + dp_p[h-1][i][j][4] * pdf_5[k-1];\n                    dp_p[h][i][j+k][1] +&#x3D; dp_p[h][i-1][j][0] * 0.375 * pdf_5[k-1];\n                    dp_p[h][i][j+k][2] +&#x3D; dp_p[h][i][j][0] * 0.25 * pdf_5[k-1];\n                    dp_p[h][i][j+k][3] +&#x3D; dp_p[h][i-1][j][1] * 0.375 * pdf_5[k-1]\\\n                                + dp_p[h][i-1][j][2] * 0.5 * pdf_5[k-1];\n                    dp_p[h][i][j+k][4] +&#x3D; dp_p[h][i][j][1] * 0.25 * pdf_5[k-1]\n\nposs&#x3D;[]\nfor i in range(0,n5_tries):\n    for i1 in range (n5_cnt_M,3*n5_cnt_M+1):\n        tmp +&#x3D; dp_p[i1][n5_cnt_N][i][1] + dp_p[i1][n5_cnt_N][i][3]\n    for i2 in range(n5_cnt_N,3*n5_cnt_N+1):\n        tmp +&#x3D; dp_p[n5_cnt_M][i2][i][0];\n    poss.append(tmp)\nprint(tmp)\n#制图代码，直接cv用\nx_major_locator&#x3D;MultipleLocator(20)#x分度值设置\ny_major_locator&#x3D;MultipleLocator(0.1)\nax&#x3D;plt.gca()\nax.xaxis.set_major_locator(x_major_locator)\nax.yaxis.set_major_locator(y_major_locator)\nplt.grid()  # 生成网格\nplt.plot(poss)</code></pre>\n\n<p><img src=\"http://img.070077.xyz/%E5%8E%9F%E7%A5%9E%E6%AD%A6%E5%99%A8m%E4%B8%94n%E6%8A%BD%E5%8D%A1%E6%A6%82%E7%8E%87%E5%88%86%E5%B8%83%E5%9B%BE.png\" alt=\"原神武器m且n抽卡概率分布图\"></p>\n<p>拓展问题：我先定轨了M，获取M后定轨N（命定值清零），参考上面两个问题叠加应该可以。</p>\n<h3 id=\"四星武器的分析\"><a href=\"#四星武器的分析\" class=\"headerlink\" title=\"四星武器的分析\"></a>四星武器的分析</h3><p>和上面四星角色祈愿分析思想一致。</p>\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">#偷懒：p_5的内容实际是p_4\nn5_cnt&#x3D;1#要抽出多少次F\nn5_tries&#x3D;130 * n5_cnt;#准备的祈愿次数\ntmp &#x3D; 0;\ndp_p &#x3D; np.zeros((13, 150*n5_cnt + 20,3), dtype&#x3D;float);\ndp_p[0][0][0] &#x3D; 1\n# 0 - F 1 - UP &amp; !F 2- !UP\nfor i in range (0,n5_cnt+1):\n        for j in range (0,n5_tries):\n            for k in range (1,11):\n                if(i-1&gt;&#x3D;0):\n                    dp_p[i][j+k][0] +&#x3D; dp_p[i-1][j][2] * pdf_5[k-1] * 1&#x2F;5\\\n                                    + dp_p[i-1][j][1] * pdf_5[k-1] * 3&#x2F;20 + dp_p[i-1][j][0] * 3&#x2F;20 * pdf_5[k-1];\n                dp_p[i][j+k][1] +&#x3D; dp_p[i][j][0] * 3&#x2F;5 * pdf_5[k-1] + dp_p[i][j][2] * 4&#x2F;5 * pdf_5[k-1]\\\n                                + dp_p[i][j][1] * 3&#x2F;5 * pdf_5[k-1];\n                dp_p[i][j+k][2] +&#x3D; dp_p[i][j][0] * 1&#x2F;4 * pdf_5[k-1] + dp_p[i][j][1] * 1&#x2F;4 * pdf_5[k-1];\nposs&#x3D;[]\nfor i in range(0,n5_tries):\n    tmp &#x3D; tmp + dp_p[n5_cnt][i][0]\n    poss.append(tmp)\nprint(tmp)\n#制图代码，直接cv用\nx_major_locator&#x3D;MultipleLocator(10)#x分度值设置\ny_major_locator&#x3D;MultipleLocator(0.1)\nax&#x3D;plt.gca()\nax.xaxis.set_major_locator(x_major_locator)\nax.yaxis.set_major_locator(y_major_locator)\nx_values &#x3D; [x for x in range(1, n5_tries)]\nplt.grid()  # 生成网格\nplt.plot(poss)  </code></pre>\n\n<p><img src=\"http://img.070077.xyz/%E5%8E%9F%E7%A5%9E%E5%9B%9B%E6%98%9F%E6%AD%A6%E5%99%A8f%E6%8A%BD%E5%8D%A1%E6%A6%82%E7%8E%87%E5%88%86%E5%B8%83%E5%9B%BE.png\" alt=\"原神四星武器f抽卡概率分布图\"></p>\n<h2 id=\"无定轨机制下武器祈愿分析\"><a href=\"#无定轨机制下武器祈愿分析\" class=\"headerlink\" title=\"无定轨机制下武器祈愿分析\"></a>无定轨机制下武器祈愿分析</h2><p>和上面四星角色祈愿分析思想一致。<img src=\"http://img.070077.xyz/%E5%8E%9F%E7%A5%9E%E6%AD%A6%E5%99%A8m%E4%B8%8D%E5%AE%9A%E8%BD%A8%E6%8A%BD%E5%8D%A1%E6%A6%82%E7%8E%87%E5%88%86%E5%B8%83%E5%9B%BE.png\" alt=\"原神武器m不定轨抽卡概率分布图\"></p>\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">#这次下面是真的武器池概率分布p_5了哈\nn5_cnt&#x3D;1#要抽出多少次M\nn5_tries&#x3D;240 * n5_cnt;#准备的祈愿次数\ntmp &#x3D; 0;\ndp_p &#x3D; np.zeros((13, 320*n5_cnt + 20,3), dtype&#x3D;float);\ndp_p[0][0][0] &#x3D; 1\n# 0 - M 1 - UP &amp; !M 2- !UP\nfor i in range (0,n5_cnt+1):\n        for j in range (0,n5_tries):\n            for k in range (1,81):\n                if(i-1&gt;&#x3D;0):\n                    dp_p[i][j+k][0] +&#x3D; dp_p[i-1][j][2] * pdf_5[k-1] * 1&#x2F;2 \\\n                                    + dp_p[i-1][j][1] * pdf_5[k-1] * 3&#x2F;8 + dp_p[i-1][j][0] * 3&#x2F;8 * pdf_5[k-1];\n                dp_p[i][j+k][1] +&#x3D; dp_p[i][j][0] * 3&#x2F;8 * pdf_5[k-1] + dp_p[i][j][2] * 1&#x2F;2 * pdf_5[k-1]\\\n                                + dp_p[i][j][1] * 3&#x2F;8 * pdf_5[k-1];\n                dp_p[i][j+k][2] +&#x3D; dp_p[i][j][0] * 1&#x2F;4 * pdf_5[k-1] + dp_p[i][j][1] * 1&#x2F;4 * pdf_5[k-1];\nposs&#x3D;[]\nfor i in range(0,n5_tries):\n    tmp &#x3D; tmp + dp_p[n5_cnt][i][0]\n    poss.append(tmp)\nprint(tmp)\n#制图代码，直接cv用\nx_major_locator&#x3D;MultipleLocator(15)#x分度值设置\ny_major_locator&#x3D;MultipleLocator(0.1)\nax&#x3D;plt.gca()\nax.xaxis.set_major_locator(x_major_locator)\nax.yaxis.set_major_locator(y_major_locator)\nx_values &#x3D; [x for x in range(1, n5_tries)]\nplt.grid()  # 生成网格\nplt.plot(poss)  </code></pre>\n\n<p>你如果和上面定轨时比较，会发现你想要M的话，需要投入稍微更多的抽数。而且可以看见，当投入200抽时，定轨机制下的获取M的概率已经逐步收敛至1。而不定轨机制下，获取到的概率的概率仅在80%附近，且之后收敛较慢，极端情况的发生概率并不低。</p>\n<p>有关不定轨又同时想要M和N的，TBC…</p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>概率分析还可以分析：如何配置属性让伤害最大化等问题。概率论作为一种打破人的直觉的东西，实在是让人又爱又恨。本文不仅仅局限于传统的期望范畴，结合具体概率的分布分析了对应的抽数需求。由于祈愿机制的概率不是恒定的，期望与中分位点存在区别，可以用平均GDP和中位数来感受。</p>\n<p>致谢：感谢张老师的帮助和OneBST的分享。</p>\n<p>【To Be Continued】</p>\n<ul>\n<li><p>同时研究多个四星的祈愿次数</p>\n</li>\n<li><p>常驻祈愿结合“联动规则”的分析</p>\n</li>\n<li><p>常驻祈愿与UP祈愿结合分析</p>\n</li>\n<li><p>蒙特卡罗模拟与大数定律</p>\n</li>\n<li><p>通过置信度研究极端情况</p>\n</li>\n</ul>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"ckz6z5ofc0001fovv3vg150xd","category_id":"ckv7ib2ra0006r8vv8gioalfw","_id":"ckz6z5off0006fovvgv8h9l6i"},{"post_id":"ckz6z5ofe0004fovv4c8m2i5z","category_id":"ckv7ib2rl000mr8vv23wv5z01","_id":"ckz6z5ofg0008fovvfti728gt"},{"post_id":"ckz6z5ofh0009fovv4tvw1s3x","category_id":"ckv7ib2rg000er8vvf0is796b","_id":"ckz6z5ofh000bfovvat9h20pu"},{"post_id":"ckz6z68tu000gfovv1lqoh3ic","category_id":"ckv7ib2ra0006r8vv8gioalfw","_id":"ckz6z68tv000ifovv2fps84mo"}],"PostTag":[{"post_id":"ckz6z5ofc0001fovv3vg150xd","tag_id":"ckv7ib2rb0007r8vvab2sdrce","_id":"ckz6z5ofe0003fovv8x0ndc8v"},{"post_id":"ckz6z5ofe0004fovv4c8m2i5z","tag_id":"ckv7ib2rg000fr8vvdleb7i0t","_id":"ckz6z5off0007fovv8fw3094k"},{"post_id":"ckz6z5ofh0009fovv4tvw1s3x","tag_id":"ckv7ib2rg000fr8vvdleb7i0t","_id":"ckz6z5ofh000afovv58k74e0e"},{"post_id":"ckz6z68tu000gfovv1lqoh3ic","tag_id":"ckv7ib2rb0007r8vvab2sdrce","_id":"ckz6z68tv000hfovv7if4dzzm"}],"Tag":[{"name":"C++,语法","_id":"ckv7ib2rb0007r8vvab2sdrce"},{"name":"dp","_id":"ckv7ib2rg000fr8vvdleb7i0t"}]}}