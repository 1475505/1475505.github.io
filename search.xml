<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>C++ STL使用手册</title>
    <url>//post/C++STL%E7%9A%84%E4%BD%BF%E7%94%A8.html</url>
    <content><![CDATA[<p>#C++ STL的使用手册</p>
<p>[toc]</p>
<p><img src="https://oi-wiki.org/lang/csl/images/container1.png" alt="img"></p>
<h3 id="共有函数"><a href="#共有函数" class="headerlink" title="共有函数"></a>共有函数</h3><p><code>=</code>：有赋值运算符以及复制构造函数。</p>
<p><code>begin()</code>：返回指向开头元素的迭代器。</p>
<p><code>end()</code>：返回指向末尾的下一个元素的迭代器。<code>end()</code> <strong>不指向某个元素</strong>，它是末尾元素的后继。</p>
<p><code>size()</code>：返回容器内的元素个数。</p>
<p><code>max_size()</code>：返回容器 <strong>理论上</strong> 能存储的最大元素个数。依容器类型和所存储变量的类型而变。</p>
<p><code>empty()</code>：返回容器是否为空的一个 <code>bool</code> 值，即 <code>begin() == end()</code>，<code>true</code> 为空，<code>false</code> 为非空。</p>
<p><code>swap()</code>：交换两个容器。</p>
<p><code>clear()</code>：清空容器。</p>
<p><code>==</code>&#x2F;<code>!=</code>&#x2F;<code>&lt;</code>&#x2F;<code>&gt;</code>&#x2F;<code>&lt;=</code>&#x2F;<code>&gt;=</code>：按 <strong>字典序</strong> 比较两个容器的大小。（比较元素大小时 <code>map</code> 的每个元素相当于 <code>set&lt;pair&lt;key, value&gt; &gt;</code>，<code>pair</code> 按 first 到 second 的顺序比较。无序容器不支持 <code>&lt;</code>&#x2F;<code>&gt;</code>&#x2F;<code>&lt;=</code>&#x2F;<code>&gt;=</code></p>
<h2 id="序列式容器"><a href="#序列式容器" class="headerlink" title="序列式容器"></a>序列式容器</h2><h3 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h3><p><strong>元素访问</strong></p>
<ol>
<li><p><code>at()</code></p>
<p><code>v.at(pos)</code> 返回容器中下标为 <code>pos</code> 的引用。如果数组越界抛出 <code>std::out_of_range</code> 类型的异常。</p>
</li>
<li><p><code>operator[]</code></p>
<p><code>v[pos]</code> 返回容器中下标为 <code>pos</code> 的引用。不执行越界检查。</p>
</li>
<li><p><code>front()</code></p>
<p><code>v.front()</code> 返回首元素的引用。</p>
</li>
<li><p><code>back()</code></p>
<p><code>v.back()</code> 返回末尾元素的引用。</p>
</li>
</ol>
<p><strong>迭代器</strong></p>
<ol>
<li><p><code>begin()/cbegin()</code></p>
<p>返回指向首元素的迭代器，其中 <code>*begin = front</code>。</p>
</li>
<li><p><code>end()/cend()</code></p>
<p>返回指向数组尾端占位符的迭代器，注意是没有元素的。</p>
</li>
</ol>
<p> 可以认为，<code>v[i]</code>与<code>*(v.begin()+i)</code>等价。但，<strong>除<code>vector</code> <code>string</code>外</strong>，其他STL容器不支持后者的形式。</p>
<ul>
<li><p><code>size()</code> 返回容器长度（元素数量），即 <code>std::distance(v.begin(), v.end())</code>。</p>
</li>
<li><p><code>insert()</code> 支持在某个迭代器位置插入元素、可以插入多个。<strong>复杂度与 <code>pos</code> 距离末尾长度成线性而非常数</strong></p>
</li>
<li><p><code>erase()</code> 删除某个<strong>迭代器或者区间的元素</strong>，返回最后被删除的迭代器。复杂度与 <code>insert</code> 一致。</p>
</li>
<li><p><code>push_back(x)</code> 在末尾插入一个元素x，均摊复杂度：常数，最坏为线性复杂度。</p>
</li>
<li><p><code>pop_back()</code> 删除末尾元素，常数复杂度。</p>
</li>
</ul>
<h3 id="deque"><a href="#deque" class="headerlink" title="deque"></a>deque</h3><p>能够提供线性复杂度的插入和删除，以及常数复杂度的随机访问。操作大同<code>vector</code>。</p>
<ul>
<li><p><code>push_front()</code> 在头部插入一个元素。</p>
</li>
<li><p><code>pop_front()</code> 删除头部元素。</p>
</li>
<li><p><code>push_back()</code> 在末尾插入一个元素。</p>
</li>
<li><p><code>pop_back()</code> 删除末尾元素。</p>
</li>
</ul>
<h3 id="list"><a href="#list" class="headerlink" title="list"></a>list</h3><p>与<code>deque</code>大致相同，但是由于 <code>list</code> 的实现是链表，因此不提供随机访问的接口。若需要访问中间元素，则需要使用迭代器。</p>
<ul>
<li><p><code>front()</code> 返回首元素的引用。</p>
</li>
<li><p><code>back()</code> 返回末尾元素的引用。</p>
</li>
</ul>
<h3 id="array-C-11"><a href="#array-C-11" class="headerlink" title="array(C++11)"></a>array(C++11)</h3><table>
<thead>
<tr>
<th align="left">成员函数</th>
<th align="left">作用</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>operator=</code></td>
<td align="left"><code>array2</code> 的每个元素重写 <code>array1</code> 对应元素</td>
<td></td>
</tr>
<tr>
<td align="left"><code>max_size</code></td>
<td align="left">返回可容纳的最大元素数</td>
<td></td>
</tr>
<tr>
<td align="left"><code>fill</code></td>
<td align="left">以指定值填充容器</td>
<td>arr.fill(1);</td>
</tr>
<tr>
<td align="left"><code>swap</code></td>
<td align="left">交换，交换array的复杂度为：O(size)</td>
<td></td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="left">非成员函数</th>
<th align="left">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>operator==</code></td>
<td align="left">按照字典序比较 <code>array</code> 中的值</td>
</tr>
<tr>
<td align="left"><code>std::get</code></td>
<td align="left">访问 <code>array</code> 的一个元素</td>
</tr>
</tbody></table>
<h2 id="关联式容器"><a href="#关联式容器" class="headerlink" title="关联式容器"></a>关联式容器</h2><h3 id="统一共有函数"><a href="#统一共有函数" class="headerlink" title="统一共有函数"></a>统一共有函数</h3><ul>
<li><p><code>find(x)</code>: 若容器内存在键为 x 的元素，会返回该元素的迭代器；否则返回 <code>end()</code>。</p>
<p><img src="C:\Users\ll\AppData\Roaming\Typora\typora-user-images\image-20211015124758889.png" alt="image-20211015124758889"></p>
</li>
<li><p><code>erase(pos)</code> 删除迭代器为 pos 的元素，可结合<code>find</code>函数使用。</p>
</li>
<li><p><code>erase(first,last)</code> 删除迭代器在 [first,last)范围内的所有元素。</p>
</li>
<li><p><code>count(x)</code>: 返回容器内键为 x 的元素数量。</p>
</li>
<li><p><code>lower_bound(x)</code>: 返回指向首个<strong>不小于</strong> 给定<strong>键</strong>的元素的迭代器。</p>
</li>
<li><p><code>upper_bound(x)</code>: 返回指向首个**大于 **给定键的元素的迭代器。若容器内所有元素均小于或等于给定键，返回 <code>end()</code>。</p>
</li>
<li><p><code>size()</code>: 返回容器内元素个数。</p>
</li>
</ul>
<h3 id="set"><a href="#set" class="headerlink" title="set"></a>set</h3><p><code>set</code> 内部采用红黑树实现。平衡二叉树的特性使得 <code>set</code> 非常适合处理需要同时兼顾查找、插入与删除的情况。</p>
<ul>
<li><code>insert(x)</code> 将元素 x 插入到 <code>set</code> 中。自动排序和去重。</li>
<li><code>erase(x)</code> 删除值为 x 的 <strong>所有</strong> 元素，返回删除元素的个数。</li>
<li><code>erase(first,last)</code> 删除迭代器在 [first,last)范围内的所有元素。</li>
</ul>
<h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><p><code>map</code> 重载了 <code>operator[]</code>，可以用任意定义了 <code>operator &lt;</code> 的类型作为下标（在 <code>map</code> 中叫做 <code>key</code>，也就是索引）。</p>
<ul>
<li>可以直接通过下标访问来进行查询或插入操作。例： <code>mp[&quot;Alan&quot;]=100</code>。利用下标访问 时，如果 <code>map</code> 中不存在相应键的元素，会自动在 <code>map</code> 中插入一个新元素，并将其值设置为默认值（对于整数，值为零；对于有默认构造函数的类型，会调用默认构造函数进行初始化）</li>
<li>通过向 <code>map</code> 中插入一个类型为 <code>pair&lt;Key, T&gt;</code> 的值可以达到插入元素的目的，例如 <code>mp.insert(pair&lt;string,int&gt;(&quot;Alan&quot;,100));</code></li>
<li><code>erase(key)</code> 函数会删除键为 <code>key</code> 的 <strong>所有</strong> 元素。返回值为删除元素的数量。</li>
</ul>
<h2 id="哈希适配容器"><a href="#哈希适配容器" class="headerlink" title="哈希适配容器"></a>哈希适配容器</h2><p>四种基于哈希实现的无序关联式容器：<code>unordered_set</code>，<code>unordered_multiset</code>，<code>unordered_map</code>，<code>unordered_multimap</code>。</p>
<p>其操作与关联式容器类似。</p>
<h2 id="容器适配器"><a href="#容器适配器" class="headerlink" title="容器适配器"></a>容器适配器</h2><p>为什么称为容器适配器呢，是因为其内部的实现是基于<code>vector</code>  <code>deque </code> 等等，其原理可以参考《STL源码剖析》。</p>
<h3 id="后进先出的stack"><a href="#后进先出的stack" class="headerlink" title="后进先出的stack"></a>后进先出的stack</h3><p>仅支持查询或删除最后一个加入的元素（栈顶元素），不支持随机访问。</p>
<ul>
<li><code>top()</code> 访问栈顶元素（如果栈为空，此处会出错）</li>
<li><code>push(x)</code> 向栈中插入元素 x</li>
<li><code>pop()</code> 删除栈顶元素</li>
</ul>
<h3 id="先进先出的queue"><a href="#先进先出的queue" class="headerlink" title="先进先出的queue"></a>先进先出的queue</h3><ul>
<li><code>front()</code> 访问队首元素（如果队列为空，此处会出错）</li>
<li><code>push(x)</code> 向队列中插入元素 x</li>
<li><code>pop()</code> 删除队首元素</li>
</ul>
<h3 id="优先队列"><a href="#优先队列" class="headerlink" title="优先队列"></a>优先队列</h3><ul>
<li><p><code>top()</code> 访问堆顶元素（此时优先队列不能为空）</p>
</li>
<li><p><code>push(x)</code> 插入元素，并对底层容器排序</p>
</li>
<li><p><code>pop()</code> 删除堆顶元素（此时优先队列不能为空）</p>
</li>
</ul>
<p>以上<code>pop</code>方法，返回已删除元素的值。</p>
<ul>
<li><p>优先级的定义：</p>
<p>对于数字，一般是值大者优先。即默认为：</p>
<p><code>priority_queue&lt;int,vector&lt;int&gt;,less&lt;int&gt; &gt; pq;</code></p>
<p>第二个参数是内部实现方式；第三个参数  <strong>less表示数字大的优先级越大。如果是<code>greater&lt;int&gt;</code>，则为数字小者优先级大。</strong>优先级大者，位于<code>top</code>。</p>
<p>结构体也可以定义优先级，可以通过<code>cmp</code>函数或者重载<code>&lt;</code>运算符实现。这种思路也适用于其他关联式容器。</p>
</li>
</ul>
<h3 id="pair的常见用法"><a href="#pair的常见用法" class="headerlink" title="pair的常见用法"></a>pair的常见用法</h3><p>头文件：<code>&lt;utility&gt;</code></p>
<p>按照正常的结构体访问（first，second…）。</p>
<h3 id="string的常见用法"><a href="#string的常见用法" class="headerlink" title="string的常见用法"></a>string的常见用法</h3><p><code>string</code>的实现形式类似于字符型<code>vector</code>，支持<code>push_back</code>、直接赋值（注意使用<strong>双引号</strong>）和下标访问。只支持<code>cin</code> <code>cout</code>，不支持<code>printf</code>等。</p>
<ul>
<li><p>可以通过加减运算符实现字符串拼接和删减、比较运算符进行字典序比较。</p>
</li>
<li><p><code>substr(pos,len)</code>方法截取子串。时间复杂度是O（len）。</p>
</li>
<li><p><code>find(x,pos)</code>指定了开始寻找的位置为下标<code>pos</code></p>
</li>
<li><p>上面的共有函数（<code>erase</code> <code>find</code>等）也是支持的。复杂度都是O(n)</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">string s1 &#x3D; &quot;Hello&quot;;
string s2 &#x3D; &quot;world&quot;;
s1.insert(3,s2);&#x2F;&#x2F;Helworldlo</code></pre></li>
</ul>
<h3 id="STL算法"><a href="#STL算法" class="headerlink" title="STL算法"></a>STL算法</h3><p>在《特性》篇也介绍有一些用法。</p>
<ul>
<li><code>find_end</code>：逆序查找。<code>find_end(v.begin(), v.end(), value)</code>。</li>
<li><code>nth_element</code>：按指定范围进行分类，即找出序列中第 <em>n</em> 大的元素，使其左边均为小于它的数，右边均为大于它的数。<code>nth_element(v.begin(), v.begin() + mid, v.end(), cmp)</code> 或 <code>nth_element(a + begin, a + begin + mid, a + end, cmp)</code></li>
<li><code>next_permutation</code>：将当前排列更改为 <strong>全排列中的下一个排列</strong>。如果当前排列已经是 <strong>全排列中的最后一个排列</strong>（元素完全从大到小排列），函数返回 <code>false</code> 并将排列更改为 <strong>全排列中的第一个排列</strong>（元素完全从小到大排列）；否则，函数返回 <code>true</code>。<code>next_permutation(v.begin(), v.end())</code> 或 <code>next_permutation(v + begin, v + end)</code>。</li>
</ul>
<h3 id="bitset"><a href="#bitset" class="headerlink" title="bitset"></a>bitset</h3><p>通过固定的优化，使得一个字节的八个比特能分别储存 8 位的 <code>0/1</code>。</p>
<p>头文件：<code>&lt;bitset&gt;</code></p>
<ul>
<li><code>bitset()</code>: 每一位都是 <code>false</code>。</li>
<li><code>bitset(int val)</code>: 设为 <code>val</code> 的二进制形式。</li>
<li><code>bitset(const string&amp; str)</code>: 设为 01 串 <code>str</code>。</li>
</ul>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">bitset&lt;4&gt; bitset1;　　&#x2F;&#x2F;无初始化下，默认每一位均为0
bitset&lt;8&gt; bitset2(16);　&#x2F;&#x2F;保存长度为8的16的二进制表示：[00010000]
string s &#x3D; &quot;10010&quot;;
bitset&lt;8&gt; bitset3(s);　　&#x2F;&#x2F;长度为10，前补0。[00010010]</code></pre>

<ul>
<li><p><code>operator []</code>: 访问其特定的一位。</p>
</li>
<li><p><code>operator ==/!=</code>: 比较两个 <code>bitset</code> 内容是否完全一样。</p>
</li>
<li><p><code>operator &amp;/&amp;=/|/| =/^/^=/~</code>: 进行按位与&#x2F;或&#x2F;异或&#x2F;取反操作。**<code>bitset</code> 只能与 <code>bitset</code> 进行位运算**，若要和整型进行位运算，要先将整型转换为 <code>bitset</code>。</p>
</li>
<li><p><code>operator &lt;&gt;/&lt;&lt;=/&gt;&gt;=</code>: 进行二进制左移&#x2F;右移。</p>
</li>
<li><p><code>operator &lt;&gt;</code>: 流运算符，这意味着你可以通过 <code>cin/cout</code> 进行输入输出。</p>
</li>
<li><p><code>count()</code>: 返回 <code>true</code> 的数量。</p>
</li>
<li><p><code>size()</code>: 返回 <code>bitset</code> 的大小。</p>
</li>
<li><p><code>test(pos)</code>: 它和 <code>vector</code> 中的 <code>at()</code> 的作用是一样的，和 <code>[]</code> 运算符的区别就是越界检查。</p>
</li>
<li><p><code>to_string()</code>: 返回转换成的字符串表达。</p>
</li>
<li><p><code>to_ulong()</code>: 返回转换成的 <code>unsigned long</code> 表达 (<code>long</code> 在 NT 及 32 位 POSIX 系统下与 <code>int</code> 一样，在 64 位 POSIX 下与 <code>long long</code> 一样）。</p>
</li>
<li><p><code>to_ullong()</code>:<em>C++11</em>，返回转换成的 <code>unsigned long long</code> 表达。</p>
</li>
<li><p><code>any()</code>: 若存在某一位是 <code>true</code> 则返回 <code>true</code>，否则返回 <code>false</code>。</p>
</li>
<li><p><code>none()</code>: 若所有位都是 <code>false</code> 则返回 <code>true</code>，否则返回 <code>false</code>。</p>
</li>
<li><p><code>all()</code>:<em>C++11</em>，若所有位都是 <code>true</code> 则返回 <code>true</code>，否则返回 <code>false</code>。</p>
</li>
<li><p><code>set()</code>: 将整个 <code>bitset</code> 设置成 <code>true</code>。</p>
<p><code>set(pos, val = true)</code>: 将某一位设置成 <code>true</code>&#x2F;<code>false</code>。</p>
</li>
<li><p><code>reset()</code>: 将整个 <code>bitset</code> 设置成 <code>false</code>。</p>
<p><code>reset(pos)</code>: 将某一位设置成 <code>false</code>。相当于 <code>set(pos, false)</code>。</p>
</li>
<li><p><code>flip()</code>: 翻转每一位。（01互换，相当于异或一个全是1 的 <code>bitset</code>）</p>
<p><code>flip(pos)</code>: 翻转某一位。</p>
</li>
<li><p><code>_Find_first()</code>: 返回 <code>bitset</code> 第一个 <code>true</code> 的下标，若没有 <code>true</code> 则返回 <code>bitset</code> 的大小。</p>
</li>
<li><p><code>_Find_next(pos)</code>: 返回 <code>pos</code> 后面（下标严格大于 <code>pos</code> 的位置）第一个 <code>true</code> 的下标，若 <code>pos</code> 后面没有 <code>true</code> 则返回 <code>bitset</code> 的大小。</p>
</li>
</ul>
<p>参考资料：</p>
<p>OI-wiki</p>
<p>《算法笔记》</p>
]]></content>
      <categories>
        <category>语言基础</category>
      </categories>
      <tags>
        <tag>C++,语法</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ 特性</title>
    <url>//post/%E4%BB%8EC%E8%BF%9B%E6%AD%A5%E5%88%B0C++%E2%80%94%E2%80%94%E7%89%B9%E6%80%A7.html</url>
    <content><![CDATA[<h1 id="从C进步到C-——特性"><a href="#从C进步到C-——特性" class="headerlink" title="从C进步到C++——特性"></a>从C进步到C++——特性</h1><p>[TOC]</p>
<h2 id="结构体初始化构造"><a href="#结构体初始化构造" class="headerlink" title="结构体初始化构造"></a>结构体初始化构造</h2><p>定义结构体时，加入以下语句，可以方便地进行初始化。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">struct student&#123;
	int id;
	char gender;
	
	student()&#123;&#125;  &#x2F;&#x2F;系统默认，用于未经初始化定义结构体
	
	student (int _id, char _gender )&#123;
		id &#x3D; _id;
		gender &#x3D; _gender;
	&#125;&#x2F;&#x2F;用于初始化id和gender。注意：减少参数 可以达到只使用部分元素构造的效果
&#125;</code></pre>

<p>构造函数可以简化为一行，并且可以进行默认赋值，如此调用时可以省略对应参数。如：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Point (int x&#x3D;0 , int y &#x3D; 0):x(x),y(y) &#123;&#125;;
&#x2F;&#x2F;Point();</code></pre>



<p>这是一个二叉树节点的定义示例：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">struct TreeNode &#123;
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;
&#125;;</code></pre>



<h2 id="auto声明推断"><a href="#auto声明推断" class="headerlink" title="auto声明推断"></a>auto声明推断</h2><p>使用STL容器时的迭代器声明等等往往比较复杂，此时使用 <code>auto</code> 可简单很多：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">vector&lt;int&gt; vec;
auto pvec &#x3D; vec.begin();&#x2F;&#x2F;vector&lt;int&gt;::iterator</code></pre>



<h2 id="容器类for-range循环"><a href="#容器类for-range循环" class="headerlink" title="容器类for-range循环"></a>容器类for-range循环</h2><p>对数组或容器执行循环操作可写成：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">double prices[5] &#x3D; &#123;1.1 , 2.2 , 3.3 , 4.4 , 5.5&#125;
for ( double x : prices)&#123;&#x2F;&#x2F;只读
	cout&lt;&lt;x&lt;&lt;endl;
&#125;
for ( double &amp;x : prices)&#123;&#x2F;&#x2F;写需要使用指针
	x &#x3D; x &#x2F; 2;
&#125;</code></pre>



<p>结合上面的auto 部分循环可以写成：</p>
<pre class="line-numbers language-none"><code class="language-none">for ( auto x : vec )</code></pre>



<h2 id="string类的类型转换函数"><a href="#string类的类型转换函数" class="headerlink" title="string类的类型转换函数"></a>string类的类型转换函数</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">int i &#x3D; 43;
string s &#x3D; to_string(i);
double d &#x3D; stod(s);&#x2F;&#x2F;43.000000
&#x2F;&#x2F;对应的有：stoi , stoll , stof</code></pre>

<p><strong>注意不要传入空串！</strong></p>
<h2 id="rotate-x2F-copy-x2F-fill函数"><a href="#rotate-x2F-copy-x2F-fill函数" class="headerlink" title="rotate&#x2F;copy&#x2F;fill函数"></a>rotate&#x2F;copy&#x2F;fill函数</h2><p>rotate函数可以“平移”。直接看例子吧：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">vector&lt;int&gt; a&#123;1,2,3,4,5,6,7,8,9&#125;;
rotate(a.begin() , a.begin()+2 , a.end());
&#x2F;&#x2F;a:[3,4,5,6,7,8,9,1,2]</code></pre>

<p>相当于得到：[mid:end] + [begin:mid)</p>
<p>copy函数将一个目标（容器、数组）里面的元素复制至另一个目标。</p>
<p><strong>注：使用前 <code>newvector.resize(7) </code>这行代码为<code>newvector</code>分配空间，防止程序崩溃</strong>。</p>
<p>此外，通过<code>vector&lt;int&gt;  dp ( 7 , 0 )</code>也可以达到初始化<code>dp</code>为[0,0,0,0,0,0,0].</p>
<p>fill函数可以为数组和vector赋初始值。头文件：<code>&lt;algorithm&gt;</code></p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int v[10];
fill(v,v+10,-1);&#x2F;&#x2F;相当于 memset(v,-1,sizeof v);
int s[10][10];
fill(s[0],s[0]+10*10,-1);</code></pre>



<h2 id="sort-x2F-lower-bound-x2F-upper-bound-x2F-unique函数"><a href="#sort-x2F-lower-bound-x2F-upper-bound-x2F-unique函数" class="headerlink" title="sort&#x2F;lower_bound&#x2F;upper_bound&#x2F;unique函数"></a>sort&#x2F;lower_bound&#x2F;upper_bound&#x2F;unique函数</h2><p>sort函数可用于 <code>vector </code>、 数组 和 <code>deque</code> 的排序。如：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">sort(b,b+n,greater&lt;int&gt;());&#x2F;&#x2F;将b降序排列</code></pre>

<p>在<strong>已排好升序</strong>的情况下：</p>
<p>1.可使用lower_bound函数（<code>startptr</code>，<code>endptr</code> ，<code>num</code>）得到第一个不小于<code>num</code>的值的指针。（二分查找）。如下代码返回下标：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">int a[10];&#x2F;&#x2F;......
int b &#x3D; upper_bound(a , a+10 , 3) - a;</code></pre>

<p>2.可使用unique函数返回最后一个非重复元素的指针，如下代码进行<strong>去重</strong>。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">vec.erase( unique(vec.begin(),vec.end()) , vec.end() );</code></pre>

<p>拓展排序：partial_sort 方法</p>
<h2 id="局部排序partiai-sort"><a href="#局部排序partiai-sort" class="headerlink" title="局部排序partiai_sort"></a>局部排序<code>partiai_sort</code></h2><p>可以提供一定区间的排序获得。原理似乎是堆排序。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">for(i&#x3D;10;i&gt;&#x3D;1;i--)	vec.push_back(i);
partial_sort(vec.begin(),vec.begin()+3,vec.end());
&#x2F;&#x2F;[1,2,3,10,9,8,7,6,5,4]

rep(i,1,10) a.push_back(i);
partial_sort(vec.begin(),vec.begin()+3,vec.end(),greater&lt;int&gt;());
&#x2F;&#x2F;[10,9,8,1,2,3,4,5,6,7]</code></pre>

<p>应用：班上有10个学生，我想知道分数最低的5名是哪些人。如果没有partial_sort，你就需要用sort把所有人排好序，然后再取前5个。现在你只需要对分数最低5名排序。</p>
<h2 id="一些可能有用的数学函数"><a href="#一些可能有用的数学函数" class="headerlink" title="一些可能有用的数学函数"></a>一些可能有用的数学函数</h2><p><strong>指对运算</strong></p>
<p>以下函数：接收x为<code>float</code>    <code>double</code>类型，返回传入类型。</p>
<p><code>exp2(x)</code>  - 快速返回2的x次幂。</p>
<p><code>log2(x)</code> - 得到以2为底x的对数。</p>
<p><code>log10(x)</code> - 得到以10为底x的对数。</p>
<p><code>log(x)</code>  - 得到x的自然对数。</p>
<p><code>expm(x)</code> - 返回e的x次幂-1。</p>
<p><code>exp(x)</code> - 得到e的x次幂。x支持complex类型。</p>
<p><strong>取整函数</strong></p>
<p>以下函数的传入传出同上。</p>
<p><code>floor(x)</code> - 向下取整。</p>
<p><code>ceil(x)</code> - 向上取整。 </p>
<p><code>round(x)</code> - 四舍五入，基本类似于<code>floor(x+0.5)</code>。<strong>但是中点情况下向远离0的方向舍入</strong>。</p>
<p><code>trunc(x)</code> - 将x向0方向舍入。</p>
<h2 id="数组生成-iota-x2F-shuffle"><a href="#数组生成-iota-x2F-shuffle" class="headerlink" title="数组生成- iota&#x2F;shuffle"></a>数组生成- iota&#x2F;shuffle</h2><p>递增数组：与 <code>golang </code>可对比：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">iota(arr,arr+n,0);&#x2F;&#x2F;[0,1,2,3,4,...];</code></pre>

<p>随机打乱数组：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">srand(time(NULL));
random_shuffle(a+1,a+n+1);</code></pre>

<p><code>random_shuffle</code> 自 C++14 起被弃用，C++17 起被移除。可以使用 <code>shuffle</code> 函数代替：</p>
<p><code>shuffle(v.begin(),v.end(),rand)</code>（最后一个参数传入的是使用的随机数生成器，一般情况下传入 <code>rand</code> 即可）。</p>
<p>使用时需要设置随机数种子，配合<code>iota</code>可以实现类似于“洗牌”的效果。同时可进行随机的多次模拟，为了时间种子的不同，可能需要每次模拟间设置<code>sleep</code>间隔。</p>
<p>参考资料：</p>
<p>《C++ Primer》 目录</p>
<p>《C++ Primer Plus》  18.1</p>
<p>《算法竞赛入门经典习题解答》第一章</p>
<p><a href="http://www.cppblog.com/mzty/archive/2005/12/15/1770.aspx">http://www.cppblog.com/mzty/archive/2005/12/15/1770.aspx</a></p>
]]></content>
      <categories>
        <category>语言基础</category>
      </categories>
      <tags>
        <tag>C++,语法</tag>
      </tags>
  </entry>
  <entry>
    <title>C/C++ 多维数组的处理</title>
    <url>//post/C%E4%B8%AD%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E5%A4%84%E7%90%86.html</url>
    <content><![CDATA[<p>笔者要用到多维数组的时候经常忘了多维数组怎么用，在此总结一下：</p>
<p>【内容产出中】</p>
<p>1.二维数组的函数调用实例</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">&#x2F;&#x2F;声明
void bubbleSort(float (*num)[40],int size);
&#x2F;&#x2F;调用
bubbleSort( stu , 40);
&#x2F;&#x2F;思想：二维数组——数组的数组</code></pre>
<p>2.把二维数组当一维数组进行赋值：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">int *p&#x3D;&amp;a[0][0];&#x2F;&#x2F;获取二维数组首地址
for(int i&#x3D;0;i&lt;6;i++)
&#123;
scnaf(&quot;%d&quot;,p);
p++;
&#125;</code></pre>
<p>3.使用 C++ 容器时，若可以使用<code>at</code>等方法获得对应元素，以缓解运算符<code>[]</code>的不稳定性问题。</p>
<p>如： array（C++11）</p>
<table>
<thead>
<tr>
<th>函数</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>at</code></td>
<td>访问指定的元素，同时进行越界检查<code>at</code> 若遇 <code>pos &gt;= size()</code> 的情况会抛出 <code>std::out_of_range</code>。</td>
</tr>
<tr>
<td><code>operator[]</code></td>
<td>访问指定的元素，<strong>不</strong> 进行越界检查</td>
</tr>
</tbody>
</table>
<p>4.多维vector的行列空间预留</p>
<pre class="line-numbers language-none"><code class="language-none">vector&lt;vector&lt;bool&gt; &gt; table(256);&#x2F;&#x2F;256行
table.resize(512);&#x2F;&#x2F;512列</code></pre>
]]></content>
  </entry>
  <entry>
    <title>《原神》祈愿机制概率研究</title>
    <url>//post/%E6%A6%82%E7%8E%87%E8%AE%BA%E8%AE%BA%E6%96%87.html</url>
    <content><![CDATA[<p>#《原神》祈愿机制概率研究</p>
<p>【摘要】本文以概率论、随机过程理论等工具研究游戏《原神》中的祈愿机制，主要基于动态规划，以“期望”和“概率的概率”两大分析方向进行数据处理，并根据分析结果总结了一些方便玩家规划金钱与资源的建议。由于追求多次获得五星道具的玩家基本“不差钱”，本文附有获取少量五星情况下的数据可视化。</p>
<p>[TOC]</p>
<blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot="">
<path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path>
<path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path>
<path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path>
<path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path>
<path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path>
<path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path>
<path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path>
</svg>
</span><p>Version:20220105</p>
<ul>
<li>修了讲一遍时找到的笔误</li>
</ul></blockquote>
<h2 id="规则表述"><a href="#规则表述" class="headerlink" title="规则表述"></a>规则表述</h2><p>旅行者（玩家）可以通过祈愿机制获取“五星角色”“五星武器“”四星角色“”四星武器“来提高战斗力。其中，角色具有命之座机制，首次获得为0命，最高6命，命座数越高，角色越强；类似地，武器拥有精炼层数机制，首次获得为1阶，最高5阶。</p>
<p>最近的版本更新中，《原神》的祈愿机制也发生了一定的变化。</p>
<p>以下是《原神》两个祈愿机制的官方描述（<a href="https://ys.mihoyo.com/main/news/public%EF%BC%89%EF%BC%9A">https://ys.mihoyo.com/main/news/public）：</a></p>
<h3 id="角色祈愿"><a href="#角色祈愿" class="headerlink" title="角色祈愿"></a>角色祈愿</h3><p>**五星角色祈愿的基础概率为0.600%，综合概率（含保底）为1.600%**，最多90次祈愿必定能通过保底获取5星角色。</p>
<p>当祈愿获取到5星角色时，有50.000%的概率为本期5星UP角色「A1」<em>（小保底）</em>。如果本次祈愿获取的5星角色非本期5星UP角色，下次祈愿获取的5星角色必定为本期5星UP角色<em>（大保底）</em>。</p>
<p><strong>4星物品祈愿的基础概率为5.100%，4星角色祈愿的基础概率为2.550%，4星武器祈愿的基础概率为2.550%，4星物品祈愿的综合概率（含保底）为13.000%。</strong>最多10次祈愿必定能通过保底获取4星或以上物品，通过保底获取4星物品的概率为99.400%，获取5星物品的概率为0.600%。</p>
<p>当祈愿获取到4星物品时，有50.000%的概率为本期4星UP角色「B」、「C」、「D」中的一个。如果本次祈愿获取的4星物品非本期4星UP角色，下次祈愿获取的4星物品必定为本期4星UP角色。当祈愿获取到4星UP物品时，每个本期4星UP角色的获取概率均等。</p>
<p>角色祈愿包括「角色活动祈愿-1」和「角色活动祈愿-2」，祈愿次数和保底完全共享，共同累计。二者区别仅在于当期UP的五星角色不同。</p>
<h3 id="武器祈愿"><a href="#武器祈愿" class="headerlink" title="武器祈愿"></a>武器祈愿</h3><p><strong>武器祈愿中，5星武器祈愿的基础概率为0.700%，综合概率（含保底）为1.850%，</strong>最多80次祈愿必定能通过保底获取5星武器。</p>
<p>当祈愿获取到5星武器时，有75.000%的概率为本期5星UP武器「M」、「N」中的一个。如果本次祈愿获取的5星武器非本期5星UP武器，下次祈愿获取的5星武器必定为本期5星UP武器。</p>
<p>【定轨机制】命定值：玩家可以指定一把本期5星UP武器（定轨）。当获取到的5星武器为非当前定轨武器时，获得1点命定值，命定值达到满值2后，在本祈愿中获得的下一把5星武器必定为当前定轨武器。获取到当前定轨武器时，无论当前命定值是否达到满值，都将会重置为0，重新累计。在未通过命定值达到满值获取定轨武器的情况下，当祈愿获取到5星UP物品时，每把本期5星UP武器的获取概率均等。</p>
<p>未使用「神铸定轨」定轨武器时，将不会累积命定值。</p>
<p><strong>4星物品祈愿的基础概率为6.000%，4星角色祈愿的基础概率为3.000%，4星武器祈愿的基础概率为3.000%，4星物品祈愿的综合概率（含保底）为14.500%。</strong>最多10次祈愿必定能通过保底获取4星或以上物品，通过保底获取4星物品的概率为99.300%，获取5星物品的概率为0.700%。</p>
<p>当祈愿获取到4星物品时，有75.000%的概率为本期4星UP武器「F」、「G」、「H」、「J」、「K」中的一个。如果本次祈愿获取的4星物品非本期4星UP武器，下次祈愿获取的4星物品必定为本期4星UP武器。当祈愿获取到4星UP物品时，每把本期4星UP武器的获取概率均等。</p>
<h1 id="角色祈愿分析"><a href="#角色祈愿分析" class="headerlink" title="角色祈愿分析"></a>角色祈愿分析</h1><h2 id="五星角色概率建模"><a href="#五星角色概率建模" class="headerlink" title="五星角色概率建模"></a>五星角色概率建模</h2><p>   前面的作业中，笔者通过运行代码和期望分析，对角色祈愿的机制进行了尝试1的模拟，简单回顾如下：</p>
<h3 id="尝试1：89次伯努利实验"><a href="#尝试1：89次伯努利实验" class="headerlink" title="尝试1：89次伯努利实验"></a>尝试1：89次伯努利实验</h3><p>建模1：前89次祈愿，每次获得五星角色的概率均为0.6%，若前89次实验没有获得五星角色，则获取五星角色的概率为100%。</p>
<p>则可以建模二项分布概率密度：</p>
<p>$$ PDF(X &#x3D; k) &#x3D; (1-p)^{k-1}p(p &#x3D; 0.6 %)$$</p>
<p>$$ CDF(X &#x3D; k) &#x3D; (1 - p)^k$$</p>
<p>计算每次获取五星角色的祈愿数期望：</p>
<p>$$ E(X) &#x3D; 90(1-CDF(89)) + \sum_{i&#x3D;1}^{89}iPDF(x&#x3D;i)$$</p>
<p>得到综合概率：</p>
<p>$$P &#x3D; \frac{1}{E(X)} $$</p>
<p>结果为：1.435%。（详见week9作业）</p>
<p>与官方描述不符。实际上，官方提到的0.6%是基础概率，说明不是恒定概率的伯努利实验，于是提出模型2.</p>
<h3 id="尝试2：概率递增的保底机制"><a href="#尝试2：概率递增的保底机制" class="headerlink" title="尝试2：概率递增的保底机制"></a>尝试2：概率递增的保底机制</h3><p>建模2：在一定抽数都没有得到五星角色后，获得五星角色概率开始线性上升，直到第90抽达到100%。 </p>
<p>由于具体概率密度没有官方文档，只能站在前人的分析上，根据结合数据统计的开源项目（<a href="https://github.com/OneBST/GGanalysis%EF%BC%8C%E6%9C%AC%E6%96%87%E5%AE%9E%E9%99%85%E4%B8%8A%E7%9B%B8%E5%BD%93%E4%BA%8E%E6%A8%A1%E5%9E%8B%E7%9A%84%E5%A4%8D%E7%8E%B0%EF%BC%89%E9%87%87%E7%94%A8%E7%9A%84%E6%A8%A1%E5%9E%8B%EF%BC%8C%E7%AC%ACx%E6%AC%A1%E7%A5%88%E6%84%BF%E8%8E%B7%E5%BE%97%E4%BA%94%E6%98%9F%E8%A7%92%E8%89%B2%E7%9A%84%E6%A6%82%E7%8E%87%E5%A6%82%E4%B8%8B%EF%BC%9A">https://github.com/OneBST/GGanalysis，本文实际上相当于模型的复现）采用的模型，第x次祈愿获得五星角色的概率如下：</a></p>
<p>$$ P(x) &#x3D; \begin{cases} 0.6% &amp;{x&lt;&#x3D;73}\ 0.6% + 6%(x - 73) &amp;{74&lt;&#x3D;x&lt;&#x3D;89}\1&amp;{x &#x3D; 90} \end{cases}$$</p>
<p>由此，可以得到第x次祈愿得到五星角色的分布列（类似于几何分布）：</p>
<p>$$ PDF(x) &#x3D; P(x) * \prod_{k &#x3D; 1}^{x - 1}1-P(x) $$</p>
<p>$$ PDF(x) &#x3D; \begin{cases} (1 - 0.6%)^{x-1}\times0.6% &amp;{x\leqslant73}\ (1-0.6%)^{73} \times \sum_{k &#x3D; 74}^{x} (1- 6%(k - 73))^{k-73}(6%(k-73)) &amp;{74\leqslant x\leqslant89}\(1-0.6%)^{73} \times \sum_{k &#x3D; 74}^{89} (1- 6%(k - 73))^{k-73}&amp;{x &#x3D; 90} \end{cases} $$</p>
<p><strong>该模型平均获取五星角色的祈愿次数为62.3。</strong>该模型下五星角色的综合概率为1.605%。</p>
<p>注：期望计算公式：</p>
<p>$$ E(X) &#x3D; \sum_{i&#x3D;1}^{x}PDF(x)\times x $$</p>
<h2 id="概率递增保底机制下的数字特征"><a href="#概率递增保底机制下的数字特征" class="headerlink" title="概率递增保底机制下的数字特征"></a>概率递增保底机制下的数字特征</h2><h3 id="求数据特征"><a href="#求数据特征" class="headerlink" title="求数据特征"></a>求数据特征</h3><p>在这里处理一个认识误区：期望 !&#x3D; 概率为50%的点（中分位点）。</p>
<p>也就是说，期望作为概率的平均值，$ CDF(EX) &#x3D; 0.5 $ <strong>是不成立的</strong>。 注意到这一前提，才能比较正确地理解下面的结论。</p>
<p>由于其概率密度并不是均匀分布的，差别较大，选择平均数似乎不太合适。所以我们获取中分位点。根本不应该是程序员能写出来的粗糙代码验证：</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">import numpy as np
import matplotlib as mlp
import matplotlib.pyplot as plt
from matplotlib.pyplot import MultipleLocator
def p_5(n):
    if n &lt; 73:
        return 0.006
    elif n &lt; 89:
        return 0.006 + (n - 72) * 0.06
    else:
        return 1
    
pdf_5 &#x3D; [];
cdf_5 &#x3D; [];
tmp &#x3D; 0.0;

for i in range (0,90):
    tmp &#x3D; p_5(i);
    for j in range(0,i):
        tmp &#x3D; tmp * (1 - p_5(j))
    pdf_5.append(tmp);
#注：下文中其他代码可能要用到p_5,p_4函数,pdf_5列表哦

for i in range (0,90):
    tmp &#x3D; 0.0;
    for j in range (0,i+1):
        tmp &#x3D; tmp + pdf_5[j];
    cdf_5.append(tmp);
    print(i+1,cdf_5[i])
# out:
#75 0.4739047630777248
#76 0.571758477145268</code></pre>

<p>该模型的概率密度函数（蓝线）和分布函数（黄线）图：</p>
<p><img src="http://img.070077.xyz/%E5%8E%9F%E7%A5%9E%E6%8A%BD%E5%8D%A1%E6%A6%82%E7%8E%87%E5%88%86%E5%B8%83%E5%9B%BE.png" alt="img"></p>
<p>我们不妨乐观一点，中分位点：75.</p>
<p>注：最概然祈愿次数为77。也就是说，在第77次祈愿获取五星角色的概率最高。</p>
<p>每次获得五星角色，需要的祈愿次数记为$N$. 则：</p>
<ul>
<li>从期望角度考虑，N &#x3D; 62.3.</li>
<li>从中分位点角度考虑，N &#x3D; 75.</li>
</ul>
<p>实际理解为：需要75次祈愿，才能使获得5星角色的发生概率达到50%（实际：46.8%）。</p>
<p>这种分布具有较强的右偏性。上面分析过，这两个数字特征具有不同的分析意义，可以理解为：</p>
<ul>
<li>祈愿623次，期望获得10个五星角色。（期望值）</li>
<li>祈愿75次，能使获得五星角色的概率达到50%。</li>
</ul>
<h3 id="由期望特征进行资源规划"><a href="#由期望特征进行资源规划" class="headerlink" title="由期望特征进行资源规划"></a>由期望特征进行资源规划</h3><p>回到规则中，解决以下问题：</p>
<h4 id="获得五星角色A的期望次数分析"><a href="#获得五星角色A的期望次数分析" class="headerlink" title="获得五星角色A的期望次数分析"></a>获得五星角色A的期望次数分析</h4><p>对于期望分析：注意到，对于获取当期UP五星角色，最多需要2次获得五星角色。也就是说，有50%的概率，仅需要获取一次五星角色；有50%的概率，需要获取2次五星角色。也就是说，需要获得五星角色的次数：</p>
<p>$$ 1 \times 50% + 2 \times 50%  &#x3D; 1.5 $$</p>
<p>对于“获取五星角色”而言，多次获取（不论是否为当期UP角色）之间互相独立，因此需要的祈愿次数为$1.5 \times 62.3 &#x3D; 93.45$ 次。</p>
<h4 id="获得6命座A角色的期望次数分析"><a href="#获得6命座A角色的期望次数分析" class="headerlink" title="获得6命座A角色的期望次数分析"></a>获得6命座A角色的期望次数分析</h4><p>注意到，对于“获取五星角色”而言，多次获取（不论是否为当期UP角色）之间互相独立。考虑这个问题：对于“获取A角色”事件之间，是相互独立的吗？</p>
<p>从期望角度考虑，可以说：是的。参考上面的思路，只需要“获取A角色”发生7次即可。因此需要的祈愿次数为 $1.5N \times 7 &#x3D; 10.5N$ 也就是 654.15 次。</p>
<h4 id="获得四星角色B的期望次数分析"><a href="#获得四星角色B的期望次数分析" class="headerlink" title="获得四星角色B的期望次数分析"></a>获得四星角色B的期望次数分析</h4><p>由于涉及“基础概率”，我们沿用上一开源项目模型的概率递增保底机制结论：</p>
<ul>
<li><p>从第9次祈愿处开始上升。</p>
</li>
<li><p>获得五星角色并不会重置四星保底。</p>
</li>
</ul>
<p>第x次祈愿获得四星角色的概率如下：</p>
<p>$$ P(x) &#x3D; \begin{cases} 5.1% &amp; {x\leqslant8}\ 56.1% &amp;{x &#x3D; 9}\1&amp;{x &#x3D; 10} \end{cases}$$</p>
<p>$$ PDF(x) &#x3D; P(x) * \prod_{k &#x3D; 1}^{x - 1}1-P(x)  &#x3D; \begin{cases} (1 - 5.1%)^{x-1}\times5.1% &amp; {x\leqslant8}\ (1-5.1%)^8\times56.1% &amp;{x&#x3D;9}\(1-5.1%)^8\times43.9%&amp;{x &#x3D; 10} \end{cases}$$ </p>
<p>期望值：</p>
<p>$$ E(X) &#x3D; \sum_{i&#x3D;1}^{x}PDF(x)\times x &#x3D; 7.66$$ </p>
<p>综合概率：13.05%.</p>
<p>对于期望分析：注意到，对于获取当期UP五星角色，仅有$\frac{1}{3}$的概率得到当期UP的四星角色中的B，且每次获得当期四星角色时，有50%的概率，仅需要获取一次四星角色；有50%的概率，需要获取2次四星角色。也就是说，获得角色B的次数期望为$1.5 \times 3 \times E(X) &#x3D; 34.5$ 。</p>
<h3 id="由分位点特征进行分析"><a href="#由分位点特征进行分析" class="headerlink" title="由分位点特征进行分析"></a>由分位点特征进行分析</h3><p>从“概率的概率”角度分析便没有期望分析那么简单了。中位点与期望的乘积并不能得到叠加事件的中位点。基本上大部分分而治之的想法均不满足独立性要求。我们需要寻找更一般的数学模型：</p>
<h4 id="获得多次五星角色的分位点分析"><a href="#获得多次五星角色的分位点分析" class="headerlink" title="获得多次五星角色的分位点分析"></a>获得多次五星角色的分位点分析</h4><p>接下来，由于<strong>使获得两次五星角色的概率达到50%的祈愿次数不等于获得一次五星角色祈愿次数的中位点的2倍</strong>，我们需要计算分布的<strong>叠加</strong>。</p>
<p>我们从简单问题入手（自己编的）：</p>
<p>(1) 一直抛硬币，直到总共出现2次正面朝上，求期望的抛硬币次数——显然是4.</p>
<p>(2) 需要抛多少次硬币，使【至少出现2次正面朝上】的概率达到50%。</p>
<p>(3) 需要抛多少次骰子，使【至少出现2次点数1】的概率达到50%。</p>
<p>题目（2）（3）这类问题，可以转化成“几何分布的叠加问题”。这里的概率稳定<del>比较简单</del>，还可以参阅负二项分布有关资料。</p>
<p>而对于的祈愿的建模，概率不稳定，有三种可能的思考方向：一可以用模拟动态规划处理，二是对各种情况进行全概率公式展开（<del>工作量极大</del>），三是离散信号的进行卷积运算:$P(Z&#x3D;X+Y&#x3D;z) &#x3D; \sum_1^\infty PDF(X&#x3D;z-y)P(X&#x3D;y)$</p>
<p>笔者采用第三种方法。</p>
<p>各位修改一下代码的变量，即可获取想要的值。</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">c5_need &#x3D; 2#需要抽出几次五星角色；
c5_poss &#x3D; 0.25#想知道的概率;
conv &#x3D; pdf_5;
for cnt in range(0,c5_need - 1):
    conv&#x3D;np.convolve(conv,pdf_5,&#39;full&#39;)
    plt.plot(conv)
    tmp &#x3D; 0.0
    for i in range (0,len(conv)):
        tmp +&#x3D; conv[i]
        if(cnt &#x3D;&#x3D; c5_need - 2 and tmp &gt;&#x3D; c5_poss):
            print(i+c5_need);
            break
    #DEMO
    #135 -- 需要祈愿135次，才有50%的概率获得两个五星角色。
	#祈愿154次，有75%的概率获得两个五星角色。</code></pre>

<p>我对获得两次的情况列了个分布图：</p>
<p><img src="http://img.070077.xyz/%E5%8E%9F%E7%A5%9E%E6%8A%BD%E5%8D%A12%E6%AC%A1%E4%BA%94%E6%98%9F%E6%A6%82%E7%8E%87%E5%88%86%E5%B8%83%E5%9B%BE.png" alt="原神抽卡2次五星概率分布图"></p>
<h4 id="双角色池祈愿"><a href="#双角色池祈愿" class="headerlink" title="双角色池祈愿"></a>双角色池祈愿</h4><p>这个其实没什么太大的变化，把A2等价成A1，就可以和上文的A的结论统一了。</p>
<h2 id="保底依赖下的分位点分析"><a href="#保底依赖下的分位点分析" class="headerlink" title="保底依赖下的分位点分析"></a>保底依赖下的分位点分析</h2><h3 id="尝试1：将“保底获得的五星”和“祈愿次数”拆成两个独立事件"><a href="#尝试1：将“保底获得的五星”和“祈愿次数”拆成两个独立事件" class="headerlink" title="尝试1：将“保底获得的五星”和“祈愿次数”拆成两个独立事件"></a>尝试1：将“保底获得的五星”和“祈愿次数”拆成两个独立事件</h3><h4 id="保底之间的马尔可夫过程"><a href="#保底之间的马尔可夫过程" class="headerlink" title="保底之间的马尔可夫过程"></a>保底之间的马尔可夫过程</h4><p>由于角色祈愿机制满足：本次获取五星角色是否为A的概率仅取决于上次获取的五星角色是否为A。符合马尔可夫过程（状态$i$只取决于上一次状态$i-1$，与再先前的状态相互独立。参：课本P321）的建模标准，可以做出以下状态图和概率转移矩阵：</p>
<pre class="line-numbers language-mermaid" data-language="mermaid"><code class="language-mermaid">graph LR
A --1&#x2F;2--&gt; !A
!A --1--&gt; A
A --1&#x2F;2--&gt; A</code></pre>
<p>$$ M &#x3D; \space \begin{matrix}  &amp; A &amp; !A\A &amp; {1}\over{2} &amp; {1}\over{2}\!A &amp; 1 &amp; 0\end{matrix}$$</p>
<p>马尔可夫链在三门问题、经济学分析、自然语言处理等领域具有广泛的应用，在极值环境下具有平稳分布的特点。以下进行模拟分析。</p>
<p>收敛的综合概率：$M^\infty$。经过计算，可知A物品的综合概率为$\frac{2}{3}$ 。这个计算结果可以理解为：任意一次获得五星角色，有$\frac{2}{3}$的概率是A.（初始状况：刚获得A，以说明存在小保底）</p>
<p>而对于中间情况的分析，可对应转换为矩阵的乘法和加法运算。</p>
<p>但是我们很难把两个独立事件的概率组合到一起，以达到50%，请看下面的分析。</p>
<h4 id="分类讨论的方式求取概率"><a href="#分类讨论的方式求取概率" class="headerlink" title="分类讨论的方式求取概率"></a>分类讨论的方式求取概率</h4><p>我们以抽到零命为例，对应的状态矩阵为$M$。因为初始状态（你可以理解为-1命）为A，此时可以理解为对应的概率为：$p_{11}P(获得一次五星) +p_{12}(获得二次五星)$，其中获得两次五星的概率模型可参考上面的卷积公式（由于二次五星也比较简单，大可自己分类讨论写）,如：</p>
<p>$$ \frac{1}{2}PDF(X) + \frac{1}{2}PDF(Z)$$（注：x&gt;90的部分，记为0即可，因为那部分情况已结束。）</p>
<p>验证这一方法的正确性：</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">tmp &#x3D; 0.0
for i in range(0,179):
    if(i&lt;90): tmp +&#x3D; 0.5 * pdf_5[i];
    tmp+&#x3D;0.5*conv[i];
    if(tmp&gt;&#x3D;0.5):
        print(i);
        break;
&#x2F;&#x2F;沿用上方的数组了，输出为79.
因为列表下标是从0开始计数的，79 &lt; 90 ，所以对应：80次祈愿可使抽到UP五星的概率达到50%。</code></pre>

<p>如果需要制图，可以使用以下的画图模板代码</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">#制图代码
x_major_locator&#x3D;MultipleLocator(4)#x分度值设置
y_major_locator&#x3D;MultipleLocator(0.1)
ax&#x3D;plt.gca()
ax.xaxis.set_major_locator(x_major_locator)
ax.yaxis.set_major_locator(y_major_locator)
plt.grid()  # 生成网格
x_values &#x3D; [x for x in range(1, 91)]
y_values &#x3D; [pdf_5[x] for x in range(0, 90)]
plt.plot(x_values,y_values)</code></pre>

<p>如果是多命，则需要更复杂的分类讨论。如：一命的情况，就需要二次转移矩阵$M^2$的各项作为转移概率了，包括(A A ， A !A A ， !A A A ， !A A !A A)四种状态对应的状态转移概率，以及多次的卷积结果。由于前面代码没有记忆，就不尝试了。</p>
<h3 id="尝试2：动态规划的角度"><a href="#尝试2：动态规划的角度" class="headerlink" title="尝试2：动态规划的角度"></a>尝试2：动态规划的角度</h3><h4 id="抽到多个五星角色中UP五星角色的个数概率"><a href="#抽到多个五星角色中UP五星角色的个数概率" class="headerlink" title="抽到多个五星角色中UP五星角色的个数概率"></a>抽到多个五星角色中UP五星角色的个数概率</h4><p>其实上面的转移矩阵比较简单，直接可以写出状态转移方程，考虑动态规划。</p>
<p>定义状态$dp[i][j][1]$表示第 $i$ 次获得的五星角色时得到当期UP角色A后，共获得了$j$次A角色，达到$j-1$命 （第一次获得A角色达到0命）；类似地，$dp[i][j][0]$ 表示第 $i$ 次获得的五星角色不是A。</p>
<p>则状态转移方程：</p>
<p>$$ dp[i][j][0] &#x3D; \frac{1}{2}dp[i-1][j][1] $$</p>
<p>$$ dp[i][j][1] &#x3D; \frac{1}{2}dp[i-1][j-1][1] + dp[i-1][j-1][0]$$</p>
<p>起点：$dp[0][0][1] &#x3D; 1$</p>
<p>由此可以记$dp[i][j]$为第$i$次获得五星角色后共获得$j$次（及以上）A角色的概率，则：</p>
<p>$$ dp[i][j] &#x3D; \sum_{k&#x3D;j}^{i}dp[i][k][1]+dp[i][k][0] $$</p>
<p>尝试构造含$i,j,dp[i][j]$三个变量的图：<img src="http://img.070077.xyz/%E5%8E%9F%E7%A5%9E%E5%91%BD%E5%BA%A7%E6%8A%BD%E6%95%B0%E6%A6%82%E7%8E%87%E5%88%86%E5%B8%83%E5%9B%BE.png"></p>
<p>由图中可以估计获取1~7次A角色时，使概率达到50%时，横坐标即为需要获得A角色的次数。（x，y）表示，已获得x次五星角色的情况下，y为对应的总共获取次数大于等于对应i的概率。</p>
<h4 id="求取命座-祈愿次数概率"><a href="#求取命座-祈愿次数概率" class="headerlink" title="求取命座-祈愿次数概率"></a>求取命座-祈愿次数概率</h4><p>定义：$ dp[i][j][k] $ ：第j次祈愿的结果对应k，并第i次获得A角色的概率，则状态转移方程：</p>
<ul>
<li>大保底状态：上次五星!A，这次必获得A；</li>
<li>小保底状态：上次五星是A（初始状态），这次只有50%的概率获得A。</li>
<li>k &#x3D; 0 ： 获得五星角色A</li>
<li>k &#x3D; 1 ： 获得五星角色且!A</li>
</ul>
<p>（临时变量：tmp：上次获得五星的祈愿次数）</p>
<ul>
<li>注意：要明确状态转移的结果“from to”。循环遍历时，由j逐步+k确定后续值并进行迭代赋值，会导致一个点的值多次计入概率，所以最后取概率只需要取[0]</li>
</ul>
<p>$$ dp[i][j][0] &#x3D; dp[i-1][tmp][1] * PDF(j-tmp) + dp[i-1][tmp][0] * \frac{1}{2} * PDF(j-tmp)$$</p>
<p>$$ dp[i][j][1] &#x3D; dp[i][tmp][0] * \frac{1}{2} * PDF(j-tmp)$$</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">n5_cnt&#x3D;1;#要抽出多少次A
n5_tries&#x3D;180;#准备的祈愿次数
tmp &#x3D; 0;
dp_p &#x3D; np.zeros((13, 180*n5_cnt+90,2), dtype&#x3D;float);
dp_p[0][0][0] &#x3D; 1
for i in range (0,n5_cnt+1):
        for j in range (0,n5_tries):
            for k in range (1,91):
                if(i-1&gt;&#x3D;0):
                    dp_p[i][j+k][0] +&#x3D; dp_p[i-1][j][1] * pdf_5[k-1] + dp_p[i-1][j][0] * 0.5 * pdf_5[k-1];
                dp_p[i][j+k][1] +&#x3D; dp_p[i][j][0] * 0.5 * pdf_5[k-1]
poss&#x3D;[]
for i in range(0,n5_tries):
    tmp &#x3D; tmp + dp_p[n5_cnt][i][0]
    poss.append(tmp)
print(tmp)
plt.plot(poss)
#DEMO:0.4762677010731945</code></pre>

<p> 与上面的卷积验证是一致的。</p>
<p>0命概率图：<img src="http://img.070077.xyz/%E5%8E%9F%E7%A5%9E%E6%8A%BD%E5%8D%A12%E6%AC%A1%E4%BA%94%E6%98%9F%E6%A6%82%E7%8E%87%E5%88%86%E5%B8%83%E5%9B%BE.1png.png" alt="原神抽卡2次五星概率分布图.1png"></p>
<h4 id="非默认状态开始的动态规划（To-Be-Continued…）"><a href="#非默认状态开始的动态规划（To-Be-Continued…）" class="headerlink" title="非默认状态开始的动态规划（To Be Continued…）"></a>非默认状态开始的动态规划（To Be Continued…）</h4><p>如果开始状态为大保底状态，或已经有一定的祈愿次数呢？以后再写。</p>
<h2 id="四星角色祈愿分析"><a href="#四星角色祈愿分析" class="headerlink" title="四星角色祈愿分析"></a>四星角色祈愿分析</h2><p>预设：获取到五星时，不会重置四星角色的保底。且，以下策略，如果出了五星角色，先笑一笑，算法就当没祈愿哈~</p>
<h3 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h3><p>四星的分析只需要将上面的p_5相关改成p_4即可，在此省略不表，给出一定结论：<img src="http://img.070077.xyz/%E5%8E%9F%E7%A5%9E%E5%9B%9B%E6%98%9F%E8%A7%92%E8%89%B2pdfcdf.png" alt="原神四星角色pdfcdf"></p>
<p>0命图：<img src="http://img.070077.xyz/%E5%8E%9F%E7%A5%9E4%E6%98%9F0%E5%91%BD%E6%8A%BD%E6%95%B0%E6%A6%82%E7%8E%87%E5%88%86%E5%B8%83%E5%9B%BE.png" alt="原神4星0命抽数概率分布图"></p>
<h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><p>定义：$ dp[i][j][k] $ ：第j次祈愿的结果对应k，并第i次获得B角色的概率，则状态转移方程：</p>
<ul>
<li>保底状态：上次四星!UP，这次必获得UP角色</li>
<li>k &#x3D; 0 ： 获得想要的四星角色B</li>
<li>k &#x3D; 1 ： 获得UP四星角色但不是B</li>
<li>k &#x3D; 2：获得非UP四星角色</li>
</ul>
<p>（临时变量：tmp：上次获得四星的祈愿次数）</p>
<p>$$ dp[i][j][0] &#x3D; dp[i-1][tmp][1] * PDF(j-tmp) * \frac{1}{6} \+ dp[i-1][tmp][0] * \frac{1}{6} * PDF(j-tmp) \+ dp[i-1][tmp][1] * PDF(j-tmp) * \frac{1}{3}$$</p>
<p>$$ dp[i][j][1] &#x3D; dp[i][tmp][0] * \frac{1}{3} * PDF(j-tmp) \+ dp[i][tmp][1] * PDF(j-tmp) * \frac{1}{3} \+  dp[i][tmp][2] * \frac{2}{3} * PDF(j-tmp)$$</p>
<p>$$ dp[i][j][2] &#x3D; dp[i][tmp][0] * \frac{1}{2} * PDF(j-tmp) + dp[i][tmp][1] * \frac{1}{2} * PDF(j-tmp)$$</p>
<p>任意代码：（原理与下方“无定轨机制武器祈愿”类似，这里人比较懒，直接对p_5移花接木了）</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">#每抽概率
#这是研究四星的，但是为了偷懒，捏：
def p_5(n):
    if n &lt; 8:
        return 0.051;
    elif n &lt; 9:
        return 0.561;
    else:
        return 1;
        
pdf_5 &#x3D; [];
cdf_5 &#x3D; [];
tmp &#x3D; 0.0;

for i in range (0,10):
    tmp &#x3D; p_5(i);
    for j in range(0,i):
        tmp &#x3D; tmp * (1 - p_5(j))
    pdf_5.append(tmp);

for i in range (0,10):
    tmp &#x3D; 0.0;
    for j in range (0,i+1):
        tmp &#x3D; tmp + pdf_5[j];
    cdf_5.append(tmp);
    print(i+1,cdf_5[i])
 
n5_cnt&#x3D;1#要抽出多少次B
n5_tries&#x3D;130 * n5_cnt;#准备的祈愿次数
tmp &#x3D; 0;
dp_p &#x3D; np.zeros((13, 150*n5_cnt + 20,3), dtype&#x3D;float);
dp_p[0][0][0] &#x3D; 1
# 0 - B 1 - UP &amp; !B 2- !UP
for i in range (0,n5_cnt+1):
        for j in range (0,n5_tries):
            for k in range (1,11):
                if(i-1&gt;&#x3D;0):
                    dp_p[i][j+k][0] +&#x3D; dp_p[i-1][j][2] * pdf_5[k-1] * 1&#x2F;3\
                                    + dp_p[i-1][j][1] * pdf_5[k-1] * 1&#x2F;6 + dp_p[i-1][j][0] * 1&#x2F;6 * pdf_5[k-1];
                dp_p[i][j+k][1] +&#x3D; dp_p[i][j][0] * 1&#x2F;3 * pdf_5[k-1] + dp_p[i][j][2] * 2&#x2F;3 * pdf_5[k-1]\
                                + dp_p[i][j][1] * 1&#x2F;3 * pdf_5[k-1];
                dp_p[i][j+k][2] +&#x3D; dp_p[i][j][0] * 1&#x2F;2 * pdf_5[k-1] + dp_p[i][j][1] * 1&#x2F;2 * pdf_5[k-1];
poss&#x3D;[]
for i in range(0,n5_tries):
    tmp &#x3D; tmp + dp_p[n5_cnt][i][0]
    poss.append(tmp)
print(tmp)
#制图代码，直接cv用
x_major_locator&#x3D;MultipleLocator(10)#x分度值设置
y_major_locator&#x3D;MultipleLocator(0.1)
ax&#x3D;plt.gca()
ax.xaxis.set_major_locator(x_major_locator)
ax.yaxis.set_major_locator(y_major_locator)
x_values &#x3D; [x for x in range(1, n5_tries)]
plt.grid()  # 生成网格
plt.plot(poss)  </code></pre>



<h2 id="不同模型对比研究"><a href="#不同模型对比研究" class="headerlink" title="不同模型对比研究"></a>不同模型对比研究</h2><h3 id="与无保底机制（均匀1-6-）的对比"><a href="#与无保底机制（均匀1-6-）的对比" class="headerlink" title="与无保底机制（均匀1.6%）的对比"></a>与无保底机制（均匀1.6%）的对比</h3><p>​    修改</p>
<pre class="line-numbers language-none"><code class="language-none">def p_5(n):
	return 0.016;</code></pre>

<p>期望：不变；</p>
<p>分位点图：<img src="http://img.070077.xyz/%E5%9D%87%E5%8C%801.6%E5%8E%9F%E7%A5%9E%E6%8A%BD%E5%8D%A1%E6%A6%82%E7%8E%87%E5%88%86%E5%B8%83%E5%9B%BE.png" alt="均匀1.6原神抽卡概率分布图"></p>
<p>极端情况上升了~</p>
<p>两次五星分布图：<img src="http://img.070077.xyz/%E5%9D%87%E5%8C%801.6%E5%8E%9F%E7%A5%9E%E6%8A%BD%E5%8D%A12%E6%AC%A1%E4%BA%94%E6%98%9F%E6%A6%82%E7%8E%87%E5%88%86%E5%B8%83%E5%9B%BE.png" alt="均匀1.6原神抽卡2次五星概率分布图"></p>
<p>一命概率分布图：<img src="http://img.070077.xyz/%E5%9D%87%E5%8C%801.6%E5%8E%9F%E7%A5%9E%E6%8A%BD%E5%8D%A1%E4%B8%80%E5%91%BD%E6%A6%82%E7%8E%87%E5%88%86%E5%B8%83%E5%9B%BE.png" alt="均匀1.6原神抽卡一命概率分布图"></p>
<p>可以发现，均匀和非均匀，有利有弊吧。</p>
<h3 id="与保底前均匀机制（魔改尝试1）的对比"><a href="#与保底前均匀机制（魔改尝试1）的对比" class="headerlink" title="与保底前均匀机制（魔改尝试1）的对比"></a>与保底前均匀机制（魔改尝试1）的对比</h3><p>用我比较熟悉的c++建模以下（其实更精确的值为0.88%）</p>
<p>$$  P(x) &#x3D; \begin{cases} 0.9% &amp;{x\leqslant 89}\1&amp;{x &#x3D; 90} \end{cases} $$</p>
<p>期望：62.06（综合概率：1.61%）</p>
<p>分位点分布图：</p>
<p><img src="http://img.070077.xyz/%E9%AD%94%E6%94%B91.6%E5%8E%9F%E7%A5%9E%E6%8A%BD%E5%8D%A1%E6%A6%82%E7%8E%87%E5%88%86%E5%B8%83%E5%9B%BE.png" alt="魔改1.6原神抽卡概率分布图"></p>
<p>两次五星分布图：<img src="http://img.070077.xyz/%E9%AD%94%E6%94%B91.6%E5%8E%9F%E7%A5%9E%E6%8A%BD%E5%8D%A12%E6%AC%A1%E4%BA%94%E6%98%9F%E6%A6%82%E7%8E%87%E5%88%86%E5%B8%83%E5%9B%BE.png" alt="魔改1.6原神抽卡2次五星概率分布图"></p>
<p>一命概率分布图：<img src="http://img.070077.xyz/%E9%AD%94%E6%94%B91.6%E5%8E%9F%E7%A5%9E%E6%8A%BD%E5%8D%A1%E4%B8%80%E5%91%BD%E6%A6%82%E7%8E%87%E5%88%86%E5%B8%83%E5%9B%BE.png" alt="魔改1.6原神抽卡一命概率分布图"></p>
<p>会让更多人吃保底~</p>
<h1 id="武器祈愿分析"><a href="#武器祈愿分析" class="headerlink" title="武器祈愿分析"></a>武器祈愿分析</h1><h2 id="概率递增保底机制及数字特征"><a href="#概率递增保底机制及数字特征" class="headerlink" title="概率递增保底机制及数字特征"></a>概率递增保底机制及数字特征</h2><p>武器祈愿的机制和角色祈愿大体一致。算法参上，在此直接给出结论。</p>
<p>五星武器概率：</p>
<p>$$P(x) &#x3D; \begin{cases}0.7% &amp; x\leqslant62\0.7%+7%(x-62) &amp; 63\leqslant x \leqslant 71\ 63.7% + 3.5%(x-71) &amp; 72\leqslant x \leqslant 79 \ 1 &amp; x&#x3D;80\end{cases}$$ </p>
<p>数学期望：54.25.</p>
<p>综合概率：1.88%</p>
<p>分布图：<img src="http://img.070077.xyz/%E5%8E%9F%E7%A5%9E%E6%AD%A6%E5%99%A8%E6%8A%BD%E5%8D%A1%E6%A6%82%E7%8E%87%E5%88%86%E5%B8%83%E5%9B%BE.png" alt="原神武器抽卡概率分布图"></p>
<p>四星武器概率</p>
<p>$$P(x) &#x3D; \begin{cases}6% &amp; x\leqslant 7\66% &amp; x &#x3D; 8 \ 96% &amp; x &#x3D; 9 \ 1 &amp; x&#x3D;10\end{cases}$$</p>
<p>数学期望：6.74.</p>
<p>综合概率：14.84%。</p>
<p>你会发现，分成了四段，复杂了一点。</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">#每抽概率
def p_5(n):
    if n &lt; 62:
        return 0.007;
    elif n &lt; 71:
        return 0.007 + (n - 62) * 0.07;
    elif n &lt; 79:
        return 0.637 + (n - 71) * 0.035;
    else:
        return 1.0;
def p_4(n):
    if n &lt; 7:
        return 0.06
    elif n &lt; 8:
        return 0.66
    elif n &lt; 9:
        return 0.96;
    else:
        return 1;
pdf_5 &#x3D; [];#第x+1抽出概率
cdf_5 &#x3D; [];
tmp &#x3D; 0.0;

for i in range (0,80):
    tmp &#x3D; p_5(i);
    for j in range(0,i):
        tmp &#x3D; tmp * (1.0 - p_5(j))
    pdf_5.append(tmp);

for i in range (0,80):
    tmp &#x3D; 0.0;
    for j in range (0,i+1):
        tmp &#x3D; tmp + pdf_5[j];
    cdf_5.append(tmp);
    print(i+1,cdf_5[i])</code></pre>



<h2 id="定轨机制下的资源规划（假设定轨M）"><a href="#定轨机制下的资源规划（假设定轨M）" class="headerlink" title="定轨机制下的资源规划（假设定轨M）"></a>定轨机制下的资源规划（假设定轨M）</h2><h3 id="获取五星武器M的祈愿次数分析"><a href="#获取五星武器M的祈愿次数分析" class="headerlink" title="获取五星武器M的祈愿次数分析"></a>获取五星武器M的祈愿次数分析</h3><p>由于命定值机制，马尔可夫过程比较复杂。于是考虑动态规划：</p>
<p>定义$dp[i][j][k]$为第j次祈愿时第i次获得五星武器M，祈愿后k：</p>
<ul>
<li>k &#x3D; 0 : 命定值为0。表示抽到了M.</li>
<li>k &#x3D; 1：命定值为1且抽到了N.</li>
<li>k &#x3D; 2：命定值为1且抽到的是非UP武器。</li>
<li>k &#x3D; 3：命定值为2，抽出来的不是M，具体是啥在本小节中不相关。</li>
</ul>
<p>$$ dp[i][j][0] &#x3D; dp[i-1][tmp][0] * \frac{3}{8} *PDF(j-tmp) \+ dp[i-1][tmp][1] * \frac{3}{8} * PDF(j-tmp) \+ dp[i-1][tmp][2] * \frac{1}{2}*PDF(j-tmp) \+ dp[i-1][tmp][3] *PDF(j-tmp)$$</p>
<p>$$ dp[i][j][1] &#x3D; dp[i][tmp][0] <em>\frac{1}{4}</em> PDF(j-tmp)$$</p>
<p>$$ dp[i][j][2] &#x3D; dp[i][tmp][0] <em>\frac{3}{8}</em> PDF(j-tmp)$$</p>
<p>$$ dp[i][j][3] &#x3D; dp[i][tmp][1] * ( \frac{3}{8} + \frac{1}{4}) *PDF(j-tmp) \ + dp[i][tmp][2] * \frac{1}{2} * PDF(j-tmp)$$</p>
<p>运行代码：</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">n5_cnt&#x3D;2;#要抽出多少次M
n5_tries&#x3D; 207;#准备的祈愿次数
tmp &#x3D; 0;
dp_p &#x3D; np.zeros((13, 330*n5_cnt,5), dtype&#x3D;float);
dp_p[0][0][0] &#x3D; 1
for i in range (0,n5_cnt+1):
        for j in range (0,n5_tries + n5_cnt + 1):
            for k in range (1,81):
                if(i-1&gt;&#x3D;0):
                    dp_p[i][j+k][0] +&#x3D; dp_p[i-1][j][0] * pdf_5[k-1] * 0.375\
                                + dp_p[i-1][j][1] * 0.375 * pdf_5[k-1] \
                                + dp_p[i-1][j][2] * 0.5 * pdf_5[k-1]\
                                + dp_p[i-1][j][3] * pdf_5[k-1];
                dp_p[i][j+k][1] +&#x3D; dp_p[i][j][0] * 0.25 * pdf_5[k-1];
                dp_p[i][j+k][2] +&#x3D; dp_p[i][j][0] * 0.375 * pdf_5[k-1];
                dp_p[i][j+k][3] +&#x3D; dp_p[i][j][1] * 0.625 * pdf_5[k-1]\
                                + dp_p[i][j][2] * 0.5 * pdf_5[k-1];
poss&#x3D;[]
for i in range(0,n5_tries):
    tmp &#x3D; tmp + dp_p[n5_cnt][i][0]
    poss.append(tmp)
print(tmp)
plt.plot(poss)
#0.49317051582855165</code></pre>

<p>进行99次祈愿后，获得M的概率达到50%。以下是获取一次武器M的概率分布图：</p>
<p><img src="http://img.070077.xyz/%E5%8E%9F%E7%A5%9E%E6%AD%A6%E5%99%A8m%E6%8A%BD%E5%8D%A1%E6%A6%82%E7%8E%87%E5%88%86%E5%B8%83%E5%9B%BE.png" alt="原神武器m抽卡概率分布图"></p>
<h3 id="获取五星武器N的祈愿次数分析"><a href="#获取五星武器N的祈愿次数分析" class="headerlink" title="获取五星武器N的祈愿次数分析"></a>获取五星武器N的祈愿次数分析</h3><p>问题：我定轨了M，反而想获取五星武器N…（反向定轨）</p>
<p>定义$dp[i][j][k]$为第j次祈愿时第i次获得五星武器N，祈愿后k：</p>
<ul>
<li>k &#x3D; 0 : 命定值为0。表示抽到了M.</li>
<li>k &#x3D; 1：命定值为1且抽到了N.</li>
<li>k &#x3D; 2：命定值为1且抽到的是非UP武器。</li>
<li>k &#x3D; 3：命定值为2，且抽到了N.</li>
<li>k &#x3D; 4：命定值为2，且抽到的是非UP武器。</li>
</ul>
<p>$$ dp[i][j][0] &#x3D; dp[i][tmp][0] * \frac{3}{8} *PDF(j-tmp) \ + dp[i][tmp][1] * \frac{3}{8} * PDF(j-tmp) \+ dp[i][tmp][2] * \frac{1}{2}*PDF(j-tmp) \+ dp[i][tmp][3] * PDF(j-tmp) \ + dp[i][tmp][4] * PDF(j-tmp)$$</p>
<p>$$ dp[i][j][1] &#x3D; dp[i-1][tmp][0] <em>\frac{3}{8}</em> PDF(j-tmp)$$</p>
<p>$$ dp[i][j][2] &#x3D; dp[i][tmp][0] <em>\frac{1}{4}</em> PDF(j-tmp)$$</p>
<p>$$ dp[i][j][3] &#x3D; dp[i-1][tmp][1] * ( \frac{3}{8}) * PDF(j-tmp) \ + dp[i-1][tmp][2] * \frac{1}{2} * PDF(j-tmp)$$</p>
<p>$$ dp[i][j][4] &#x3D; dp[i][tmp][1] * \frac{1}{4} * PDF(j-tmp)$$</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">n5_cnt&#x3D;1;#要抽出多少次N
n5_tries&#x3D; 106;#准备的祈愿次数
tmp &#x3D; 0;
dp_p &#x3D; np.zeros((13, 510*n5_cnt + 80,5), dtype&#x3D;float);
dp_p[0][0][0] &#x3D; 1
for i in range (0,n5_cnt+1):
        for j in range (0,n5_tries + n5_cnt + 1):
            for k in range (1,81):
                dp_p[i][j+k][0] +&#x3D; dp_p[i][j][0] * pdf_5[k-1] * 0.375\
                                + dp_p[i][j][1] * 0.375 * pdf_5[k-1] \
                                + dp_p[i][j][2] * 0.5 * pdf_5[k-1]\
                                + dp_p[i][j][3] * pdf_5[k-1]\
                                + dp_p[i][j][4] * pdf_5[k-1];
                dp_p[i][j+k][1] +&#x3D; dp_p[i-1][j][0] * 0.375 * pdf_5[k-1];
                dp_p[i][j+k][2] +&#x3D; dp_p[i][j][0] * 0.25 * pdf_5[k-1];
                dp_p[i][j+k][3] +&#x3D; dp_p[i-1][j][1] * 0.375 * pdf_5[k-1]\
                                + dp_p[i-1][j][2] * 0.5 * pdf_5[k-1];
                dp_p[i][j+k][4] +&#x3D; dp_p[i][j][1] * 0.25 * pdf_5[k-1]
poss&#x3D;[]
for i in range(0,n5_tries):
    tmp &#x3D; tmp + dp_p[n5_cnt][i][1] + dp_p[n5_cnt][i][3]
    poss.append(tmp)
print(tmp)
#DEMO:0.5007747697175682</code></pre>

<p>图表</p>
<p>​    <img src="http://img.070077.xyz/%E5%8E%9F%E7%A5%9E%E6%AD%A6%E5%99%A8n%E6%8A%BD%E5%8D%A1%E6%A6%82%E7%8E%87%E5%88%86%E5%B8%83%E5%9B%BE.png" alt="原神武器n抽卡概率分布图"></p>
<h3 id="获取五星武器M、N的祈愿次数分析（To-Be-Updated…"><a href="#获取五星武器M、N的祈愿次数分析（To-Be-Updated…" class="headerlink" title="获取五星武器M、N的祈愿次数分析（To Be Updated…)"></a>获取五星武器M、N的祈愿次数分析（To Be Updated…)</h3><p>问题：我定轨了M，但M、N都想要。</p>
<p>我可能比较蠢：四维动态规划？</p>
<p>定义$dp[h][i][j][k]$为第j次祈愿时第i次获得五星武器N，第h获得五星武器M，祈愿后k：……（同上）</p>
<p>呃，我们先不考虑土豪了哈，我们只考虑都只获得1次的情况，只需要把<code>tmp = tmp + dp_p[n5_cnt][i][1] + dp_p[n5_cnt][i][3]</code> 再加一项 <code>dp_p[n5_cnt][i][0]</code> ？</p>
<p>我也希望这能成功，但是这么直接地不可行，因为前面那两项的概率本身就包含了上一次抽到M的情况，再加会导致重复计算，我没想到别的方式改良之。</p>
<p>另一种思路是分类讨论了，分为先获得M后获得N、先获得N再获得M两种情况。</p>
<p>再者就是还是含泪：</p>
<ul>
<li>需要做出一定的修改，使状态转移时，不忽略h的出现次数。</li>
</ul>
<p>$$ dp[h][i][j][0] &#x3D; dp[h-1][i][tmp][0] * \frac{3}{8} *PDF(j-tmp) \ + dp[h-1][i][tmp][1] * \frac{3}{8} * PDF(j-tmp) \+ dp[h-1][i][tmp][2] * \frac{1}{2}*PDF(j-tmp) \+ dp[h-1][i][tmp][3] * PDF(j-tmp) \ + dp[h-1][i][tmp][4] * PDF(j-tmp)$$</p>
<p>$$ dp[h][i][j][1] &#x3D; dp[h][i-1][tmp][0] <em>\frac{3}{8}</em> PDF(j-tmp)$$</p>
<p>$$ dp[h][i][j][2] &#x3D; dp[h][i][tmp][0] <em>\frac{1}{4}</em> PDF(j-tmp)$$</p>
<p>$$ dp[h][i][j][3] &#x3D; dp[h][i-1][tmp][1] * ( \frac{3}{8}) * PDF(j-tmp) \ + dp[h][i-1][tmp][2] * \frac{1}{2} * PDF(j-tmp)$$</p>
<p>$$ dp[h][i][j][4] &#x3D; dp[h][i][tmp][1] * \frac{1}{4} * PDF(j-tmp)$$</p>
<p>事实证明上面的方法不一定获得了正确答案。这个错误是没有价值的吗，不，他可能会给一个同样想研究这一问题的人一个参考。于是提出下面的形式：</p>
<p>定义$dp[i][j][k]$为第j次祈愿时，i - 获得的目标种类数 , 祈愿后k同上。</p>
<p>其实关键原因和上面的“加一项”一样，就是因为最后获取概率时，需要涵盖多个状态。以前的动态规划获取概率时，获取的状态间互相不存在依赖，而这次获取概率时，各个状态内部的转移存在相关。</p>
<p>最近灵感较为枯竭，先赶别的ddl了。在此附上可能是错误的代码（若考虑较大次数，可能需修改码参数&#x2F;概率不准确）和运行结果：</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">n5_cnt_M&#x3D;1;#要抽出多少次M,N
n5_cnt_N&#x3D;1;
n5_cnt&#x3D;n5_cnt_M + n5_cnt_N;
n5_tries&#x3D; 180*n5_cnt;#准备的祈愿次数
tmp &#x3D; 0;
dp_p &#x3D; np.zeros((13,13, 310*n5_cnt + 80,5), dtype&#x3D;float);
dp_p[0][0][0][0] &#x3D; 1

h &#x3D; 0;
for h in range (0,3*n5_cnt_M +1):
    for i in range(0,3*n5_cnt_N+1):
        for j in range (0,n5_tries + n5_cnt + 1):
            for k in range (1,81):
                    dp_p[h][i][j+k][0] +&#x3D; dp_p[h-1][i][j][0] * pdf_5[k-1] * 0.375\
                                + dp_p[h-1][i][j][1] * 0.375 * pdf_5[k-1] \
                                + dp_p[h-1][i][j][2] * 0.5 * pdf_5[k-1]\
                                + dp_p[h-1][i][j][3] * pdf_5[k-1]\
                                + dp_p[h-1][i][j][4] * pdf_5[k-1];
                    dp_p[h][i][j+k][1] +&#x3D; dp_p[h][i-1][j][0] * 0.375 * pdf_5[k-1];
                    dp_p[h][i][j+k][2] +&#x3D; dp_p[h][i][j][0] * 0.25 * pdf_5[k-1];
                    dp_p[h][i][j+k][3] +&#x3D; dp_p[h][i-1][j][1] * 0.375 * pdf_5[k-1]\
                                + dp_p[h][i-1][j][2] * 0.5 * pdf_5[k-1];
                    dp_p[h][i][j+k][4] +&#x3D; dp_p[h][i][j][1] * 0.25 * pdf_5[k-1]

poss&#x3D;[]
for i in range(0,n5_tries):
    for i1 in range (n5_cnt_M,3*n5_cnt_M+1):
        tmp +&#x3D; dp_p[i1][n5_cnt_N][i][1] + dp_p[i1][n5_cnt_N][i][3]
    for i2 in range(n5_cnt_N,3*n5_cnt_N+1):
        tmp +&#x3D; dp_p[n5_cnt_M][i2][i][0];
    poss.append(tmp)
print(tmp)
#制图代码，直接cv用
x_major_locator&#x3D;MultipleLocator(20)#x分度值设置
y_major_locator&#x3D;MultipleLocator(0.1)
ax&#x3D;plt.gca()
ax.xaxis.set_major_locator(x_major_locator)
ax.yaxis.set_major_locator(y_major_locator)
plt.grid()  # 生成网格
plt.plot(poss)</code></pre>

<p><img src="http://img.070077.xyz/%E5%8E%9F%E7%A5%9E%E6%AD%A6%E5%99%A8m%E4%B8%94n%E6%8A%BD%E5%8D%A1%E6%A6%82%E7%8E%87%E5%88%86%E5%B8%83%E5%9B%BE.png" alt="原神武器m且n抽卡概率分布图"></p>
<p>拓展问题：我先定轨了M，获取M后定轨N（命定值清零），参考上面两个问题叠加应该可以。</p>
<h3 id="四星武器的分析"><a href="#四星武器的分析" class="headerlink" title="四星武器的分析"></a>四星武器的分析</h3><p>和上面四星角色祈愿分析思想一致。</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">#偷懒：p_5的内容实际是p_4
n5_cnt&#x3D;1#要抽出多少次F
n5_tries&#x3D;130 * n5_cnt;#准备的祈愿次数
tmp &#x3D; 0;
dp_p &#x3D; np.zeros((13, 150*n5_cnt + 20,3), dtype&#x3D;float);
dp_p[0][0][0] &#x3D; 1
# 0 - F 1 - UP &amp; !F 2- !UP
for i in range (0,n5_cnt+1):
        for j in range (0,n5_tries):
            for k in range (1,11):
                if(i-1&gt;&#x3D;0):
                    dp_p[i][j+k][0] +&#x3D; dp_p[i-1][j][2] * pdf_5[k-1] * 1&#x2F;5\
                                    + dp_p[i-1][j][1] * pdf_5[k-1] * 3&#x2F;20 + dp_p[i-1][j][0] * 3&#x2F;20 * pdf_5[k-1];
                dp_p[i][j+k][1] +&#x3D; dp_p[i][j][0] * 3&#x2F;5 * pdf_5[k-1] + dp_p[i][j][2] * 4&#x2F;5 * pdf_5[k-1]\
                                + dp_p[i][j][1] * 3&#x2F;5 * pdf_5[k-1];
                dp_p[i][j+k][2] +&#x3D; dp_p[i][j][0] * 1&#x2F;4 * pdf_5[k-1] + dp_p[i][j][1] * 1&#x2F;4 * pdf_5[k-1];
poss&#x3D;[]
for i in range(0,n5_tries):
    tmp &#x3D; tmp + dp_p[n5_cnt][i][0]
    poss.append(tmp)
print(tmp)
#制图代码，直接cv用
x_major_locator&#x3D;MultipleLocator(10)#x分度值设置
y_major_locator&#x3D;MultipleLocator(0.1)
ax&#x3D;plt.gca()
ax.xaxis.set_major_locator(x_major_locator)
ax.yaxis.set_major_locator(y_major_locator)
x_values &#x3D; [x for x in range(1, n5_tries)]
plt.grid()  # 生成网格
plt.plot(poss)  </code></pre>

<p><img src="http://img.070077.xyz/%E5%8E%9F%E7%A5%9E%E5%9B%9B%E6%98%9F%E6%AD%A6%E5%99%A8f%E6%8A%BD%E5%8D%A1%E6%A6%82%E7%8E%87%E5%88%86%E5%B8%83%E5%9B%BE.png" alt="原神四星武器f抽卡概率分布图"></p>
<h2 id="无定轨机制下武器祈愿分析"><a href="#无定轨机制下武器祈愿分析" class="headerlink" title="无定轨机制下武器祈愿分析"></a>无定轨机制下武器祈愿分析</h2><p>和上面四星角色祈愿分析思想一致。<img src="http://img.070077.xyz/%E5%8E%9F%E7%A5%9E%E6%AD%A6%E5%99%A8m%E4%B8%8D%E5%AE%9A%E8%BD%A8%E6%8A%BD%E5%8D%A1%E6%A6%82%E7%8E%87%E5%88%86%E5%B8%83%E5%9B%BE.png" alt="原神武器m不定轨抽卡概率分布图"></p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">#这次下面是真的武器池概率分布p_5了哈
n5_cnt&#x3D;1#要抽出多少次M
n5_tries&#x3D;240 * n5_cnt;#准备的祈愿次数
tmp &#x3D; 0;
dp_p &#x3D; np.zeros((13, 320*n5_cnt + 20,3), dtype&#x3D;float);
dp_p[0][0][0] &#x3D; 1
# 0 - M 1 - UP &amp; !M 2- !UP
for i in range (0,n5_cnt+1):
        for j in range (0,n5_tries):
            for k in range (1,81):
                if(i-1&gt;&#x3D;0):
                    dp_p[i][j+k][0] +&#x3D; dp_p[i-1][j][2] * pdf_5[k-1] * 1&#x2F;2 \
                                    + dp_p[i-1][j][1] * pdf_5[k-1] * 3&#x2F;8 + dp_p[i-1][j][0] * 3&#x2F;8 * pdf_5[k-1];
                dp_p[i][j+k][1] +&#x3D; dp_p[i][j][0] * 3&#x2F;8 * pdf_5[k-1] + dp_p[i][j][2] * 1&#x2F;2 * pdf_5[k-1]\
                                + dp_p[i][j][1] * 3&#x2F;8 * pdf_5[k-1];
                dp_p[i][j+k][2] +&#x3D; dp_p[i][j][0] * 1&#x2F;4 * pdf_5[k-1] + dp_p[i][j][1] * 1&#x2F;4 * pdf_5[k-1];
poss&#x3D;[]
for i in range(0,n5_tries):
    tmp &#x3D; tmp + dp_p[n5_cnt][i][0]
    poss.append(tmp)
print(tmp)
#制图代码，直接cv用
x_major_locator&#x3D;MultipleLocator(15)#x分度值设置
y_major_locator&#x3D;MultipleLocator(0.1)
ax&#x3D;plt.gca()
ax.xaxis.set_major_locator(x_major_locator)
ax.yaxis.set_major_locator(y_major_locator)
x_values &#x3D; [x for x in range(1, n5_tries)]
plt.grid()  # 生成网格
plt.plot(poss)  </code></pre>

<p>你如果和上面定轨时比较，会发现你想要M的话，需要投入稍微更多的抽数。而且可以看见，当投入200抽时，定轨机制下的获取M的概率已经逐步收敛至1。而不定轨机制下，获取到的概率的概率仅在80%附近，且之后收敛较慢，极端情况的发生概率并不低。</p>
<p>有关不定轨又同时想要M和N的，TBC…</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>概率分析还可以分析：如何配置属性让伤害最大化等问题。概率论作为一种打破人的直觉的东西，实在是让人又爱又恨。本文不仅仅局限于传统的期望范畴，结合具体概率的分布分析了对应的抽数需求。由于祈愿机制的概率不是恒定的，期望与中分位点存在区别，可以用平均GDP和中位数来感受。</p>
<p>致谢：感谢张老师的帮助和OneBST的分享。</p>
<p>【To Be Continued】</p>
<ul>
<li><p>同时研究多个四星的祈愿次数</p>
</li>
<li><p>常驻祈愿结合“联动规则”的分析</p>
</li>
<li><p>常驻祈愿与UP祈愿结合分析</p>
</li>
<li><p>蒙特卡罗模拟与大数定律</p>
</li>
<li><p>通过置信度研究极端情况</p>
</li>
</ul>
]]></content>
      <categories>
        <category>数据分析</category>
      </categories>
      <tags>
        <tag>原神,数据分析</tag>
      </tags>
  </entry>
</search>
