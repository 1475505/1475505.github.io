---
title: 算法模板
---



# 回溯法

[TOC]

解决一个回溯问题，实际上就是一个决策树的遍历过程，使用 `isValid` 函数剪枝。回溯算法模板框架如下：

```cpp
void backtracking(参数) {
    if (结束遍历条件) {
        存放结果;
        return;
    }

    for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) {
        if (!isValid(..)) 	continue;//// 排除不合法选择
        处理节点;
        backtracking(路径，选择列表); // 深入
        撤销节点处理；
    }
}
```

对于`isValid`函数及剪枝策略，回溯法求最值时，可以通过贪心思想找到一个“较优解”，减去差于其的枝。(分支限界法)

回溯与 DFS 的思想很类似，区别主要在于解空间的表示和处理：

```cpp
for 循环内：
record[son] = 1; // 标记使用/状态
dfs(deep + 1); // dfs 下一层
record[son] = 0; // 取消标记/状态
```

**在递归之前做出选择，在递归之后撤销刚才的选择**。

解空间的状态表示主要有： 排列树 和 组合树 两种。

![回溯算法理论基础](https://img-blog.csdnimg.cn/20210130173631174.png)

口诀：for循环，换子树；递归调用往深溯

## 示例：生成全排列

![img](https://github.com/labuladong/fucking-algorithm/raw/master/pictures/backtracking/3.jpg)

## n-皇后问题的 位运算解法 及 bitset 包

### bitset

bitset 头文件中，有一种类似数组的结构，它的每一个元素只能是０或１，每个元素仅用１bit空间，名为 bitset 。构造方式：

```cpp
    bitset<4> bitset1;　　//无初始化下，默认每一位均为0
    bitset<8> bitset2(16);　//保存长度为8的16的二进制表示：[00010000]
    string s = "10010";
    bitset<8> bitset3(s);　　//长度为10，前补0。[00010010]
```



bitset 支持一些按位的位运算，且支持to_string类型转换。

对于一个叫做bit的bitset：
bit.size()       返回大小（位数）
bit.count()     返回1的个数
bit.any()       返回是否有1
bit.none()      返回是否没有1
bit.set()       全都变成1
bit.set(p)      将第p + 1位变成1（bitset是从第0位开始的！） 
bit.set(p, x)   将第p + 1位变成x
bit.reset()     全都变成0
bit.reset(p)    将第p + 1位变成0
bit.flip()      全都取反
bit.flip(p)     将第p + 1位取反
bit.to_ulong()  返回它转换为unsigned long的结果，如果超出范围则报错
bit.to_ullong() 返回它转换为unsigned long long的结果，如果超出范围则报错

