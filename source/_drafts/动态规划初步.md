---
title:		动态规划初步
tags:		dp
categories:	算法基础	
permalink:  https://oi-wiki.org/dp/knapsack/	
---
# 动态规划初步

[toc]



## 基本思路

动态规划实际是“聪明地枚举”，会遍历所有可能的情况。对其中的“剪枝”（不丢失最优解）属于贪心的范畴，可能提高了“溯源”的难度。

首先注意：动态规划不是说一上来就写状态转移方程（直接做“备忘录”），而是逐步分析，如下：

分析最优子结构 -> 递推公式 -> 自底向上求解（初始化、状态转移）

分析技巧： 递归树、状态转移图

调试技巧：打印 dp 数组

如果需要“溯源”，可以开一个新数组标记。

由于需要状态转移，一般数组下标从1开始，对应的`dp`数组也开有“安全空间"。

### 背包 dp

####背包问题的基本状态转移方程

f[j] 表示处理到当前物品 i 时背包容量为 j 的最大价值，得出以下方程：

![image-20210806174605728](C:\Users\ll\blog\source\_posts\贴图\20210806dp1.png)

#### 0-1背包问题

注意：关于 j 的循环是逆向的。**为了保证物品i只被放入一次！**从后往前循环，每次取得状态**不会和之前取得状态重合**（也就是要求子问题之间互相独立），这样每种物品就只取一次了。

```C++
for (int i = 0; i < n; i++) {
        for (int j = m; j >= w[i]; j--) {
            dp[j] = max(dp[j], dp[j - w[i]] + v[i]);
        }
    }
```

#### 0-1背包问题打印方案

对于滚动数组方法，由于少存储了很多数据，所以很难溯源。

我们先来看二维情况下，背包问题的循环遍历顺序：

1.当然，传统地（i++,j++）是可行的。并且可以边读边计算。

2.**先遍历容量，再遍历物品，也是可以的！**虽然两个for循环遍历的次序不同，但是`dp[i][j]`所需要的状态来自左上角，不影响`dp[i][j]`的下标和状态转移。

3.能否**逆序遍历物品**？需要经过小小地修改。此时，用dp[i,j]表示 把第 i, i＋1, i＋2,…, n 个物品装到容量为j的背包中的最大总重量。也就是说，“对称”了一下：

由于下标的意义变化，其状态转移方程也要发生改变：

```cpp
for(i = n; i >= 1; i--)
for(j = 0; j <= C; j++) 
if(j >= V[i]) 
	d[i][j]=max(d[i+1][j],d[i＋1][j－V[i]]＋W[i]);//！
else  
    d[i][j]= d[i+1][j]；
```

当然，最后我们的输出的结果也就为最终的 `dp[1][C]`了。

我们可以总结一下：循环的遍历顺序和状态转移的方向最好是对应的！这和我们提到过的子问题之间互相独立也是一致的。

4.能否**逆序遍历容量**？类似于3的思路，但比较难理解，略。



对于打印方案，可以按照（i++，j++）的方案结合标志数组记录回溯，如果有**字典序最小**的要求，最终需要`reverse`；另一种想法是上面的第3点，不需要`reverse`。以下是示例代码：

```cpp
int dp[MAX_N][MAX_N];
int dp_d[MAX_N][MAX_N];
int N, V;//n - 物品数，v - 容量（体积） w - 价值
vector<int> w(1, 0);
vector<int> v(1, 0);

int main() {
    //INPUT
    memset(dp, 0, sizeof dp);
    memset(dp_d, 0, sizeof dp_d);

	//DP
    for (int i = N; i > 0; i--) {
        for (int j = 0; j <= V; j++) {
            int noti = dp[i + 1][j];
            int geti = j >= v[i] ? dp[i + 1][j - v[i]] + w[i] : 0;
            //for (int j = v[i]; j <= V; j++)不可！why？遍历不完全！（dp本质）
            if (noti > geti) {//不能用>= 不然多解时会出错
                dp[i][j] = noti;
                dp_d[i][j] = 1;
            } else {
                dp[i][j] = geti;
                dp_d[i][j] = 2;
            }
        }
    }
    //DP_D
    vector<int> ans;
    int i = 1 ,  j = V;
    while (i <= N && j > 0) {
        switch (dp_d[i][j]) {
            case 1:
                i++;
                break;
            case 2:
                if (j >= v[i])//一个补丁，bug以后补坑
                    ans.push_back(i);
                j -= v[i];
                i++;
                break;
        }
    }
    for (auto i : ans) {
        cout << i << " ";
    }
}

```



#### 完全背包问题

注意：关于 j 的循环是正向的。

```
for (int i = 0; i < m; i++) {
        for (int j = t[i]; j <= T; j++) {
            dp[j] = max(dp[j], dp[j - t[i]] + v[i]);
        }
    }
```

Tips：解题时，注意数据范围，选择合适的数据结构（eg.long long，_int128）。

**完全背包和 01 背包的区别就在于对容量限制枚举的顺序不同**

原因：0-1背包问题的状态转移利用的是“上一个状态”，完全背包利用的是“当前状态”。



