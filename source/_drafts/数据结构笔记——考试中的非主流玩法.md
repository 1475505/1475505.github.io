[toc]



实际考试中的数据结构题目会比平时代码常用的东西多一点。在此提纲掣领地做一复习。

# 非常规队列

## 顺序的环形实现

顺序队列在数据不断地进队出队过程中，在顺序表中的位置不断后移。

可以使用巧妙的方法将顺序表打造成一个环状表，如图 ：



![img](https:////upload-images.jianshu.io/upload_images/6567790-e5806e91d36f67b7.png?imageMogr2/auto-orient/strip|imageView2/2/w/300)

在真正的实现时，没必要真创建这样一种结构，可以通过增加取模、判断（到达队尾返回开头）的方式实现。

## 循环队列

队头指针front指向队头元素的前一位置，而队尾指针rear指向队尾元素。

为解决如何判断队列的满与空问题，牺牲一个存储单元。

 

## 栈浮动技术

两个栈共享一组地址连续的存储单元。

略。



# 广义表


## 稀疏矩阵的存储

### 三元组存储及快速转置

![img](C:\Users\ll\blog\source\_posts\贴图\350.png)

关键步骤：以 j 为序列，重新排列三元组表中存储各三元组的先后顺序。

1. 在普通算法的基础上增设两个数组（ array 和 copt）：

- array 数组负责记录原矩阵每一列非 0 元素的个数。例子对应的 array 数组：

  ![img](https:////upload-images.jianshu.io/upload_images/6567790-164e9998c2c3026d.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200)

- copt 数组用于计算稀疏矩阵中每列第一个非 0 元素在**新**三元组表中存放的位置，示例对应的 copt 数组如图 ：

  ![img](https:////upload-images.jianshu.io/upload_images/6567790-22df260c67063f1c.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200)



```
cpot[1]=1
cpot[col]=cpot[col-1] +array[col-1]	(col > 1)//意思是，后一列首个非 0 元素存放的位置等于前一列首个非 0 元素的存放位置,加上该列非 0 元素的个数。由此可以看出，copt 数组才是最终想要的，而 array 数组的设立只是为了帮助我们得到 copt 数组。
```



### 行逻辑链接顺序表

当使用行逻辑链接的顺序表对其进行压缩存储时，需要做以下两个工作：

1.将矩阵中的非 0 元素采用三元组的形式存储到一维数组 data 中，如图 ：

![img](https:////upload-images.jianshu.io/upload_images/6567790-d9807ee6236a2bd1.png?imageMogr2/auto-orient/strip|imageView2/2/w/450)

2.使用数组 rpos 记录矩阵中每行第一个非 0 元素在一维数组中的存储位置。如图:



![img](https:////upload-images.jianshu.io/upload_images/6567790-230259eea2644095.png?imageMogr2/auto-orient/strip|imageView2/2/w/300)

**此时，如果想从行逻辑链接的顺序表中提取元素，则可以借助 rpos 数组提高遍历数组的效率。**

例如，提取元素 2 的过程如下：

由 `rpos` 数组可知，第一行首个非 0 元素位于data[1]，因此在遍历此行时，可以直接从第 data[1] 的位置开始，一直遍历到下一行首个非 0 元素所在的位置（data[3]）之前

### 十字链表

为克服三元组表在矩阵的非零元素位置或个数经常变动时的使用不便，矩阵中的各行各列都各用一链表存储，与此同时，所有行链表的表头存储到一个数组（`rhead`），所有列链表的表头存储到另一个数组（`chead`）中。各个链表中节点的结构如图:



![img](https:////upload-images.jianshu.io/upload_images/6567790-81a62ea7f51afc57.png?imageMogr2/auto-orient/strip|imageView2/2/w/230)

![image-20211123171532586](C:\Users\ll\blog\source\_posts\贴图\image-20211123171532586.png)

# 树

## 线索化

> 二叉链表对于无子树侧的指针域，能否利用这些空闲区存放有用的信息或线索？
> ——可以用它来存放当前结点的直接前驱和后继等线索，以加快查找速度。按照某种方式对二叉树进行遍历，可以把二叉树中所有结点排序为一个线性序列，参考之，可以把一棵二叉树转变成了一个“双向链表“。
>
> 在该序列中，除第一个结点外每个结点有且仅有一个直接前驱结点；除最后一个结点外每一个结点有且仅有一个直接后继结点，由此线索化。

LTag=0, lchild域指向左孩子；LTag=1, lchild域指向其前驱
RTag=0, rchild域指向右孩子；RTag=1, rchild域指向其后继 

在线索二叉树的基础上，额外添加一个结点。此结点的作用类似于链表中的头指针，数据域不起作用，只利用两个指针域：左指针域指向二叉树的树根，确保可以正方向对二叉树进行遍历；同时右指针指向线索二叉树形成的线性序列中的最后一个结点。同时，该节点也可避免"悬空"的情形。

## 补充结论

### 深入理解二叉树遍历

非递归中序遍历：

- 入栈顺序：先序遍历；
- 出栈顺序：中序遍历

### 二叉树和森林的互化

#### 树和二叉树

回忆我们从树抽象到二叉树的思路：

将树用“长子 - 兄弟“ 表示法时，转化成对应二叉树的方式：

- 从根开始，左子树连接“长子”；
- 从根开始，右子树连接“兄弟”；

由此便知二者互化的原理；

#### 二叉树和森林

将森林中的每一棵树均用二叉树的方式抽象表述后，从最后一棵二叉树开始，每棵二叉树作为前一棵二叉树的根结点的右子树，得到森林对应的二叉树。

所以，将二叉树根沿着右子树链方向的所有边去掉，得到若干棵孤立的二叉树，对应森林中的各棵树对应的二叉树集合。

![img](C:\Users\ll\blog\source\_posts\贴图\webp.webp)

参考：

https://www.jianshu.com/p/d7d5545012e2



# 查找与排序

## 分块查找

n元素分块查找，记b为索引表长度，s为块中记录个数，则：

当s取$\sqrt{n}$时，$ASL_{bs}$取最小值$\sqrt{n}+1$



# 仅限考试用的结论

1. 树的高度是从1开始算的，也就是说，空树的高度是0。
2. 试卷中除非自己定义，请默认下标从“1”开始。
3. 并查集：与主流一致，根节点的值为-1.
