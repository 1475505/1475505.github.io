---
title:		动态规划的优化
tags:		dp	
categories:	算法进阶
---
## 动态规划的优化策略

### 单调队列/单调栈优化

#### 单调队列

eg.[[Poj2823 - 滑动窗口](http://poj.org/problem?id=2823)]给予一个长度为n的数组，输出每k个连续元素中的最大值和最小值。

解：使用STL容器deque，维护一个单调的数列。以求最小值为例，操作包括：

序列例：1 3 -1 -3 5 3 6 7。

维护递增的队列，操作如下：

| 操作                                                   | 队列状态  |
| :----------------------------------------------------- | :-------- |
| 1 入队                                                 | `{1}`     |
| 3 比 1 大，3 入队                                      | `{1 3}`   |
| -1 比队列中所有元素小，所以队列被清空， -1 入队        | `{-1}`    |
| -3 比队列中所有元素小，所以队列被清空， -3 入队        | `{-3}`    |
| 5 比 -3 大，直接入队                                   | `{-3 5}`  |
| 3 比 5 小，5 出队，3 入队                              | `{-3 3}`  |
| -3 已经在窗体外(越界)，所以 -3 出队；6 比 3 大，6 入队 | `{3 6}`   |
| 7 比 6 大，7 入队                                      | `{3 6 7}` |

即包括：

1.当满足“若待入列数比先进列的数还要小”，可将其前面的数尽数 "弹出"，再将该数 push 进队尾。因此，前面的数先出列，不可能是最大值。

2.需要 site 数组记录第 i 个队中的数在原数组中的位置，以弹出越界的队头。

3.输出时只需输出队头即可。

```C++
    for (int i = 0; i < m; i++) {
        if (i >= n - 1) {
            while (!que.empty() && que.front().second <= i - n) {
                que.pop_front();
            }
        }
        while (!que.empty() && a[i] < que.back().first) {
            que.pop_back();
        }
        que.push_back(P(a[i], i));
        if (i >= n - 1)
            cout << que.front().first << " ";
    }
```

####单调栈

与单调队列相比，其只在一端进行进出。单调队列主要处理的是一个区间内的最大/小值，而单调栈处理的是寻找以某个值为最小/大值的最大区间。参考[lucky52529的博客](https://blog.csdn.net/lucky52529/article/details/89155694)

```
for (遍历)
{
	if (栈空 || 栈顶元素大于等于当前比较元素)
		入栈;
	else{
		while (栈不为空 && 栈顶元素小于当前元素){
			栈顶元素出栈;
			更新结果;
		}
		当前数据入栈;
	}
}
```



其中需要注意的是：

1.对于某些特殊题目，栈内元素出不完，遗留在栈里面的人还没有考虑，导致答案错误，这时候我们要添加结束标识符强制清空栈。比如：

```
vec.push_back(INF);//对于单调递增栈（栈顶最小），补充结束标识符，使最后清空栈
```

2.我们进行栈的处理时，是在出栈操作时进行的。

模板题练习：[[洛谷P5788](https://www.luogu.com.cn/problem/P5788)]

```

```







