{"title":"C/C++ 多维数组的处理","uid":"f4b1f6c62c51b83cc4ba3ecdcd8b9c52","slug":"C中多维数组的处理","date":"2021-09-19T13:17:35.450Z","updated":"2021-11-29T15:08:17.177Z","comments":true,"path":"api/articles/C中多维数组的处理.json","keywords":null,"cover":null,"content":"<p>笔者要用到多维数组的时候经常忘了多维数组怎么用，在此总结一下：</p>\n<p>【内容产出中】</p>\n<p>1.二维数组的函数调用实例</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">&#x2F;&#x2F;声明\nvoid bubbleSort(float (*num)[40],int size);\n&#x2F;&#x2F;调用\nbubbleSort( stu , 40);\n&#x2F;&#x2F;思想：二维数组——数组的数组</code></pre>\n\n<p>2.把二维数组当一维数组进行赋值：</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">int *p&#x3D;&amp;a[0][0];&#x2F;&#x2F;获取二维数组首地址\nfor(int i&#x3D;0;i&lt;6;i++)\n&#123;\nscnaf(&quot;%d&quot;,p);\np++;\n&#125;</code></pre>\n\n<p>3.使用 C++ 容器时，若可以使用<code>at</code>等方法获得对应元素，以缓解运算符<code>[]</code>的不稳定性问题。</p>\n<p>如： array（C++11）</p>\n<table>\n<thead>\n<tr>\n<th>函数</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>at</code></td>\n<td>访问指定的元素，同时进行越界检查<code>at</code> 若遇 <code>pos &gt;= size()</code> 的情况会抛出 <code>std::out_of_range</code>。</td>\n</tr>\n<tr>\n<td><code>operator[]</code></td>\n<td>访问指定的元素，<strong>不</strong> 进行越界检查</td>\n</tr>\n</tbody></table>\n<p>4.多维vector的行列空间预留</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">vector&lt;vector&lt;bool&gt; &gt; table(256);&#x2F;&#x2F;256行\ntable.resize(512);&#x2F;&#x2F;512列</code></pre>\n\n","feature":true,"text":"笔者要用到多维数组的时候经常忘了多维数组怎么用，在此总结一下： 【内容产出中】 1.二维数组的函数调用实例 &#x2F;&#x2F;声明 void bubbleSort(float (*num)[40],int size); &#x2F;&#x2F;调用 bubbleSort( ...","link":"","photos":[],"count_time":{"symbolsCount":609,"symbolsTime":"1 mins."},"categories":[],"tags":[],"toc":"","author":{"name":"Liul","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"","uid":"f73a8e23e6f6f669cf99c7dba8fa0722","slug":"概率论论文","date":"2022-02-03T12:49:05.194Z","updated":"2022-02-03T10:54:47.829Z","comments":true,"path":"api/articles/概率论论文.json","keywords":null,"cover":[],"text":"#《原神》祈愿机制概率研究 【摘要】本文以概率论、随机过程理论等工具研究游戏《原神》中的祈愿机制，主要基于动态规划，以“期望”和“概率的概率”两大分析方向进行数据处理，并根据分析结果总结了一些方便玩家规划金钱与资源的建议。由于追求多次获得五星道具的玩家基本“不差钱”，本文附有获取...","link":"","photos":[],"count_time":{"symbolsCount":"23k","symbolsTime":"21 mins."},"categories":[],"tags":[],"author":{"name":"Liul","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true},"next_post":{"title":"C++ 特性","uid":"02283cddd2f2c72dd0f98ea650045063","slug":"从C进步到C++——特性","date":"2021-09-06T11:11:52.010Z","updated":"2022-01-02T12:08:13.849Z","comments":true,"path":"api/articles/从C进步到C++——特性.json","keywords":null,"cover":null,"text":"从C进步到C++——特性[TOC] 结构体初始化构造定义结构体时，加入以下语句，可以方便地进行初始化。 struct student&#123; int id; char gender; student()&#123;&#125; &#x2F;&#x2F;系统默认，用于未经初始化...","link":"","photos":[],"count_time":{"symbolsCount":"3.3k","symbolsTime":"3 mins."},"categories":[{"name":"语言基础","slug":"语言基础","count":1,"path":"api/categories/语言基础.json"}],"tags":[{"name":"C++,语法","slug":"C-语法","count":1,"path":"api/tags/C-语法.json"}],"author":{"name":"Liul","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true}}