{"title":"动态规划的优化","uid":"138e79928c1a716384cb2dd1093bf72b","slug":"动态规划优化","date":"2021-08-06T14:40:33.683Z","updated":"2021-08-07T07:47:49.093Z","comments":true,"path":"api/articles/动态规划优化.json","keywords":null,"cover":null,"content":"<h2 id=\"动态规划的优化策略\"><a href=\"#动态规划的优化策略\" class=\"headerlink\" title=\"动态规划的优化策略\"></a>动态规划的优化策略</h2><h3 id=\"单调队列-单调栈优化\"><a href=\"#单调队列-单调栈优化\" class=\"headerlink\" title=\"单调队列/单调栈优化\"></a>单调队列/单调栈优化</h3><h4 id=\"单调队列\"><a href=\"#单调队列\" class=\"headerlink\" title=\"单调队列\"></a>单调队列</h4><p>eg.[<a href=\"http://poj.org/problem?id=2823\">Poj2823 - 滑动窗口</a>]给予一个长度为n的数组，输出每k个连续元素中的最大值和最小值。</p>\n<p>解：使用STL容器deque，维护一个单调的数列。以求最小值为例，操作包括：</p>\n<p>序列例：1 3 -1 -3 5 3 6 7。</p>\n<p>维护递增的队列，操作如下：</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">操作</th>\n<th align=\"left\">队列状态</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">1 入队</td>\n<td align=\"left\"><code>&#123;1&#125;</code></td>\n</tr>\n<tr>\n<td align=\"left\">3 比 1 大，3 入队</td>\n<td align=\"left\"><code>&#123;1 3&#125;</code></td>\n</tr>\n<tr>\n<td align=\"left\">-1 比队列中所有元素小，所以队列被清空， -1 入队</td>\n<td align=\"left\"><code>&#123;-1&#125;</code></td>\n</tr>\n<tr>\n<td align=\"left\">-3 比队列中所有元素小，所以队列被清空， -3 入队</td>\n<td align=\"left\"><code>&#123;-3&#125;</code></td>\n</tr>\n<tr>\n<td align=\"left\">5 比 -3 大，直接入队</td>\n<td align=\"left\"><code>&#123;-3 5&#125;</code></td>\n</tr>\n<tr>\n<td align=\"left\">3 比 5 小，5 出队，3 入队</td>\n<td align=\"left\"><code>&#123;-3 3&#125;</code></td>\n</tr>\n<tr>\n<td align=\"left\">-3 已经在窗体外(越界)，所以 -3 出队；6 比 3 大，6 入队</td>\n<td align=\"left\"><code>&#123;3 6&#125;</code></td>\n</tr>\n<tr>\n<td align=\"left\">7 比 6 大，7 入队</td>\n<td align=\"left\"><code>&#123;3 6 7&#125;</code></td>\n</tr>\n</tbody></table>\n<p>即包括：</p>\n<p>1.当满足“若待入列数比先进列的数还要小”，可将其前面的数尽数 “弹出”，再将该数 push 进队尾。因此，前面的数先出列，不可能是最大值。</p>\n<p>2.需要 site 数组记录第 i 个队中的数在原数组中的位置，以弹出越界的队头。</p>\n<p>3.输出时只需输出队头即可。</p>\n<pre class=\"line-numbers language-C++\" data-language=\"C++\"><code class=\"language-C++\">for (int i &#x3D; 0; i &lt; m; i++) &#123;\n    if (i &gt;&#x3D; n - 1) &#123;\n        while (!que.empty() &amp;&amp; que.front().second &lt;&#x3D; i - n) &#123;\n            que.pop_front();\n        &#125;\n    &#125;\n    while (!que.empty() &amp;&amp; a[i] &lt; que.back().first) &#123;\n        que.pop_back();\n    &#125;\n    que.push_back(P(a[i], i));\n    if (i &gt;&#x3D; n - 1)\n        cout &lt;&lt; que.front().first &lt;&lt; &quot; &quot;;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>####单调栈</p>\n<p>与单调队列相比，其只在一端进行进出。单调队列主要处理的是一个区间内的最大/小值，而单调栈处理的是寻找以某个值为最小/大值的最大区间。参考<a href=\"https://blog.csdn.net/lucky52529/article/details/89155694\">lucky52529的博客</a></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">for (遍历)\n&#123;\n\tif (栈空 || 栈顶元素大于等于当前比较元素)\n\t\t入栈;\n\telse&#123;\n\t\twhile (栈不为空 &amp;&amp; 栈顶元素小于当前元素)&#123;\n\t\t\t栈顶元素出栈;\n\t\t\t更新结果;\n\t\t&#125;\n\t\t当前数据入栈;\n\t&#125;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n\n\n<p>其中需要注意的是：</p>\n<p>1.对于某些特殊题目，栈内元素出不完，遗留在栈里面的人还没有考虑，导致答案错误，这时候我们要添加结束标识符强制清空栈。比如：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">vec.push_back(INF);&#x2F;&#x2F;对于单调递增栈（栈顶最小），补充结束标识符，使最后清空栈<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>2.我们进行栈的处理时，是在出栈操作时进行的。</p>\n<p>模板题练习：[<a href=\"https://www.luogu.com.cn/problem/P5788\">洛谷P5788</a>]</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\"><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n\n\n\n\n\n\n","text":"动态规划的优化策略单调队列/单调栈优化单调队列eg.[Poj2823 - 滑动窗口]给予一个长度为n的数组，输出每k个连续元素中的最大值和最小值。 解：使用STL容器deque，维护一个单调的数列。以求最小值为例，操作包括： 序列例：1 3 -1 -3 5 3 6 7。 维护递增...","link":"","photos":[],"count_time":{"symbolsCount":"1.5k","symbolsTime":"1 mins."},"categories":[{"name":"算法进阶","slug":"算法进阶","count":1,"path":"api/categories/算法进阶.json"}],"tags":[{"name":"dp","slug":"dp","count":2,"path":"api/tags/dp.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%9A%84%E4%BC%98%E5%8C%96%E7%AD%96%E7%95%A5\"><span class=\"toc-text\">动态规划的优化策略</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97-%E5%8D%95%E8%B0%83%E6%A0%88%E4%BC%98%E5%8C%96\"><span class=\"toc-text\">单调队列&#x2F;单调栈优化</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97\"><span class=\"toc-text\">单调队列</span></a></li></ol></li></ol></li></ol>","author":{"name":"Liul","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"C++ STL使用手册","uid":"705805ce17024f8fb64b911637d83992","slug":"C++STL的使用","date":"2021-08-06T15:07:15.151Z","updated":"2021-09-12T09:03:35.681Z","comments":true,"path":"api/articles/C++STL的使用.json","keywords":null,"cover":[],"text":"#C++ STL的使用手册 [toc] 共有函数=：有赋值运算符以及复制构造函数。 begin()：返回指向开头元素的迭代器。 end()：返回指向末尾的下一个元素的迭代器。end() 不指向某个元素，它是末尾元素的后继。 size()：返回容器内的元素个数。 max_size(...","link":"","photos":[],"count_time":{"symbolsCount":"5.1k","symbolsTime":"5 mins."},"categories":[{"name":"语言基础","slug":"语言基础","count":2,"path":"api/categories/语言基础.json"}],"tags":[{"name":"C++,语法","slug":"C-语法","count":2,"path":"api/tags/C-语法.json"}],"author":{"name":"Liul","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true},"next_post":{"title":"动态规划初步","uid":"b94fc74a26961727683d8eed12a779bd","slug":"动态规划初步","date":"2021-08-06T09:30:57.763Z","updated":"2021-09-09T09:31:29.969Z","comments":true,"path":"api/articles/动态规划初步.json","keywords":null,"cover":[],"text":"动态规划初步[toc] 基本思路动态规划实际是“聪明地枚举”，会遍历所有可能的情况。对其中的“剪枝”（不丢失最优解）属于贪心的范畴，可能提高了“溯源”的难度。 首先注意：动态规划不是说一上来就写状态转移方程（直接做“备忘录”），而是逐步分析，如下： 分析最优子结构 -&gt; 递...","link":"","photos":[],"count_time":{"symbolsCount":"2.8k","symbolsTime":"3 mins."},"categories":[{"name":"算法基础","slug":"算法基础","count":1,"path":"api/categories/算法基础.json"}],"tags":[{"name":"dp","slug":"dp","count":2,"path":"api/tags/dp.json"}],"author":{"name":"Liul","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}