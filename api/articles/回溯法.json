{"title":"算法模板","uid":"9e122bacf6c8b61a95cac22cf033e3e5","slug":"回溯法","date":"2021-09-09T12:13:56.975Z","updated":"2021-09-12T12:38:45.049Z","comments":true,"path":"api/articles/回溯法.json","keywords":null,"cover":[],"content":"<h1 id=\"回溯法\"><a href=\"#回溯法\" class=\"headerlink\" title=\"回溯法\"></a>回溯法</h1><p>[TOC]</p>\n<p>解决一个回溯问题，实际上就是一个决策树的遍历过程，使用 <code>isValid</code> 函数剪枝。回溯算法模板框架如下：</p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\"><span class=\"token keyword\">void</span> <span class=\"token function\">backtracking</span><span class=\"token punctuation\">(</span>参数<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>结束遍历条件<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        存放结果<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">return</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span>选择：本层集合中元素（树中节点孩子的数量就是集合的大小）<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span><span class=\"token function\">isValid</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> \t<span class=\"token keyword\">continue</span><span class=\"token punctuation\">;</span><span class=\"token comment\">//// 排除不合法选择</span>\n        处理节点<span class=\"token punctuation\">;</span>\n        <span class=\"token function\">backtracking</span><span class=\"token punctuation\">(</span>路径，选择列表<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 深入</span>\n        撤销节点处理；\n    <span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>对于<code>isValid</code>函数及剪枝策略，回溯法求最值时，可以通过贪心思想找到一个“较优解”，减去差于其的枝。(分支限界法)</p>\n<p>回溯与 DFS 的思想很类似，区别主要在于解空间的表示和处理：</p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\"><span class=\"token keyword\">for</span> 循环内：\nrecord<span class=\"token punctuation\">[</span>son<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 标记使用/状态</span>\n<span class=\"token function\">dfs</span><span class=\"token punctuation\">(</span>deep <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// dfs 下一层</span>\nrecord<span class=\"token punctuation\">[</span>son<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 取消标记/状态</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p><strong>在递归之前做出选择，在递归之后撤销刚才的选择</strong>。</p>\n<p>解空间的状态表示主要有： 排列树 和 组合树 两种。</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20210130173631174.png\" alt=\"回溯算法理论基础\"></p>\n<p>口诀：for循环，换子树；递归调用往深溯</p>\n<h4 id=\"示例：生成全排列\"><a href=\"#示例：生成全排列\" class=\"headerlink\" title=\"示例：生成全排列\"></a>示例：生成全排列</h4><p><img src=\"https://github.com/labuladong/fucking-algorithm/raw/master/pictures/backtracking/3.jpg\" alt=\"img\"></p>\n<h3 id=\"n-皇后问题的-位运算解法-及-bitset-包\"><a href=\"#n-皇后问题的-位运算解法-及-bitset-包\" class=\"headerlink\" title=\"n-皇后问题的 位运算解法 及 bitset 包\"></a>n-皇后问题的 位运算解法 及 bitset 包</h3><h4 id=\"bitset\"><a href=\"#bitset\" class=\"headerlink\" title=\"bitset\"></a>bitset</h4><p>bitset 头文件中，有一种类似数组的结构，它的每一个元素只能是０或１，每个元素仅用１bit空间，名为 bitset 。构造方式：</p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">bitset<span class=\"token operator\">&lt;</span><span class=\"token number\">4</span><span class=\"token operator\">></span> bitset1<span class=\"token punctuation\">;</span>　　<span class=\"token comment\">//无初始化下，默认每一位均为0</span>\nbitset<span class=\"token operator\">&lt;</span><span class=\"token number\">8</span><span class=\"token operator\">></span> <span class=\"token function\">bitset2</span><span class=\"token punctuation\">(</span><span class=\"token number\">16</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>　<span class=\"token comment\">//保存长度为8的16的二进制表示：[00010000]</span>\nstring s <span class=\"token operator\">=</span> <span class=\"token string\">\"10010\"</span><span class=\"token punctuation\">;</span>\nbitset<span class=\"token operator\">&lt;</span><span class=\"token number\">8</span><span class=\"token operator\">></span> <span class=\"token function\">bitset3</span><span class=\"token punctuation\">(</span>s<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>　　<span class=\"token comment\">//长度为10，前补0。[00010010]</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n\n\n\n<p>bitset 支持一些按位的位运算，且支持to_string类型转换。</p>\n<p>对于一个叫做bit的bitset：<br>bit.size()       返回大小（位数）<br>bit.count()     返回1的个数<br>bit.any()       返回是否有1<br>bit.none()      返回是否没有1<br>bit.set()       全都变成1<br>bit.set(p)      将第p + 1位变成1（bitset是从第0位开始的！）<br>bit.set(p, x)   将第p + 1位变成x<br>bit.reset()     全都变成0<br>bit.reset(p)    将第p + 1位变成0<br>bit.flip()      全都取反<br>bit.flip(p)     将第p + 1位取反<br>bit.to_ulong()  返回它转换为unsigned long的结果，如果超出范围则报错<br>bit.to_ullong() 返回它转换为unsigned long long的结果，如果超出范围则报错</p>\n","feature":true,"text":"回溯法[TOC] 解决一个回溯问题，实际上就是一个决策树的遍历过程，使用 isValid 函数剪枝。回溯算法模板框架如下： void backtracking(参数) &#123; if (结束遍历条件) &#123; 存放结果; return; &#125; for (选择：本...","link":"","photos":[],"count_time":{"symbolsCount":"1.3k","symbolsTime":"1 mins."},"categories":[],"tags":[],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%9B%9E%E6%BA%AF%E6%B3%95\"><span class=\"toc-text\">回溯法</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E7%A4%BA%E4%BE%8B%EF%BC%9A%E7%94%9F%E6%88%90%E5%85%A8%E6%8E%92%E5%88%97\"><span class=\"toc-text\">示例：生成全排列</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#n-%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98%E7%9A%84-%E4%BD%8D%E8%BF%90%E7%AE%97%E8%A7%A3%E6%B3%95-%E5%8F%8A-bitset-%E5%8C%85\"><span class=\"toc-text\">n-皇后问题的 位运算解法 及 bitset 包</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#bitset\"><span class=\"toc-text\">bitset</span></a></li></ol></li></ol></li></ol></li></ol>","author":{"name":"Liul","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{},"next_post":{"title":"C++ 特性","uid":"02283cddd2f2c72dd0f98ea650045063","slug":"从C进步到C++——特性","date":"2021-09-06T11:11:52.010Z","updated":"2021-09-12T09:03:53.960Z","comments":true,"path":"api/articles/从C进步到C++——特性.json","keywords":null,"cover":[],"text":"从C进步到C++——特性[TOC] ###结构体初始化构造 定义结构体时，加入以下语句，可以方便地进行初始化。 struct student&#123; int id; char gender; student()&#123;&#125; &#x2F;&#x2F;系统默认，用于未...","link":"","photos":[],"count_time":{"symbolsCount":"2.3k","symbolsTime":"2 mins."},"categories":[{"name":"语言基础","slug":"语言基础","count":2,"path":"api/categories/语言基础.json"}],"tags":[{"name":"C++,语法","slug":"C-语法","count":2,"path":"api/tags/C-语法.json"}],"author":{"name":"Liul","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true}}