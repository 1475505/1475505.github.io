[{"id":"dd94b17f720b673970514d5457d814a2","title":"《原神》祈愿机制概率研究","content":"#《原神》祈愿机制概率研究\n【摘要】本文以概率论、随机过程理论等工具研究游戏《原神》中的祈愿机制，主要基于动态规划，以“期望”和“概率的概率”两大分析方向进行数据处理，并根据分析结果总结了一些方便玩家规划金钱与资源的建议。由于追求多次获得五星道具的玩家基本“不差钱”，本文附有获取少量五星情况下的数据可视化。\n[TOC]\n\n\n\n\n\n\n\n\n\nVersion:20220105\n\n修了讲一遍时找到的笔误\n\n规则表述旅行者（玩家）可以通过祈愿机制获取“五星角色”“五星武器“”四星角色“”四星武器“来提高战斗力。其中，角色具有命之座机制，首次获得为0命，最高6命，命座数越高，角色越强；类似地，武器拥有精炼层数机制，首次获得为1阶，最高5阶。\n最近的版本更新中，《原神》的祈愿机制也发生了一定的变化。\n以下是《原神》两个祈愿机制的官方描述（https://ys.mihoyo.com/main/news/public）：\n角色祈愿**五星角色祈愿的基础概率为0.600%，综合概率（含保底）为1.600%**，最多90次祈愿必定能通过保底获取5星角色。\n当祈愿获取到5星角色时，有50.000%的概率为本期5星UP角色「A1」（小保底）。如果本次祈愿获取的5星角色非本期5星UP角色，下次祈愿获取的5星角色必定为本期5星UP角色（大保底）。\n4星物品祈愿的基础概率为5.100%，4星角色祈愿的基础概率为2.550%，4星武器祈愿的基础概率为2.550%，4星物品祈愿的综合概率（含保底）为13.000%。最多10次祈愿必定能通过保底获取4星或以上物品，通过保底获取4星物品的概率为99.400%，获取5星物品的概率为0.600%。\n当祈愿获取到4星物品时，有50.000%的概率为本期4星UP角色「B」、「C」、「D」中的一个。如果本次祈愿获取的4星物品非本期4星UP角色，下次祈愿获取的4星物品必定为本期4星UP角色。当祈愿获取到4星UP物品时，每个本期4星UP角色的获取概率均等。\n角色祈愿包括「角色活动祈愿-1」和「角色活动祈愿-2」，祈愿次数和保底完全共享，共同累计。二者区别仅在于当期UP的五星角色不同。\n武器祈愿武器祈愿中，5星武器祈愿的基础概率为0.700%，综合概率（含保底）为1.850%，最多80次祈愿必定能通过保底获取5星武器。\n当祈愿获取到5星武器时，有75.000%的概率为本期5星UP武器「M」、「N」中的一个。如果本次祈愿获取的5星武器非本期5星UP武器，下次祈愿获取的5星武器必定为本期5星UP武器。\n【定轨机制】命定值：玩家可以指定一把本期5星UP武器（定轨）。当获取到的5星武器为非当前定轨武器时，获得1点命定值，命定值达到满值2后，在本祈愿中获得的下一把5星武器必定为当前定轨武器。获取到当前定轨武器时，无论当前命定值是否达到满值，都将会重置为0，重新累计。在未通过命定值达到满值获取定轨武器的情况下，当祈愿获取到5星UP物品时，每把本期5星UP武器的获取概率均等。\n未使用「神铸定轨」定轨武器时，将不会累积命定值。\n4星物品祈愿的基础概率为6.000%，4星角色祈愿的基础概率为3.000%，4星武器祈愿的基础概率为3.000%，4星物品祈愿的综合概率（含保底）为14.500%。最多10次祈愿必定能通过保底获取4星或以上物品，通过保底获取4星物品的概率为99.300%，获取5星物品的概率为0.700%。\n当祈愿获取到4星物品时，有75.000%的概率为本期4星UP武器「F」、「G」、「H」、「J」、「K」中的一个。如果本次祈愿获取的4星物品非本期4星UP武器，下次祈愿获取的4星物品必定为本期4星UP武器。当祈愿获取到4星UP物品时，每把本期4星UP武器的获取概率均等。\n角色祈愿分析五星角色概率建模   前面的作业中，笔者通过运行代码和期望分析，对角色祈愿的机制进行了尝试1的模拟，简单回顾如下：\n尝试1：89次伯努利实验建模1：前89次祈愿，每次获得五星角色的概率均为0.6%，若前89次实验没有获得五星角色，则获取五星角色的概率为100%。\n则可以建模二项分布概率密度：\n$$ PDF(X &#x3D; k) &#x3D; (1-p)^{k-1}p(p &#x3D; 0.6 %)$$\n$$ CDF(X &#x3D; k) &#x3D; (1 - p)^k$$\n计算每次获取五星角色的祈愿数期望：\n$$ E(X) &#x3D; 90(1-CDF(89)) + \\sum_{i&#x3D;1}^{89}iPDF(x&#x3D;i)$$\n得到综合概率：\n$$P &#x3D; \\frac{1}{E(X)} $$\n结果为：1.435%。（详见week9作业）\n与官方描述不符。实际上，官方提到的0.6%是基础概率，说明不是恒定概率的伯努利实验，于是提出模型2.\n尝试2：概率递增的保底机制建模2：在一定抽数都没有得到五星角色后，获得五星角色概率开始线性上升，直到第90抽达到100%。 \n由于具体概率密度没有官方文档，只能站在前人的分析上，根据结合数据统计的开源项目（https://github.com/OneBST/GGanalysis，本文实际上相当于模型的复现）采用的模型，第x次祈愿获得五星角色的概率如下：\n$$ P(x) &#x3D; \\begin{cases} 0.6% &amp;{x&lt;&#x3D;73}\\ 0.6% + 6%(x - 73) &amp;{74&lt;&#x3D;x&lt;&#x3D;89}\\1&amp;{x &#x3D; 90} \\end{cases}$$\n由此，可以得到第x次祈愿得到五星角色的分布列（类似于几何分布）：\n$$ PDF(x) &#x3D; P(x) * \\prod_{k &#x3D; 1}^{x - 1}1-P(x) $$\n$$ PDF(x) &#x3D; \\begin{cases} (1 - 0.6%)^{x-1}\\times0.6% &amp;{x\\leqslant73}\\ (1-0.6%)^{73} \\times \\sum_{k &#x3D; 74}^{x} (1- 6%(k - 73))^{k-73}(6%(k-73)) &amp;{74\\leqslant x\\leqslant89}\\(1-0.6%)^{73} \\times \\sum_{k &#x3D; 74}^{89} (1- 6%(k - 73))^{k-73}&amp;{x &#x3D; 90} \\end{cases} $$\n该模型平均获取五星角色的祈愿次数为62.3。该模型下五星角色的综合概率为1.605%。\n注：期望计算公式：\n$$ E(X) &#x3D; \\sum_{i&#x3D;1}^{x}PDF(x)\\times x $$\n概率递增保底机制下的数字特征求数据特征在这里处理一个认识误区：期望 !&#x3D; 概率为50%的点（中分位点）。\n也就是说，期望作为概率的平均值，$ CDF(EX) &#x3D; 0.5 $ 是不成立的。 注意到这一前提，才能比较正确地理解下面的结论。\n由于其概率密度并不是均匀分布的，差别较大，选择平均数似乎不太合适。所以我们获取中分位点。根本不应该是程序员能写出来的粗糙代码验证：\nimport numpy as np\nimport matplotlib as mlp\nimport matplotlib.pyplot as plt\nfrom matplotlib.pyplot import MultipleLocator\ndef p_5(n):\n    if n &lt; 73:\n        return 0.006\n    elif n &lt; 89:\n        return 0.006 + (n - 72) * 0.06\n    else:\n        return 1\n    \npdf_5 &#x3D; [];\ncdf_5 &#x3D; [];\ntmp &#x3D; 0.0;\n\nfor i in range (0,90):\n    tmp &#x3D; p_5(i);\n    for j in range(0,i):\n        tmp &#x3D; tmp * (1 - p_5(j))\n    pdf_5.append(tmp);\n#注：下文中其他代码可能要用到p_5,p_4函数,pdf_5列表哦\n\nfor i in range (0,90):\n    tmp &#x3D; 0.0;\n    for j in range (0,i+1):\n        tmp &#x3D; tmp + pdf_5[j];\n    cdf_5.append(tmp);\n    print(i+1,cdf_5[i])\n# out:\n#75 0.4739047630777248\n#76 0.571758477145268\n\n该模型的概率密度函数（蓝线）和分布函数（黄线）图：\n\n我们不妨乐观一点，中分位点：75.\n注：最概然祈愿次数为77。也就是说，在第77次祈愿获取五星角色的概率最高。\n每次获得五星角色，需要的祈愿次数记为$N$. 则：\n\n从期望角度考虑，N &#x3D; 62.3.\n从中分位点角度考虑，N &#x3D; 75.\n\n实际理解为：需要75次祈愿，才能使获得5星角色的发生概率达到50%（实际：46.8%）。\n这种分布具有较强的右偏性。上面分析过，这两个数字特征具有不同的分析意义，可以理解为：\n\n祈愿623次，期望获得10个五星角色。（期望值）\n祈愿75次，能使获得五星角色的概率达到50%。\n\n由期望特征进行资源规划回到规则中，解决以下问题：\n获得五星角色A的期望次数分析对于期望分析：注意到，对于获取当期UP五星角色，最多需要2次获得五星角色。也就是说，有50%的概率，仅需要获取一次五星角色；有50%的概率，需要获取2次五星角色。也就是说，需要获得五星角色的次数：\n$$ 1 \\times 50% + 2 \\times 50%  &#x3D; 1.5 $$\n对于“获取五星角色”而言，多次获取（不论是否为当期UP角色）之间互相独立，因此需要的祈愿次数为$1.5 \\times 62.3 &#x3D; 93.45$ 次。\n获得6命座A角色的期望次数分析注意到，对于“获取五星角色”而言，多次获取（不论是否为当期UP角色）之间互相独立。考虑这个问题：对于“获取A角色”事件之间，是相互独立的吗？\n从期望角度考虑，可以说：是的。参考上面的思路，只需要“获取A角色”发生7次即可。因此需要的祈愿次数为 $1.5N \\times 7 &#x3D; 10.5N$ 也就是 654.15 次。\n获得四星角色B的期望次数分析由于涉及“基础概率”，我们沿用上一开源项目模型的概率递增保底机制结论：\n\n从第9次祈愿处开始上升。\n\n获得五星角色并不会重置四星保底。\n\n\n第x次祈愿获得四星角色的概率如下：\n$$ P(x) &#x3D; \\begin{cases} 5.1% &amp; {x\\leqslant8}\\ 56.1% &amp;{x &#x3D; 9}\\1&amp;{x &#x3D; 10} \\end{cases}$$\n$$ PDF(x) &#x3D; P(x) * \\prod_{k &#x3D; 1}^{x - 1}1-P(x)  &#x3D; \\begin{cases} (1 - 5.1%)^{x-1}\\times5.1% &amp; {x\\leqslant8}\\ (1-5.1%)^8\\times56.1% &amp;{x&#x3D;9}\\(1-5.1%)^8\\times43.9%&amp;{x &#x3D; 10} \\end{cases}$$ \n期望值：\n$$ E(X) &#x3D; \\sum_{i&#x3D;1}^{x}PDF(x)\\times x &#x3D; 7.66$$ \n综合概率：13.05%.\n对于期望分析：注意到，对于获取当期UP五星角色，仅有$\\frac{1}{3}$的概率得到当期UP的四星角色中的B，且每次获得当期四星角色时，有50%的概率，仅需要获取一次四星角色；有50%的概率，需要获取2次四星角色。也就是说，获得角色B的次数期望为$1.5 \\times 3 \\times E(X) &#x3D; 34.5$ 。\n由分位点特征进行分析从“概率的概率”角度分析便没有期望分析那么简单了。中位点与期望的乘积并不能得到叠加事件的中位点。基本上大部分分而治之的想法均不满足独立性要求。我们需要寻找更一般的数学模型：\n获得多次五星角色的分位点分析接下来，由于使获得两次五星角色的概率达到50%的祈愿次数不等于获得一次五星角色祈愿次数的中位点的2倍，我们需要计算分布的叠加。\n我们从简单问题入手（自己编的）：\n(1) 一直抛硬币，直到总共出现2次正面朝上，求期望的抛硬币次数——显然是4.\n(2) 需要抛多少次硬币，使【至少出现2次正面朝上】的概率达到50%。\n(3) 需要抛多少次骰子，使【至少出现2次点数1】的概率达到50%。\n题目（2）（3）这类问题，可以转化成“几何分布的叠加问题”。这里的概率稳定比较简单，还可以参阅负二项分布有关资料。\n而对于的祈愿的建模，概率不稳定，有三种可能的思考方向：一可以用模拟动态规划处理，二是对各种情况进行全概率公式展开（工作量极大），三是离散信号的进行卷积运算:$P(Z&#x3D;X+Y&#x3D;z) &#x3D; \\sum_1^\\infty PDF(X&#x3D;z-y)P(X&#x3D;y)$\n笔者采用第三种方法。\n各位修改一下代码的变量，即可获取想要的值。\nc5_need &#x3D; 2#需要抽出几次五星角色；\nc5_poss &#x3D; 0.25#想知道的概率;\nconv &#x3D; pdf_5;\nfor cnt in range(0,c5_need - 1):\n    conv&#x3D;np.convolve(conv,pdf_5,&#39;full&#39;)\n    plt.plot(conv)\n    tmp &#x3D; 0.0\n    for i in range (0,len(conv)):\n        tmp +&#x3D; conv[i]\n        if(cnt &#x3D;&#x3D; c5_need - 2 and tmp &gt;&#x3D; c5_poss):\n            print(i+c5_need);\n            break\n    #DEMO\n    #135 -- 需要祈愿135次，才有50%的概率获得两个五星角色。\n\t#祈愿154次，有75%的概率获得两个五星角色。\n\n我对获得两次的情况列了个分布图：\n\n双角色池祈愿这个其实没什么太大的变化，把A2等价成A1，就可以和上文的A的结论统一了。\n保底依赖下的分位点分析尝试1：将“保底获得的五星”和“祈愿次数”拆成两个独立事件保底之间的马尔可夫过程由于角色祈愿机制满足：本次获取五星角色是否为A的概率仅取决于上次获取的五星角色是否为A。符合马尔可夫过程（状态$i$只取决于上一次状态$i-1$，与再先前的状态相互独立。参：课本P321）的建模标准，可以做出以下状态图和概率转移矩阵：\ngraph LR\nA --1&#x2F;2--&gt; !A\n!A --1--&gt; A\nA --1&#x2F;2--&gt; A\n$$ M &#x3D; \\space \\begin{matrix}  &amp; A &amp; !A\\A &amp; {1}\\over{2} &amp; {1}\\over{2}\\!A &amp; 1 &amp; 0\\end{matrix}$$\n马尔可夫链在三门问题、经济学分析、自然语言处理等领域具有广泛的应用，在极值环境下具有平稳分布的特点。以下进行模拟分析。\n收敛的综合概率：$M^\\infty$。经过计算，可知A物品的综合概率为$\\frac{2}{3}$ 。这个计算结果可以理解为：任意一次获得五星角色，有$\\frac{2}{3}$的概率是A.（初始状况：刚获得A，以说明存在小保底）\n而对于中间情况的分析，可对应转换为矩阵的乘法和加法运算。\n但是我们很难把两个独立事件的概率组合到一起，以达到50%，请看下面的分析。\n分类讨论的方式求取概率我们以抽到零命为例，对应的状态矩阵为$M$。因为初始状态（你可以理解为-1命）为A，此时可以理解为对应的概率为：$p_{11}P(获得一次五星) +p_{12}(获得二次五星)$，其中获得两次五星的概率模型可参考上面的卷积公式（由于二次五星也比较简单，大可自己分类讨论写）,如：\n$$ \\frac{1}{2}PDF(X) + \\frac{1}{2}PDF(Z)$$（注：x&gt;90的部分，记为0即可，因为那部分情况已结束。）\n验证这一方法的正确性：\ntmp &#x3D; 0.0\nfor i in range(0,179):\n    if(i&lt;90): tmp +&#x3D; 0.5 * pdf_5[i];\n    tmp+&#x3D;0.5*conv[i];\n    if(tmp&gt;&#x3D;0.5):\n        print(i);\n        break;\n&#x2F;&#x2F;沿用上方的数组了，输出为79.\n因为列表下标是从0开始计数的，79 &lt; 90 ，所以对应：80次祈愿可使抽到UP五星的概率达到50%。\n\n如果需要制图，可以使用以下的画图模板代码\n#制图代码\nx_major_locator&#x3D;MultipleLocator(4)#x分度值设置\ny_major_locator&#x3D;MultipleLocator(0.1)\nax&#x3D;plt.gca()\nax.xaxis.set_major_locator(x_major_locator)\nax.yaxis.set_major_locator(y_major_locator)\nplt.grid()  # 生成网格\nx_values &#x3D; [x for x in range(1, 91)]\ny_values &#x3D; [pdf_5[x] for x in range(0, 90)]\nplt.plot(x_values,y_values)\n\n如果是多命，则需要更复杂的分类讨论。如：一命的情况，就需要二次转移矩阵$M^2$的各项作为转移概率了，包括(A A ， A !A A ， !A A A ， !A A !A A)四种状态对应的状态转移概率，以及多次的卷积结果。由于前面代码没有记忆，就不尝试了。\n尝试2：动态规划的角度抽到多个五星角色中UP五星角色的个数概率其实上面的转移矩阵比较简单，直接可以写出状态转移方程，考虑动态规划。\n定义状态$dp[i][j][1]$表示第 $i$ 次获得的五星角色时得到当期UP角色A后，共获得了$j$次A角色，达到$j-1$命 （第一次获得A角色达到0命）；类似地，$dp[i][j][0]$ 表示第 $i$ 次获得的五星角色不是A。\n则状态转移方程：\n$$ dp[i][j][0] &#x3D; \\frac{1}{2}dp[i-1][j][1] $$\n$$ dp[i][j][1] &#x3D; \\frac{1}{2}dp[i-1][j-1][1] + dp[i-1][j-1][0]$$\n起点：$dp[0][0][1] &#x3D; 1$\n由此可以记$dp[i][j]$为第$i$次获得五星角色后共获得$j$次（及以上）A角色的概率，则：\n$$ dp[i][j] &#x3D; \\sum_{k&#x3D;j}^{i}dp[i][k][1]+dp[i][k][0] $$\n尝试构造含$i,j,dp[i][j]$三个变量的图：\n由图中可以估计获取1~7次A角色时，使概率达到50%时，横坐标即为需要获得A角色的次数。（x，y）表示，已获得x次五星角色的情况下，y为对应的总共获取次数大于等于对应i的概率。\n求取命座-祈愿次数概率定义：$ dp[i][j][k] $ ：第j次祈愿的结果对应k，并第i次获得A角色的概率，则状态转移方程：\n\n大保底状态：上次五星!A，这次必获得A；\n小保底状态：上次五星是A（初始状态），这次只有50%的概率获得A。\nk &#x3D; 0 ： 获得五星角色A\nk &#x3D; 1 ： 获得五星角色且!A\n\n（临时变量：tmp：上次获得五星的祈愿次数）\n\n注意：要明确状态转移的结果“from to”。循环遍历时，由j逐步+k确定后续值并进行迭代赋值，会导致一个点的值多次计入概率，所以最后取概率只需要取[0]\n\n$$ dp[i][j][0] &#x3D; dp[i-1][tmp][1] * PDF(j-tmp) + dp[i-1][tmp][0] * \\frac{1}{2} * PDF(j-tmp)$$\n$$ dp[i][j][1] &#x3D; dp[i][tmp][0] * \\frac{1}{2} * PDF(j-tmp)$$\nn5_cnt&#x3D;1;#要抽出多少次A\nn5_tries&#x3D;180;#准备的祈愿次数\ntmp &#x3D; 0;\ndp_p &#x3D; np.zeros((13, 180*n5_cnt+90,2), dtype&#x3D;float);\ndp_p[0][0][0] &#x3D; 1\nfor i in range (0,n5_cnt+1):\n        for j in range (0,n5_tries):\n            for k in range (1,91):\n                if(i-1&gt;&#x3D;0):\n                    dp_p[i][j+k][0] +&#x3D; dp_p[i-1][j][1] * pdf_5[k-1] + dp_p[i-1][j][0] * 0.5 * pdf_5[k-1];\n                dp_p[i][j+k][1] +&#x3D; dp_p[i][j][0] * 0.5 * pdf_5[k-1]\nposs&#x3D;[]\nfor i in range(0,n5_tries):\n    tmp &#x3D; tmp + dp_p[n5_cnt][i][0]\n    poss.append(tmp)\nprint(tmp)\nplt.plot(poss)\n#DEMO:0.4762677010731945\n\n 与上面的卷积验证是一致的。\n0命概率图：\n非默认状态开始的动态规划（To Be Continued…）如果开始状态为大保底状态，或已经有一定的祈愿次数呢？以后再写。\n四星角色祈愿分析预设：获取到五星时，不会重置四星角色的保底。且，以下策略，如果出了五星角色，先笑一笑，算法就当没祈愿哈~\n概览四星的分析只需要将上面的p_5相关改成p_4即可，在此省略不表，给出一定结论：\n0命图：\n算法定义：$ dp[i][j][k] $ ：第j次祈愿的结果对应k，并第i次获得B角色的概率，则状态转移方程：\n\n保底状态：上次四星!UP，这次必获得UP角色\nk &#x3D; 0 ： 获得想要的四星角色B\nk &#x3D; 1 ： 获得UP四星角色但不是B\nk &#x3D; 2：获得非UP四星角色\n\n（临时变量：tmp：上次获得四星的祈愿次数）\n$$ dp[i][j][0] &#x3D; dp[i-1][tmp][1] * PDF(j-tmp) * \\frac{1}{6} \\+ dp[i-1][tmp][0] * \\frac{1}{6} * PDF(j-tmp) \\+ dp[i-1][tmp][1] * PDF(j-tmp) * \\frac{1}{3}$$\n$$ dp[i][j][1] &#x3D; dp[i][tmp][0] * \\frac{1}{3} * PDF(j-tmp) \\+ dp[i][tmp][1] * PDF(j-tmp) * \\frac{1}{3} \\+  dp[i][tmp][2] * \\frac{2}{3} * PDF(j-tmp)$$\n$$ dp[i][j][2] &#x3D; dp[i][tmp][0] * \\frac{1}{2} * PDF(j-tmp) + dp[i][tmp][1] * \\frac{1}{2} * PDF(j-tmp)$$\n任意代码：（原理与下方“无定轨机制武器祈愿”类似，这里人比较懒，直接对p_5移花接木了）\n#每抽概率\n#这是研究四星的，但是为了偷懒，捏：\ndef p_5(n):\n    if n &lt; 8:\n        return 0.051;\n    elif n &lt; 9:\n        return 0.561;\n    else:\n        return 1;\n        \npdf_5 &#x3D; [];\ncdf_5 &#x3D; [];\ntmp &#x3D; 0.0;\n\nfor i in range (0,10):\n    tmp &#x3D; p_5(i);\n    for j in range(0,i):\n        tmp &#x3D; tmp * (1 - p_5(j))\n    pdf_5.append(tmp);\n\nfor i in range (0,10):\n    tmp &#x3D; 0.0;\n    for j in range (0,i+1):\n        tmp &#x3D; tmp + pdf_5[j];\n    cdf_5.append(tmp);\n    print(i+1,cdf_5[i])\n \nn5_cnt&#x3D;1#要抽出多少次B\nn5_tries&#x3D;130 * n5_cnt;#准备的祈愿次数\ntmp &#x3D; 0;\ndp_p &#x3D; np.zeros((13, 150*n5_cnt + 20,3), dtype&#x3D;float);\ndp_p[0][0][0] &#x3D; 1\n# 0 - B 1 - UP &amp; !B 2- !UP\nfor i in range (0,n5_cnt+1):\n        for j in range (0,n5_tries):\n            for k in range (1,11):\n                if(i-1&gt;&#x3D;0):\n                    dp_p[i][j+k][0] +&#x3D; dp_p[i-1][j][2] * pdf_5[k-1] * 1&#x2F;3\\\n                                    + dp_p[i-1][j][1] * pdf_5[k-1] * 1&#x2F;6 + dp_p[i-1][j][0] * 1&#x2F;6 * pdf_5[k-1];\n                dp_p[i][j+k][1] +&#x3D; dp_p[i][j][0] * 1&#x2F;3 * pdf_5[k-1] + dp_p[i][j][2] * 2&#x2F;3 * pdf_5[k-1]\\\n                                + dp_p[i][j][1] * 1&#x2F;3 * pdf_5[k-1];\n                dp_p[i][j+k][2] +&#x3D; dp_p[i][j][0] * 1&#x2F;2 * pdf_5[k-1] + dp_p[i][j][1] * 1&#x2F;2 * pdf_5[k-1];\nposs&#x3D;[]\nfor i in range(0,n5_tries):\n    tmp &#x3D; tmp + dp_p[n5_cnt][i][0]\n    poss.append(tmp)\nprint(tmp)\n#制图代码，直接cv用\nx_major_locator&#x3D;MultipleLocator(10)#x分度值设置\ny_major_locator&#x3D;MultipleLocator(0.1)\nax&#x3D;plt.gca()\nax.xaxis.set_major_locator(x_major_locator)\nax.yaxis.set_major_locator(y_major_locator)\nx_values &#x3D; [x for x in range(1, n5_tries)]\nplt.grid()  # 生成网格\nplt.plot(poss)  \n\n\n\n不同模型对比研究与无保底机制（均匀1.6%）的对比​    修改\ndef p_5(n):\n\treturn 0.016;\n\n期望：不变；\n分位点图：\n极端情况上升了~\n两次五星分布图：\n一命概率分布图：\n可以发现，均匀和非均匀，有利有弊吧。\n与保底前均匀机制（魔改尝试1）的对比用我比较熟悉的c++建模以下（其实更精确的值为0.88%）\n$$  P(x) &#x3D; \\begin{cases} 0.9% &amp;{x\\leqslant 89}\\1&amp;{x &#x3D; 90} \\end{cases} $$\n期望：62.06（综合概率：1.61%）\n分位点分布图：\n\n两次五星分布图：\n一命概率分布图：\n会让更多人吃保底~\n武器祈愿分析概率递增保底机制及数字特征武器祈愿的机制和角色祈愿大体一致。算法参上，在此直接给出结论。\n五星武器概率：\n$$P(x) &#x3D; \\begin{cases}0.7% &amp; x\\leqslant62\\0.7%+7%(x-62) &amp; 63\\leqslant x \\leqslant 71\\ 63.7% + 3.5%(x-71) &amp; 72\\leqslant x \\leqslant 79 \\ 1 &amp; x&#x3D;80\\end{cases}$$ \n数学期望：54.25.\n综合概率：1.88%\n分布图：\n四星武器概率\n$$P(x) &#x3D; \\begin{cases}6% &amp; x\\leqslant 7\\66% &amp; x &#x3D; 8 \\ 96% &amp; x &#x3D; 9 \\ 1 &amp; x&#x3D;10\\end{cases}$$\n数学期望：6.74.\n综合概率：14.84%。\n你会发现，分成了四段，复杂了一点。\n#每抽概率\ndef p_5(n):\n    if n &lt; 62:\n        return 0.007;\n    elif n &lt; 71:\n        return 0.007 + (n - 62) * 0.07;\n    elif n &lt; 79:\n        return 0.637 + (n - 71) * 0.035;\n    else:\n        return 1.0;\ndef p_4(n):\n    if n &lt; 7:\n        return 0.06\n    elif n &lt; 8:\n        return 0.66\n    elif n &lt; 9:\n        return 0.96;\n    else:\n        return 1;\npdf_5 &#x3D; [];#第x+1抽出概率\ncdf_5 &#x3D; [];\ntmp &#x3D; 0.0;\n\nfor i in range (0,80):\n    tmp &#x3D; p_5(i);\n    for j in range(0,i):\n        tmp &#x3D; tmp * (1.0 - p_5(j))\n    pdf_5.append(tmp);\n\nfor i in range (0,80):\n    tmp &#x3D; 0.0;\n    for j in range (0,i+1):\n        tmp &#x3D; tmp + pdf_5[j];\n    cdf_5.append(tmp);\n    print(i+1,cdf_5[i])\n\n\n\n定轨机制下的资源规划（假设定轨M）获取五星武器M的祈愿次数分析由于命定值机制，马尔可夫过程比较复杂。于是考虑动态规划：\n定义$dp[i][j][k]$为第j次祈愿时第i次获得五星武器M，祈愿后k：\n\nk &#x3D; 0 : 命定值为0。表示抽到了M.\nk &#x3D; 1：命定值为1且抽到了N.\nk &#x3D; 2：命定值为1且抽到的是非UP武器。\nk &#x3D; 3：命定值为2，抽出来的不是M，具体是啥在本小节中不相关。\n\n$$ dp[i][j][0] &#x3D; dp[i-1][tmp][0] * \\frac{3}{8} *PDF(j-tmp) \\+ dp[i-1][tmp][1] * \\frac{3}{8} * PDF(j-tmp) \\+ dp[i-1][tmp][2] * \\frac{1}{2}*PDF(j-tmp) \\+ dp[i-1][tmp][3] *PDF(j-tmp)$$\n$$ dp[i][j][1] &#x3D; dp[i][tmp][0] \\frac{1}{4} PDF(j-tmp)$$\n$$ dp[i][j][2] &#x3D; dp[i][tmp][0] \\frac{3}{8} PDF(j-tmp)$$\n$$ dp[i][j][3] &#x3D; dp[i][tmp][1] * ( \\frac{3}{8} + \\frac{1}{4}) *PDF(j-tmp) \\ + dp[i][tmp][2] * \\frac{1}{2} * PDF(j-tmp)$$\n运行代码：\nn5_cnt&#x3D;2;#要抽出多少次M\nn5_tries&#x3D; 207;#准备的祈愿次数\ntmp &#x3D; 0;\ndp_p &#x3D; np.zeros((13, 330*n5_cnt,5), dtype&#x3D;float);\ndp_p[0][0][0] &#x3D; 1\nfor i in range (0,n5_cnt+1):\n        for j in range (0,n5_tries + n5_cnt + 1):\n            for k in range (1,81):\n                if(i-1&gt;&#x3D;0):\n                    dp_p[i][j+k][0] +&#x3D; dp_p[i-1][j][0] * pdf_5[k-1] * 0.375\\\n                                + dp_p[i-1][j][1] * 0.375 * pdf_5[k-1] \\\n                                + dp_p[i-1][j][2] * 0.5 * pdf_5[k-1]\\\n                                + dp_p[i-1][j][3] * pdf_5[k-1];\n                dp_p[i][j+k][1] +&#x3D; dp_p[i][j][0] * 0.25 * pdf_5[k-1];\n                dp_p[i][j+k][2] +&#x3D; dp_p[i][j][0] * 0.375 * pdf_5[k-1];\n                dp_p[i][j+k][3] +&#x3D; dp_p[i][j][1] * 0.625 * pdf_5[k-1]\\\n                                + dp_p[i][j][2] * 0.5 * pdf_5[k-1];\nposs&#x3D;[]\nfor i in range(0,n5_tries):\n    tmp &#x3D; tmp + dp_p[n5_cnt][i][0]\n    poss.append(tmp)\nprint(tmp)\nplt.plot(poss)\n#0.49317051582855165\n\n进行99次祈愿后，获得M的概率达到50%。以下是获取一次武器M的概率分布图：\n\n获取五星武器N的祈愿次数分析问题：我定轨了M，反而想获取五星武器N…（反向定轨）\n定义$dp[i][j][k]$为第j次祈愿时第i次获得五星武器N，祈愿后k：\n\nk &#x3D; 0 : 命定值为0。表示抽到了M.\nk &#x3D; 1：命定值为1且抽到了N.\nk &#x3D; 2：命定值为1且抽到的是非UP武器。\nk &#x3D; 3：命定值为2，且抽到了N.\nk &#x3D; 4：命定值为2，且抽到的是非UP武器。\n\n$$ dp[i][j][0] &#x3D; dp[i][tmp][0] * \\frac{3}{8} *PDF(j-tmp) \\ + dp[i][tmp][1] * \\frac{3}{8} * PDF(j-tmp) \\+ dp[i][tmp][2] * \\frac{1}{2}*PDF(j-tmp) \\+ dp[i][tmp][3] * PDF(j-tmp) \\ + dp[i][tmp][4] * PDF(j-tmp)$$\n$$ dp[i][j][1] &#x3D; dp[i-1][tmp][0] \\frac{3}{8} PDF(j-tmp)$$\n$$ dp[i][j][2] &#x3D; dp[i][tmp][0] \\frac{1}{4} PDF(j-tmp)$$\n$$ dp[i][j][3] &#x3D; dp[i-1][tmp][1] * ( \\frac{3}{8}) * PDF(j-tmp) \\ + dp[i-1][tmp][2] * \\frac{1}{2} * PDF(j-tmp)$$\n$$ dp[i][j][4] &#x3D; dp[i][tmp][1] * \\frac{1}{4} * PDF(j-tmp)$$\nn5_cnt&#x3D;1;#要抽出多少次N\nn5_tries&#x3D; 106;#准备的祈愿次数\ntmp &#x3D; 0;\ndp_p &#x3D; np.zeros((13, 510*n5_cnt + 80,5), dtype&#x3D;float);\ndp_p[0][0][0] &#x3D; 1\nfor i in range (0,n5_cnt+1):\n        for j in range (0,n5_tries + n5_cnt + 1):\n            for k in range (1,81):\n                dp_p[i][j+k][0] +&#x3D; dp_p[i][j][0] * pdf_5[k-1] * 0.375\\\n                                + dp_p[i][j][1] * 0.375 * pdf_5[k-1] \\\n                                + dp_p[i][j][2] * 0.5 * pdf_5[k-1]\\\n                                + dp_p[i][j][3] * pdf_5[k-1]\\\n                                + dp_p[i][j][4] * pdf_5[k-1];\n                dp_p[i][j+k][1] +&#x3D; dp_p[i-1][j][0] * 0.375 * pdf_5[k-1];\n                dp_p[i][j+k][2] +&#x3D; dp_p[i][j][0] * 0.25 * pdf_5[k-1];\n                dp_p[i][j+k][3] +&#x3D; dp_p[i-1][j][1] * 0.375 * pdf_5[k-1]\\\n                                + dp_p[i-1][j][2] * 0.5 * pdf_5[k-1];\n                dp_p[i][j+k][4] +&#x3D; dp_p[i][j][1] * 0.25 * pdf_5[k-1]\nposs&#x3D;[]\nfor i in range(0,n5_tries):\n    tmp &#x3D; tmp + dp_p[n5_cnt][i][1] + dp_p[n5_cnt][i][3]\n    poss.append(tmp)\nprint(tmp)\n#DEMO:0.5007747697175682\n\n图表\n​    \n获取五星武器M、N的祈愿次数分析（To Be Updated…)问题：我定轨了M，但M、N都想要。\n我可能比较蠢：四维动态规划？\n定义$dp[h][i][j][k]$为第j次祈愿时第i次获得五星武器N，第h获得五星武器M，祈愿后k：……（同上）\n呃，我们先不考虑土豪了哈，我们只考虑都只获得1次的情况，只需要把tmp = tmp + dp_p[n5_cnt][i][1] + dp_p[n5_cnt][i][3] 再加一项 dp_p[n5_cnt][i][0] ？\n我也希望这能成功，但是这么直接地不可行，因为前面那两项的概率本身就包含了上一次抽到M的情况，再加会导致重复计算，我没想到别的方式改良之。\n另一种思路是分类讨论了，分为先获得M后获得N、先获得N再获得M两种情况。\n再者就是还是含泪：\n\n需要做出一定的修改，使状态转移时，不忽略h的出现次数。\n\n$$ dp[h][i][j][0] &#x3D; dp[h-1][i][tmp][0] * \\frac{3}{8} *PDF(j-tmp) \\ + dp[h-1][i][tmp][1] * \\frac{3}{8} * PDF(j-tmp) \\+ dp[h-1][i][tmp][2] * \\frac{1}{2}*PDF(j-tmp) \\+ dp[h-1][i][tmp][3] * PDF(j-tmp) \\ + dp[h-1][i][tmp][4] * PDF(j-tmp)$$\n$$ dp[h][i][j][1] &#x3D; dp[h][i-1][tmp][0] \\frac{3}{8} PDF(j-tmp)$$\n$$ dp[h][i][j][2] &#x3D; dp[h][i][tmp][0] \\frac{1}{4} PDF(j-tmp)$$\n$$ dp[h][i][j][3] &#x3D; dp[h][i-1][tmp][1] * ( \\frac{3}{8}) * PDF(j-tmp) \\ + dp[h][i-1][tmp][2] * \\frac{1}{2} * PDF(j-tmp)$$\n$$ dp[h][i][j][4] &#x3D; dp[h][i][tmp][1] * \\frac{1}{4} * PDF(j-tmp)$$\n事实证明上面的方法不一定获得了正确答案。这个错误是没有价值的吗，不，他可能会给一个同样想研究这一问题的人一个参考。于是提出下面的形式：\n定义$dp[i][j][k]$为第j次祈愿时，i - 获得的目标种类数 , 祈愿后k同上。\n其实关键原因和上面的“加一项”一样，就是因为最后获取概率时，需要涵盖多个状态。以前的动态规划获取概率时，获取的状态间互相不存在依赖，而这次获取概率时，各个状态内部的转移存在相关。\n最近灵感较为枯竭，先赶别的ddl了。在此附上可能是错误的代码（若考虑较大次数，可能需修改码参数&#x2F;概率不准确）和运行结果：\nn5_cnt_M&#x3D;1;#要抽出多少次M,N\nn5_cnt_N&#x3D;1;\nn5_cnt&#x3D;n5_cnt_M + n5_cnt_N;\nn5_tries&#x3D; 180*n5_cnt;#准备的祈愿次数\ntmp &#x3D; 0;\ndp_p &#x3D; np.zeros((13,13, 310*n5_cnt + 80,5), dtype&#x3D;float);\ndp_p[0][0][0][0] &#x3D; 1\n\nh &#x3D; 0;\nfor h in range (0,3*n5_cnt_M +1):\n    for i in range(0,3*n5_cnt_N+1):\n        for j in range (0,n5_tries + n5_cnt + 1):\n            for k in range (1,81):\n                    dp_p[h][i][j+k][0] +&#x3D; dp_p[h-1][i][j][0] * pdf_5[k-1] * 0.375\\\n                                + dp_p[h-1][i][j][1] * 0.375 * pdf_5[k-1] \\\n                                + dp_p[h-1][i][j][2] * 0.5 * pdf_5[k-1]\\\n                                + dp_p[h-1][i][j][3] * pdf_5[k-1]\\\n                                + dp_p[h-1][i][j][4] * pdf_5[k-1];\n                    dp_p[h][i][j+k][1] +&#x3D; dp_p[h][i-1][j][0] * 0.375 * pdf_5[k-1];\n                    dp_p[h][i][j+k][2] +&#x3D; dp_p[h][i][j][0] * 0.25 * pdf_5[k-1];\n                    dp_p[h][i][j+k][3] +&#x3D; dp_p[h][i-1][j][1] * 0.375 * pdf_5[k-1]\\\n                                + dp_p[h][i-1][j][2] * 0.5 * pdf_5[k-1];\n                    dp_p[h][i][j+k][4] +&#x3D; dp_p[h][i][j][1] * 0.25 * pdf_5[k-1]\n\nposs&#x3D;[]\nfor i in range(0,n5_tries):\n    for i1 in range (n5_cnt_M,3*n5_cnt_M+1):\n        tmp +&#x3D; dp_p[i1][n5_cnt_N][i][1] + dp_p[i1][n5_cnt_N][i][3]\n    for i2 in range(n5_cnt_N,3*n5_cnt_N+1):\n        tmp +&#x3D; dp_p[n5_cnt_M][i2][i][0];\n    poss.append(tmp)\nprint(tmp)\n#制图代码，直接cv用\nx_major_locator&#x3D;MultipleLocator(20)#x分度值设置\ny_major_locator&#x3D;MultipleLocator(0.1)\nax&#x3D;plt.gca()\nax.xaxis.set_major_locator(x_major_locator)\nax.yaxis.set_major_locator(y_major_locator)\nplt.grid()  # 生成网格\nplt.plot(poss)\n\n\n拓展问题：我先定轨了M，获取M后定轨N（命定值清零），参考上面两个问题叠加应该可以。\n四星武器的分析和上面四星角色祈愿分析思想一致。\n#偷懒：p_5的内容实际是p_4\nn5_cnt&#x3D;1#要抽出多少次F\nn5_tries&#x3D;130 * n5_cnt;#准备的祈愿次数\ntmp &#x3D; 0;\ndp_p &#x3D; np.zeros((13, 150*n5_cnt + 20,3), dtype&#x3D;float);\ndp_p[0][0][0] &#x3D; 1\n# 0 - F 1 - UP &amp; !F 2- !UP\nfor i in range (0,n5_cnt+1):\n        for j in range (0,n5_tries):\n            for k in range (1,11):\n                if(i-1&gt;&#x3D;0):\n                    dp_p[i][j+k][0] +&#x3D; dp_p[i-1][j][2] * pdf_5[k-1] * 1&#x2F;5\\\n                                    + dp_p[i-1][j][1] * pdf_5[k-1] * 3&#x2F;20 + dp_p[i-1][j][0] * 3&#x2F;20 * pdf_5[k-1];\n                dp_p[i][j+k][1] +&#x3D; dp_p[i][j][0] * 3&#x2F;5 * pdf_5[k-1] + dp_p[i][j][2] * 4&#x2F;5 * pdf_5[k-1]\\\n                                + dp_p[i][j][1] * 3&#x2F;5 * pdf_5[k-1];\n                dp_p[i][j+k][2] +&#x3D; dp_p[i][j][0] * 1&#x2F;4 * pdf_5[k-1] + dp_p[i][j][1] * 1&#x2F;4 * pdf_5[k-1];\nposs&#x3D;[]\nfor i in range(0,n5_tries):\n    tmp &#x3D; tmp + dp_p[n5_cnt][i][0]\n    poss.append(tmp)\nprint(tmp)\n#制图代码，直接cv用\nx_major_locator&#x3D;MultipleLocator(10)#x分度值设置\ny_major_locator&#x3D;MultipleLocator(0.1)\nax&#x3D;plt.gca()\nax.xaxis.set_major_locator(x_major_locator)\nax.yaxis.set_major_locator(y_major_locator)\nx_values &#x3D; [x for x in range(1, n5_tries)]\nplt.grid()  # 生成网格\nplt.plot(poss)  \n\n\n无定轨机制下武器祈愿分析和上面四星角色祈愿分析思想一致。\n#这次下面是真的武器池概率分布p_5了哈\nn5_cnt&#x3D;1#要抽出多少次M\nn5_tries&#x3D;240 * n5_cnt;#准备的祈愿次数\ntmp &#x3D; 0;\ndp_p &#x3D; np.zeros((13, 320*n5_cnt + 20,3), dtype&#x3D;float);\ndp_p[0][0][0] &#x3D; 1\n# 0 - M 1 - UP &amp; !M 2- !UP\nfor i in range (0,n5_cnt+1):\n        for j in range (0,n5_tries):\n            for k in range (1,81):\n                if(i-1&gt;&#x3D;0):\n                    dp_p[i][j+k][0] +&#x3D; dp_p[i-1][j][2] * pdf_5[k-1] * 1&#x2F;2 \\\n                                    + dp_p[i-1][j][1] * pdf_5[k-1] * 3&#x2F;8 + dp_p[i-1][j][0] * 3&#x2F;8 * pdf_5[k-1];\n                dp_p[i][j+k][1] +&#x3D; dp_p[i][j][0] * 3&#x2F;8 * pdf_5[k-1] + dp_p[i][j][2] * 1&#x2F;2 * pdf_5[k-1]\\\n                                + dp_p[i][j][1] * 3&#x2F;8 * pdf_5[k-1];\n                dp_p[i][j+k][2] +&#x3D; dp_p[i][j][0] * 1&#x2F;4 * pdf_5[k-1] + dp_p[i][j][1] * 1&#x2F;4 * pdf_5[k-1];\nposs&#x3D;[]\nfor i in range(0,n5_tries):\n    tmp &#x3D; tmp + dp_p[n5_cnt][i][0]\n    poss.append(tmp)\nprint(tmp)\n#制图代码，直接cv用\nx_major_locator&#x3D;MultipleLocator(15)#x分度值设置\ny_major_locator&#x3D;MultipleLocator(0.1)\nax&#x3D;plt.gca()\nax.xaxis.set_major_locator(x_major_locator)\nax.yaxis.set_major_locator(y_major_locator)\nx_values &#x3D; [x for x in range(1, n5_tries)]\nplt.grid()  # 生成网格\nplt.plot(poss)  \n\n你如果和上面定轨时比较，会发现你想要M的话，需要投入稍微更多的抽数。而且可以看见，当投入200抽时，定轨机制下的获取M的概率已经逐步收敛至1。而不定轨机制下，获取到的概率的概率仅在80%附近，且之后收敛较慢，极端情况的发生概率并不低。\n有关不定轨又同时想要M和N的，TBC…\n总结概率分析还可以分析：如何配置属性让伤害最大化等问题。概率论作为一种打破人的直觉的东西，实在是让人又爱又恨。本文不仅仅局限于传统的期望范畴，结合具体概率的分布分析了对应的抽数需求。由于祈愿机制的概率不是恒定的，期望与中分位点存在区别，可以用平均GDP和中位数来感受。\n致谢：感谢张老师的帮助和OneBST的分享。\n【To Be Continued】\n\n同时研究多个四星的祈愿次数\n\n常驻祈愿结合“联动规则”的分析\n\n常驻祈愿与UP祈愿结合分析\n\n蒙特卡罗模拟与大数定律\n\n通过置信度研究极端情况\n\n\n","slug":"概率论论文","date":"2022-01-13T01:42:26.000Z","categories_index":"数据分析","tags_index":"原神,数据分析","author_index":"Liul"},{"id":"02283cddd2f2c72dd0f98ea650045063","title":"C++ 特性","content":"从C进步到C++——特性[TOC]\n结构体初始化构造定义结构体时，加入以下语句，可以方便地进行初始化。\nstruct student&#123;\n\tint id;\n\tchar gender;\n\t\n\tstudent()&#123;&#125;  &#x2F;&#x2F;系统默认，用于未经初始化定义结构体\n\t\n\tstudent (int _id, char _gender )&#123;\n\t\tid &#x3D; _id;\n\t\tgender &#x3D; _gender;\n\t&#125;&#x2F;&#x2F;用于初始化id和gender。注意：减少参数 可以达到只使用部分元素构造的效果\n&#125;\n\n构造函数可以简化为一行，并且可以进行默认赋值，如此调用时可以省略对应参数。如：\nPoint (int x&#x3D;0 , int y &#x3D; 0):x(x),y(y) &#123;&#125;;\n&#x2F;&#x2F;Point();\n\n\n\n这是一个二叉树节点的定义示例：\nstruct TreeNode &#123;\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n    TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;\n&#125;;\n\n\n\nauto声明推断使用STL容器时的迭代器声明等等往往比较复杂，此时使用 auto 可简单很多：\nvector&lt;int&gt; vec;\nauto pvec &#x3D; vec.begin();&#x2F;&#x2F;vector&lt;int&gt;::iterator\n\n\n\n容器类for-range循环对数组或容器执行循环操作可写成：\ndouble prices[5] &#x3D; &#123;1.1 , 2.2 , 3.3 , 4.4 , 5.5&#125;\nfor ( double x : prices)&#123;&#x2F;&#x2F;只读\n\tcout&lt;&lt;x&lt;&lt;endl;\n&#125;\nfor ( double &amp;x : prices)&#123;&#x2F;&#x2F;写需要使用指针\n\tx &#x3D; x &#x2F; 2;\n&#125;\n\n\n\n结合上面的auto 部分循环可以写成：\nfor ( auto x : vec )\n\n\n\nstring类的类型转换函数int i &#x3D; 43;\nstring s &#x3D; to_string(i);\ndouble d &#x3D; stod(s);&#x2F;&#x2F;43.000000\n&#x2F;&#x2F;对应的有：stoi , stoll , stof\n\n注意不要传入空串！\nrotate&#x2F;copy&#x2F;fill函数rotate函数可以“平移”。直接看例子吧：\nvector&lt;int&gt; a&#123;1,2,3,4,5,6,7,8,9&#125;;\nrotate(a.begin() , a.begin()+2 , a.end());\n&#x2F;&#x2F;a:[3,4,5,6,7,8,9,1,2]\n\n相当于得到：[mid:end] + [begin:mid)\ncopy函数将一个目标（容器、数组）里面的元素复制至另一个目标。\n注：使用前 newvector.resize(7) 这行代码为newvector分配空间，防止程序崩溃。\n此外，通过vector&lt;int&gt;  dp ( 7 , 0 )也可以达到初始化dp为[0,0,0,0,0,0,0].\nfill函数可以为数组和vector赋初始值。头文件：&lt;algorithm&gt;\nint v[10];\nfill(v,v+10,-1);&#x2F;&#x2F;相当于 memset(v,-1,sizeof v);\nint s[10][10];\nfill(s[0],s[0]+10*10,-1);\n\n\n\nsort&#x2F;lower_bound&#x2F;upper_bound&#x2F;unique函数sort函数可用于 vector 、 数组 和 deque 的排序。如：\nsort(b,b+n,greater&lt;int&gt;());&#x2F;&#x2F;将b降序排列\n\n在已排好升序的情况下：\n1.可使用lower_bound函数（startptr，endptr ，num）得到第一个不小于num的值的指针。（二分查找）。如下代码返回下标：\nint a[10];&#x2F;&#x2F;......\nint b &#x3D; upper_bound(a , a+10 , 3) - a;\n\n2.可使用unique函数返回最后一个非重复元素的指针，如下代码进行去重。\nvec.erase( unique(vec.begin(),vec.end()) , vec.end() );\n\n拓展排序：partial_sort 方法\n局部排序partiai_sort可以提供一定区间的排序获得。原理似乎是堆排序。\nfor(i&#x3D;10;i&gt;&#x3D;1;i--)\tvec.push_back(i);\npartial_sort(vec.begin(),vec.begin()+3,vec.end());\n&#x2F;&#x2F;[1,2,3,10,9,8,7,6,5,4]\n\nrep(i,1,10) a.push_back(i);\npartial_sort(vec.begin(),vec.begin()+3,vec.end(),greater&lt;int&gt;());\n&#x2F;&#x2F;[10,9,8,1,2,3,4,5,6,7]\n\n应用：班上有10个学生，我想知道分数最低的5名是哪些人。如果没有partial_sort，你就需要用sort把所有人排好序，然后再取前5个。现在你只需要对分数最低5名排序。\n一些可能有用的数学函数指对运算\n以下函数：接收x为float    double类型，返回传入类型。\nexp2(x)  - 快速返回2的x次幂。\nlog2(x) - 得到以2为底x的对数。\nlog10(x) - 得到以10为底x的对数。\nlog(x)  - 得到x的自然对数。\nexpm(x) - 返回e的x次幂-1。\nexp(x) - 得到e的x次幂。x支持complex类型。\n取整函数\n以下函数的传入传出同上。\nfloor(x) - 向下取整。\nceil(x) - 向上取整。 \nround(x) - 四舍五入，基本类似于floor(x+0.5)。但是中点情况下向远离0的方向舍入。\ntrunc(x) - 将x向0方向舍入。\n数组生成- iota&#x2F;shuffle递增数组：与 golang 可对比：\niota(arr,arr+n,0);&#x2F;&#x2F;[0,1,2,3,4,...];\n\n随机打乱数组：\nsrand(time(NULL));\nrandom_shuffle(a+1,a+n+1);\n\nrandom_shuffle 自 C++14 起被弃用，C++17 起被移除。可以使用 shuffle 函数代替：\nshuffle(v.begin(),v.end(),rand)（最后一个参数传入的是使用的随机数生成器，一般情况下传入 rand 即可）。\n使用时需要设置随机数种子，配合iota可以实现类似于“洗牌”的效果。同时可进行随机的多次模拟，为了时间种子的不同，可能需要每次模拟间设置sleep间隔。\n参考资料：\n《C++ Primer》 目录\n《C++ Primer Plus》  18.1\n《算法竞赛入门经典习题解答》第一章\nhttp://www.cppblog.com/mzty/archive/2005/12/15/1770.aspx\n","slug":"从C进步到C++——特性","date":"2021-08-13T03:12:56.000Z","categories_index":"语言基础","tags_index":"C++,语法","author_index":"Liul"},{"id":"705805ce17024f8fb64b911637d83992","title":"C++ STL使用手册","content":"#C++ STL的使用手册\n[toc]\n\n共有函数=：有赋值运算符以及复制构造函数。\nbegin()：返回指向开头元素的迭代器。\nend()：返回指向末尾的下一个元素的迭代器。end() 不指向某个元素，它是末尾元素的后继。\nsize()：返回容器内的元素个数。\nmax_size()：返回容器 理论上 能存储的最大元素个数。依容器类型和所存储变量的类型而变。\nempty()：返回容器是否为空的一个 bool 值，即 begin() == end()，true 为空，false 为非空。\nswap()：交换两个容器。\nclear()：清空容器。\n==&#x2F;!=&#x2F;&lt;&#x2F;&gt;&#x2F;&lt;=&#x2F;&gt;=：按 字典序 比较两个容器的大小。（比较元素大小时 map 的每个元素相当于 set&lt;pair&lt;key, value&gt; &gt;，pair 按 first 到 second 的顺序比较。无序容器不支持 &lt;&#x2F;&gt;&#x2F;&lt;=&#x2F;&gt;=\n序列式容器vector元素访问\n\nat()\nv.at(pos) 返回容器中下标为 pos 的引用。如果数组越界抛出 std::out_of_range 类型的异常。\n\noperator[]\nv[pos] 返回容器中下标为 pos 的引用。不执行越界检查。\n\nfront()\nv.front() 返回首元素的引用。\n\nback()\nv.back() 返回末尾元素的引用。\n\n\n迭代器\n\nbegin()/cbegin()\n返回指向首元素的迭代器，其中 *begin = front。\n\nend()/cend()\n返回指向数组尾端占位符的迭代器，注意是没有元素的。\n\n\n 可以认为，v[i]与*(v.begin()+i)等价。但，除vector string外，其他STL容器不支持后者的形式。\n\nsize() 返回容器长度（元素数量），即 std::distance(v.begin(), v.end())。\n\ninsert() 支持在某个迭代器位置插入元素、可以插入多个。复杂度与 pos 距离末尾长度成线性而非常数\n\nerase() 删除某个迭代器或者区间的元素，返回最后被删除的迭代器。复杂度与 insert 一致。\n\npush_back(x) 在末尾插入一个元素x，均摊复杂度：常数，最坏为线性复杂度。\n\npop_back() 删除末尾元素，常数复杂度。\n\n\ndeque能够提供线性复杂度的插入和删除，以及常数复杂度的随机访问。操作大同vector。\n\npush_front() 在头部插入一个元素。\n\npop_front() 删除头部元素。\n\npush_back() 在末尾插入一个元素。\n\npop_back() 删除末尾元素。\n\n\nlist与deque大致相同，但是由于 list 的实现是链表，因此不提供随机访问的接口。若需要访问中间元素，则需要使用迭代器。\n\nfront() 返回首元素的引用。\n\nback() 返回末尾元素的引用。\n\n\narray(C++11)\n\n\n成员函数\n作用\n示例\n\n\n\noperator=\narray2 的每个元素重写 array1 对应元素\n\n\n\nmax_size\n返回可容纳的最大元素数\n\n\n\nfill\n以指定值填充容器\narr.fill(1);\n\n\nswap\n交换，交换array的复杂度为：O(size)\n\n\n\n\n\n\n非成员函数\n作用\n\n\n\noperator==\n按照字典序比较 array 中的值\n\n\nstd::get\n访问 array 的一个元素\n\n\n关联式容器统一共有函数\nfind(x): 若容器内存在键为 x 的元素，会返回该元素的迭代器；否则返回 end()。\n\n\nerase(pos) 删除迭代器为 pos 的元素，可结合find函数使用。\n\nerase(first,last) 删除迭代器在 [first,last)范围内的所有元素。\n\ncount(x): 返回容器内键为 x 的元素数量。\n\nlower_bound(x): 返回指向首个不小于 给定键的元素的迭代器。\n\nupper_bound(x): 返回指向首个**大于 **给定键的元素的迭代器。若容器内所有元素均小于或等于给定键，返回 end()。\n\nsize(): 返回容器内元素个数。\n\n\nsetset 内部采用红黑树实现。平衡二叉树的特性使得 set 非常适合处理需要同时兼顾查找、插入与删除的情况。\n\ninsert(x) 将元素 x 插入到 set 中。自动排序和去重。\nerase(x) 删除值为 x 的 所有 元素，返回删除元素的个数。\nerase(first,last) 删除迭代器在 [first,last)范围内的所有元素。\n\nmapmap 重载了 operator[]，可以用任意定义了 operator &lt; 的类型作为下标（在 map 中叫做 key，也就是索引）。\n\n可以直接通过下标访问来进行查询或插入操作。例： mp[&quot;Alan&quot;]=100。利用下标访问 时，如果 map 中不存在相应键的元素，会自动在 map 中插入一个新元素，并将其值设置为默认值（对于整数，值为零；对于有默认构造函数的类型，会调用默认构造函数进行初始化）\n通过向 map 中插入一个类型为 pair&lt;Key, T&gt; 的值可以达到插入元素的目的，例如 mp.insert(pair&lt;string,int&gt;(&quot;Alan&quot;,100));\nerase(key) 函数会删除键为 key 的 所有 元素。返回值为删除元素的数量。\n\n哈希适配容器四种基于哈希实现的无序关联式容器：unordered_set，unordered_multiset，unordered_map，unordered_multimap。\n其操作与关联式容器类似。\n容器适配器为什么称为容器适配器呢，是因为其内部的实现是基于vector  deque  等等，其原理可以参考《STL源码剖析》。\n后进先出的stack仅支持查询或删除最后一个加入的元素（栈顶元素），不支持随机访问。\n\ntop() 访问栈顶元素（如果栈为空，此处会出错）\npush(x) 向栈中插入元素 x\npop() 删除栈顶元素\n\n先进先出的queue\nfront() 访问队首元素（如果队列为空，此处会出错）\npush(x) 向队列中插入元素 x\npop() 删除队首元素\n\n优先队列\ntop() 访问堆顶元素（此时优先队列不能为空）\n\npush(x) 插入元素，并对底层容器排序\n\npop() 删除堆顶元素（此时优先队列不能为空）\n\n\n以上pop方法，返回已删除元素的值。\n\n优先级的定义：\n对于数字，一般是值大者优先。即默认为：\npriority_queue&lt;int,vector&lt;int&gt;,less&lt;int&gt; &gt; pq;\n第二个参数是内部实现方式；第三个参数  less表示数字大的优先级越大。如果是greater&lt;int&gt;，则为数字小者优先级大。优先级大者，位于top。\n结构体也可以定义优先级，可以通过cmp函数或者重载&lt;运算符实现。这种思路也适用于其他关联式容器。\n\n\npair的常见用法头文件：&lt;utility&gt;\n按照正常的结构体访问（first，second…）。\nstring的常见用法string的实现形式类似于字符型vector，支持push_back、直接赋值（注意使用双引号）和下标访问。只支持cin cout，不支持printf等。\n\n可以通过加减运算符实现字符串拼接和删减、比较运算符进行字典序比较。\n\nsubstr(pos,len)方法截取子串。时间复杂度是O（len）。\n\nfind(x,pos)指定了开始寻找的位置为下标pos\n\n上面的共有函数（erase find等）也是支持的。复杂度都是O(n)\nstring s1 &#x3D; &quot;Hello&quot;;\nstring s2 &#x3D; &quot;world&quot;;\ns1.insert(3,s2);&#x2F;&#x2F;Helworldlo\n\nSTL算法在《特性》篇也介绍有一些用法。\n\nfind_end：逆序查找。find_end(v.begin(), v.end(), value)。\nnth_element：按指定范围进行分类，即找出序列中第 n 大的元素，使其左边均为小于它的数，右边均为大于它的数。nth_element(v.begin(), v.begin() + mid, v.end(), cmp) 或 nth_element(a + begin, a + begin + mid, a + end, cmp)\nnext_permutation：将当前排列更改为 全排列中的下一个排列。如果当前排列已经是 全排列中的最后一个排列（元素完全从大到小排列），函数返回 false 并将排列更改为 全排列中的第一个排列（元素完全从小到大排列）；否则，函数返回 true。next_permutation(v.begin(), v.end()) 或 next_permutation(v + begin, v + end)。\n\nbitset通过固定的优化，使得一个字节的八个比特能分别储存 8 位的 0/1。\n头文件：&lt;bitset&gt;\n\nbitset(): 每一位都是 false。\nbitset(int val): 设为 val 的二进制形式。\nbitset(const string&amp; str): 设为 01 串 str。\n\nbitset&lt;4&gt; bitset1;　　&#x2F;&#x2F;无初始化下，默认每一位均为0\nbitset&lt;8&gt; bitset2(16);　&#x2F;&#x2F;保存长度为8的16的二进制表示：[00010000]\nstring s &#x3D; &quot;10010&quot;;\nbitset&lt;8&gt; bitset3(s);　　&#x2F;&#x2F;长度为10，前补0。[00010010]\n\n\noperator []: 访问其特定的一位。\n\noperator ==/!=: 比较两个 bitset 内容是否完全一样。\n\noperator &amp;/&amp;=/|/| =/^/^=/~: 进行按位与&#x2F;或&#x2F;异或&#x2F;取反操作。**bitset 只能与 bitset 进行位运算**，若要和整型进行位运算，要先将整型转换为 bitset。\n\noperator &lt;&gt;/&lt;&lt;=/&gt;&gt;=: 进行二进制左移&#x2F;右移。\n\noperator &lt;&gt;: 流运算符，这意味着你可以通过 cin/cout 进行输入输出。\n\ncount(): 返回 true 的数量。\n\nsize(): 返回 bitset 的大小。\n\ntest(pos): 它和 vector 中的 at() 的作用是一样的，和 [] 运算符的区别就是越界检查。\n\nto_string(): 返回转换成的字符串表达。\n\nto_ulong(): 返回转换成的 unsigned long 表达 (long 在 NT 及 32 位 POSIX 系统下与 int 一样，在 64 位 POSIX 下与 long long 一样）。\n\nto_ullong():C++11，返回转换成的 unsigned long long 表达。\n\nany(): 若存在某一位是 true 则返回 true，否则返回 false。\n\nnone(): 若所有位都是 false 则返回 true，否则返回 false。\n\nall():C++11，若所有位都是 true 则返回 true，否则返回 false。\n\nset(): 将整个 bitset 设置成 true。\nset(pos, val = true): 将某一位设置成 true&#x2F;false。\n\nreset(): 将整个 bitset 设置成 false。\nreset(pos): 将某一位设置成 false。相当于 set(pos, false)。\n\nflip(): 翻转每一位。（01互换，相当于异或一个全是1 的 bitset）\nflip(pos): 翻转某一位。\n\n_Find_first(): 返回 bitset 第一个 true 的下标，若没有 true 则返回 bitset 的大小。\n\n_Find_next(pos): 返回 pos 后面（下标严格大于 pos 的位置）第一个 true 的下标，若 pos 后面没有 true 则返回 bitset 的大小。\n\n\n参考资料：\nOI-wiki\n《算法笔记》\n","slug":"C++STL的使用","date":"2021-08-01T03:42:26.000Z","categories_index":"语言基础","tags_index":"C++,语法","author_index":"Liul"},{"id":"f73a8e23e6f6f669cf99c7dba8fa0722","title":"","content":"笔者要用到多维数组的时候经常忘了多维数组怎么用，在此总结一下：\n【内容产出中】\n1.二维数组的函数调用实例\n&#x2F;&#x2F;声明\nvoid bubbleSort(float (*num)[40],int size);\n&#x2F;&#x2F;调用\nbubbleSort( stu , 40);\n&#x2F;&#x2F;思想：二维数组——数组的数组\n\n2.把二维数组当一维数组进行赋值：\nint *p&#x3D;&amp;a[0][0];&#x2F;&#x2F;获取二维数组首地址\nfor(int i&#x3D;0;i&lt;6;i++)\n&#123;\nscnaf(&quot;%d&quot;,p);\np++;\n&#125;\n\n3.使用 C++ 容器时，若可以使用at等方法获得对应元素，以缓解运算符[]的不稳定性问题。\n如： array（C++11）\n\n\n\n函数\n作用\n\n\n\nat\n访问指定的元素，同时进行越界检查at 若遇 pos &gt;= size() 的情况会抛出 std::out_of_range。\n\n\noperator[]\n访问指定的元素，不 进行越界检查\n\n\n4.多维vector的行列空间预留\nvector&lt;vector&lt;bool&gt; &gt; table(256);&#x2F;&#x2F;256行\ntable.resize(512);&#x2F;&#x2F;512列\n\n","slug":"C中多维数组的处理","date":"2021-09-19T13:17:35.450Z","categories_index":"","tags_index":"","author_index":"Liul"}]