[{"id":"9e122bacf6c8b61a95cac22cf033e3e5","title":"算法模板","content":"回溯法[TOC]\n解决一个回溯问题，实际上就是一个决策树的遍历过程，使用 isValid 函数剪枝。回溯算法模板框架如下：\nvoid backtracking(参数) &#123;\n    if (结束遍历条件) &#123;\n        存放结果;\n        return;\n    &#125;\n\n    for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) &#123;\n        if (!isValid(..)) \tcontinue;//// 排除不合法选择\n        处理节点;\n        backtracking(路径，选择列表); // 深入\n        撤销节点处理；\n    &#125;\n&#125;\n\n对于isValid函数及剪枝策略，回溯法求最值时，可以通过贪心思想找到一个“较优解”，减去差于其的枝。(分支限界法)\n回溯与 DFS 的思想很类似，区别主要在于解空间的表示和处理：\nfor 循环内：\nrecord[son] = 1; // 标记使用/状态\ndfs(deep + 1); // dfs 下一层\nrecord[son] = 0; // 取消标记/状态\n\n在递归之前做出选择，在递归之后撤销刚才的选择。\n解空间的状态表示主要有： 排列树 和 组合树 两种。\n\n口诀：for循环，换子树；递归调用往深溯\n示例：生成全排列\nn-皇后问题的 位运算解法 及 bitset 包bitsetbitset 头文件中，有一种类似数组的结构，它的每一个元素只能是０或１，每个元素仅用１bit空间，名为 bitset 。构造方式：\nbitset&lt;4> bitset1;　　//无初始化下，默认每一位均为0\nbitset&lt;8> bitset2(16);　//保存长度为8的16的二进制表示：[00010000]\nstring s = \"10010\";\nbitset&lt;8> bitset3(s);　　//长度为10，前补0。[00010010]\n\n\n\nbitset 支持一些按位的位运算，且支持to_string类型转换。\n对于一个叫做bit的bitset：bit.size()       返回大小（位数）bit.count()     返回1的个数bit.any()       返回是否有1bit.none()      返回是否没有1bit.set()       全都变成1bit.set(p)      将第p + 1位变成1（bitset是从第0位开始的！）bit.set(p, x)   将第p + 1位变成xbit.reset()     全都变成0bit.reset(p)    将第p + 1位变成0bit.flip()      全都取反bit.flip(p)     将第p + 1位取反bit.to_ulong()  返回它转换为unsigned long的结果，如果超出范围则报错bit.to_ullong() 返回它转换为unsigned long long的结果，如果超出范围则报错\n","slug":"回溯法","date":"2021-09-09T12:13:56.975Z","categories_index":"","tags_index":"","author_index":"Liul"},{"id":"02283cddd2f2c72dd0f98ea650045063","title":"C++ 特性","content":"从C进步到C++——特性[TOC]\n###结构体初始化构造\n定义结构体时，加入以下语句，可以方便地进行初始化。\nstruct student&#123;\n\tint id;\n\tchar gender;\n\t\n\tstudent()&#123;&#125;  &#x2F;&#x2F;系统默认，用于未经初始化定义结构体\n\t\n\tstudent (int _id, char _gender )&#123;\n\t\tid &#x3D; _id;\n\t\tgender &#x3D; _gender;\n\t&#125;&#x2F;&#x2F;用于初始化id和gender。注意：减少参数 可以达到只使用部分元素构造的效果\n&#125;\n\n构造函数可以简化为一行，如：\nPoint (int x=0 , int y = 0):x(x),y(y) &#123;&#125;;\n\n\n\n这是一个二叉树的定义示例：\nstruct TreeNode &#123;\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n    TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;\n&#125;;\n\n\n\nauto声明推断使用STL容器时的迭代器声明等等往往比较复杂，此时使用 auto 可简单很多：\nvector&lt;int&gt; vec;\nauto pvec &#x3D; vec.begin();&#x2F;&#x2F;vector&lt;int&gt;::iterator\n\n\n\n容器类for-range循环对数组或容器执行循环操作可写成：\ndouble prices[5] &#x3D; &#123;1.1 , 2.2 , 3.3 , 4.4 , 5.5&#125;\nfor ( double x : prices)&#123;&#x2F;&#x2F;只读\n\tcout&lt;&lt;x&lt;&lt;endl;\n&#125;\nfor ( double &amp;x : prices)&#123;&#x2F;&#x2F;写需要使用指针\n\tx &#x3D; x &#x2F; 2;\n&#125;\n\n\n\n结合上面的auto 部分循环可以写成：\nfor ( auto x : vec )\n\n\n\nstring类的类型转换函数int i = 43;\nstring s = to_string(i);\ndouble d = stod(s);//43.000000\n//对应的有：stoi , stoll , stof\n\n\n\nrotate/copy/fill函数rotate函数可以“平移”。直接看例子吧：\nvector&lt;int> a&#123;1,2,3,4,5,6,7,8,9&#125;;\nrotate(a.begin() , a.begin()+2 , a.end());\n//a:[3,4,5,6,7,8,9,1,2]\n\n相当于得到：[mid:end] + [begin:mid]\ncopy函数将一个目标（容器、数组）里面的元素复制至另一个目标。\n注：使用前 newvector.resize(7) 这行代码为newvector分配空间，否则程序会崩。\n此外，通过vector&lt;int&gt;  dp ( 7 , 0 )也可以达到初始化dp为[0,0,0,0,0,0,0].\nfill函数可以为数组和vector赋初始值。头文件：&lt;algorithm&gt;\nint v[10];\nfill(v,v+10,-1);&#x2F;&#x2F;相当于 memset(v,-1,sizeof v);\nint s[10][10];\nfill(s[0],s[0]+10*10,-1);\n\n\n\nsort/lower_bound/upper_bound/unique函数sort函数可用于 vector 、 数组 和 deque 的排序。如：\nsort(b,b+n,greater&lt;int>());//将b降序排列\n\n在已排好升序的情况下：\n1.可使用lower_bound函数（startptr，endptr ，num）得到第一个不小于num的值的指针。（二分查找）。如下代码返回下标：\nint a[10];//......\nint b = upper_bound(a , a+10 , 3) - a;\n\n2.可使用unique函数返回最后一个非重复元素的指针，如下代码进行去重。\nvec.erase( unique(vec.begin(),vec.end()) , vec.end() );\n\n拓展排序：partial_sort 方法\n前缀和 partiai_sort\n数组生成- shuffle/iota随机打乱数组：\nsrand(time(NULL));\nrandom_shuffle(a+1,a+n+1);\n\nrandom_shuffle 自 C++14 起被弃用，C++17 起被移除。可以使用 shuffle 函数代替：\nshuffle(v.begin(),v.end(),rand)（最后一个参数传入的是使用的随机数生成器，一般情况下传入 rand 即可）。\n递增数组：与 golang 可对比：\niota(arr,arr+n,0);//[0,1,2,3,4,...];\n\n\n\n参考资料：\n《C++ Primer》 目录\n《C++ Primer Plus》  18.1\n《算法竞赛入门经典习题解答》第一章\n","slug":"从C进步到C++——特性","date":"2021-09-06T11:11:52.010Z","categories_index":"语言基础","tags_index":"C++,语法","author_index":"Liul"},{"id":"705805ce17024f8fb64b911637d83992","title":"C++ STL使用手册","content":"#C++ STL的使用手册\n[toc]\n\n共有函数=：有赋值运算符以及复制构造函数。\nbegin()：返回指向开头元素的迭代器。\nend()：返回指向末尾的下一个元素的迭代器。end() 不指向某个元素，它是末尾元素的后继。\nsize()：返回容器内的元素个数。\nmax_size()：返回容器 理论上 能存储的最大元素个数。依容器类型和所存储变量的类型而变。\nempty()：返回容器是否为空的一个 bool 值，即 begin() == end()，true 为空，false 为非空。\nswap()：交换两个容器。\nclear()：清空容器。\n==/!=/&lt;/&gt;/&lt;=/&gt;=：按 字典序 比较两个容器的大小。（比较元素大小时 map 的每个元素相当于 set&lt;pair&lt;key, value&gt; &gt;，pair 按 first 到 second 的顺序比较。无序容器不支持 &lt;/&gt;/&lt;=/&gt;=\n序列式容器####vector\n元素访问\n\nat()\nv.at(pos) 返回容器中下标为 pos 的引用。如果数组越界抛出 std::out_of_range 类型的异常。\n\noperator[]\nv[pos] 返回容器中下标为 pos 的引用。不执行越界检查。\n\nfront()\nv.front() 返回首元素的引用。\n\nback()\nv.back() 返回末尾元素的引用。\n\n\n迭代器\n\nbegin()/cbegin()\n返回指向首元素的迭代器，其中 *begin = front。\n\nend()/cend()\n返回指向数组尾端占位符的迭代器，注意是没有元素的。\n\n\n 可以认为，v[i]与*(v.begin()+i)等价。但，除vector string外，其他STL容器不支持后者的形式。\n\nsize() 返回容器长度（元素数量），即 std::distance(v.begin(), v.end())。\n\ninsert() 支持在某个迭代器位置插入元素、可以插入多个。复杂度与 pos 距离末尾长度成线性而非常数\n\nerase() 删除某个迭代器或者区间的元素，返回最后被删除的迭代器。复杂度与 insert 一致。\n\npush_back(x) 在末尾插入一个元素x，均摊复杂度：常数，最坏为线性复杂度。\n\npop_back() 删除末尾元素，常数复杂度。\n\n\ndeque能够提供线性复杂度的插入和删除，以及常数复杂度的随机访问。操作大同vector。\n\npush_front() 在头部插入一个元素。\n\npop_front() 删除头部元素。\n\npush_back() 在末尾插入一个元素。\n\npop_back() 删除末尾元素。\n\n\nlist与deque大致相同，但是由于 list 的实现是链表，因此不提供随机访问的接口。若需要访问中间元素，则需要使用迭代器。\n\nfront() 返回首元素的引用。\n\nback() 返回末尾元素的引用。\n\n\narray(C++11)\n\n\n成员函数\n作用\n示例\n\n\n\noperator=\narray2 的每个元素重写 array1 对应元素\n\n\n\nmax_size\n返回可容纳的最大元素数\n\n\n\nfill\n以指定值填充容器\narr.fill(1);\n\n\nswap\n交换，交换array的复杂度为：O(size)\n\n\n\n\n\n\n非成员函数\n作用\n\n\n\noperator==\n按照字典序比较 array 中的值\n\n\nstd::get\n访问 array 的一个元素\n\n\n关联式容器统一共有函数\nfind(x): 若容器内存在键为 x 的元素，会返回该元素的迭代器；否则返回 end()。\nerase(pos) 删除迭代器为 pos 的元素，可结合find函数使用。\nerase(first,last) 删除迭代器在 [first,last)范围内的所有元素。\ncount(x): 返回容器内键为 x 的元素数量。\nlower_bound(x): 返回指向首个不小于 给定键的元素的迭代器。\nupper_bound(x): 返回指向首个**大于 **给定键的元素的迭代器。若容器内所有元素均小于或等于给定键，返回 end()。\nsize(): 返回容器内元素个数。\n\nsetset 内部采用红黑树实现。平衡二叉树的特性使得 set 非常适合处理需要同时兼顾查找、插入与删除的情况。\n\ninsert(x) 将元素 x 插入到 set 中。自动排序和去重。\nerase(x) 删除值为 x 的 所有 元素，返回删除元素的个数。\nerase(first,last) 删除迭代器在 [first,last)范围内的所有元素。\n\n####map\nmap 重载了 operator[]，可以用任意定义了 operator &lt; 的类型作为下标（在 map 中叫做 key，也就是索引）。\n\n可以直接通过下标访问来进行查询或插入操作。例： mp[&quot;Alan&quot;]=100。利用下标访问 时，如果 map 中不存在相应键的元素，会自动在 map 中插入一个新元素，并将其值设置为默认值（对于整数，值为零；对于有默认构造函数的类型，会调用默认构造函数进行初始化）\n通过向 map 中插入一个类型为 pair&lt;Key, T&gt; 的值可以达到插入元素的目的，例如 mp.insert(pair&lt;string,int&gt;(&quot;Alan&quot;,100));\nerase(key) 函数会删除键为 key 的 所有 元素。返回值为删除元素的数量。\n\n哈希适配容器四种基于哈希实现的无序关联式容器：unordered_set，unordered_multiset，unordered_map，unordered_multimap。\n其操作与关联式容器类似。\n容器适配器为什么称为容器适配器呢，是因为其内部的实现是基于vector  deque  等等，其原理可以参考《STL源码剖析》。\n后进先出的stack仅支持查询或删除最后一个加入的元素（栈顶元素），不支持随机访问。\n\ntop() 访问栈顶元素（如果栈为空，此处会出错）\npush(x) 向栈中插入元素 x\npop() 删除栈顶元素\n\n先进先出的queue\nfront() 访问队首元素（如果队列为空，此处会出错）\npush(x) 向队列中插入元素 x\npop() 删除队首元素\n\n优先队列\ntop() 访问堆顶元素（此时优先队列不能为空）\n\npush(x) 插入元素，并对底层容器排序\n\npop() 删除堆顶元素（此时优先队列不能为空）\n\n优先级的定义：\n对于数字，一般是值大者优先。即默认为：\npriority_queue&lt;int,vector&lt;int&gt;,less&lt;int&gt; &gt; pq;\n第二个参数是内部实现方式；第三个参数  less表示数字大的优先级越大。如果是greater&lt;int&gt;，则为数字小者优先级大。优先级大者，位于top。\n结构体也可以定义优先级，可以通过cmp函数或者重载&lt;运算符实现。这种思路也适用于其他关联式容器。\n\n\npair的常见用法头文件：&lt;utility&gt;\n按照正常的结构体访问（first，second…）。\nstring的常见用法string支持直接赋值（注意使用双引号）和下标访问。只支持cin cout，不支持printf等。\n\n可以通过加减运算符实现字符串拼接和删减、比较运算符进行字典序比较。\n\nsubstr(pos,len)方法可帮助你截取子串。\n\n上面的共有函数（erase find等）也是支持的。\nstring s1 = \"Hello\";\nstring s2 = \"world\";\ns1.insert(3,s2);//Helworldlo\n\nSTL算法在《特性》篇也介绍有一些用法。\n\nfind_end：逆序查找。find_end(v.begin(), v.end(), value)。\nnth_element：按指定范围进行分类，即找出序列中第 n 大的元素，使其左边均为小于它的数，右边均为大于它的数。nth_element(v.begin(), v.begin() + mid, v.end(), cmp) 或 nth_element(a + begin, a + begin + mid, a + end, cmp)\nnext_permutation：将当前排列更改为 全排列中的下一个排列。如果当前排列已经是 全排列中的最后一个排列（元素完全从大到小排列），函数返回 false 并将排列更改为 全排列中的第一个排列（元素完全从小到大排列）；否则，函数返回 true。next_permutation(v.begin(), v.end()) 或 next_permutation(v + begin, v + end)。\n\nbitset通过固定的优化，使得一个字节的八个比特能分别储存 8 位的 0/1。\n头文件：&lt;bitset&gt;\n\nbitset(): 每一位都是 false。\nbitset(int val): 设为 val 的二进制形式。\nbitset(const string&amp; str): 设为 01 串 str。\n\nbitset&lt;4> bitset1;　　//无初始化下，默认每一位均为0\nbitset&lt;8> bitset2(16);　//保存长度为8的16的二进制表示：[00010000]\nstring s = \"10010\";\nbitset&lt;8> bitset3(s);　　//长度为10，前补0。[00010010]\n\n\noperator []: 访问其特定的一位。\n\noperator ==/!=: 比较两个 bitset 内容是否完全一样。\n\noperator &amp;/&amp;=/|/| =/^/^=/~: 进行按位与/或/异或/取反操作。**bitset 只能与 bitset 进行位运算**，若要和整型进行位运算，要先将整型转换为 bitset。\n\noperator &lt;&gt;/&lt;&lt;=/&gt;&gt;=: 进行二进制左移/右移。\n\noperator &lt;&gt;: 流运算符，这意味着你可以通过 cin/cout 进行输入输出。\n\ncount(): 返回 true 的数量。\n\nsize(): 返回 bitset 的大小。\n\ntest(pos): 它和 vector 中的 at() 的作用是一样的，和 [] 运算符的区别就是越界检查。\n\nto_string(): 返回转换成的字符串表达。\n\nto_ulong(): 返回转换成的 unsigned long 表达 (long 在 NT 及 32 位 POSIX 系统下与 int 一样，在 64 位 POSIX 下与 long long 一样）。\n\nto_ullong():C++11，返回转换成的 unsigned long long 表达。\n\nany(): 若存在某一位是 true 则返回 true，否则返回 false。\n\nnone(): 若所有位都是 false 则返回 true，否则返回 false。\n\nall():C++11，若所有位都是 true 则返回 true，否则返回 false。\n\n\nset(): 将整个 bitset 设置成 true。\nset(pos, val = true): 将某一位设置成 true/false。\n\n\n\nreset(): 将整个 bitset 设置成 false。\nreset(pos): 将某一位设置成 false。相当于 set(pos, false)。\n\n\n\nflip(): 翻转每一位。（01互换，相当于异或一个全是1 的 bitset）\nflip(pos): 翻转某一位。\n\n\n_Find_first(): 返回 bitset 第一个 true 的下标，若没有 true 则返回 bitset 的大小。\n\n_Find_next(pos): 返回 pos 后面（下标严格大于 pos 的位置）第一个 true 的下标，若 pos 后面没有 true 则返回 bitset 的大小。\n\n\n参考资料：\nOI-wiki\n《算法笔记》\n","slug":"C++STL的使用","date":"2021-08-06T15:07:15.151Z","categories_index":"语言基础","tags_index":"C++,语法","author_index":"Liul"},{"id":"138e79928c1a716384cb2dd1093bf72b","title":"动态规划的优化","content":"动态规划的优化策略单调队列/单调栈优化单调队列eg.[Poj2823 - 滑动窗口]给予一个长度为n的数组，输出每k个连续元素中的最大值和最小值。\n解：使用STL容器deque，维护一个单调的数列。以求最小值为例，操作包括：\n序列例：1 3 -1 -3 5 3 6 7。\n维护递增的队列，操作如下：\n\n\n\n操作\n队列状态\n\n\n\n1 入队\n&#123;1&#125;\n\n\n3 比 1 大，3 入队\n&#123;1 3&#125;\n\n\n-1 比队列中所有元素小，所以队列被清空， -1 入队\n&#123;-1&#125;\n\n\n-3 比队列中所有元素小，所以队列被清空， -3 入队\n&#123;-3&#125;\n\n\n5 比 -3 大，直接入队\n&#123;-3 5&#125;\n\n\n3 比 5 小，5 出队，3 入队\n&#123;-3 3&#125;\n\n\n-3 已经在窗体外(越界)，所以 -3 出队；6 比 3 大，6 入队\n&#123;3 6&#125;\n\n\n7 比 6 大，7 入队\n&#123;3 6 7&#125;\n\n\n即包括：\n1.当满足“若待入列数比先进列的数还要小”，可将其前面的数尽数 “弹出”，再将该数 push 进队尾。因此，前面的数先出列，不可能是最大值。\n2.需要 site 数组记录第 i 个队中的数在原数组中的位置，以弹出越界的队头。\n3.输出时只需输出队头即可。\nfor (int i &#x3D; 0; i &lt; m; i++) &#123;\n    if (i &gt;&#x3D; n - 1) &#123;\n        while (!que.empty() &amp;&amp; que.front().second &lt;&#x3D; i - n) &#123;\n            que.pop_front();\n        &#125;\n    &#125;\n    while (!que.empty() &amp;&amp; a[i] &lt; que.back().first) &#123;\n        que.pop_back();\n    &#125;\n    que.push_back(P(a[i], i));\n    if (i &gt;&#x3D; n - 1)\n        cout &lt;&lt; que.front().first &lt;&lt; &quot; &quot;;\n&#125;\n\n####单调栈\n与单调队列相比，其只在一端进行进出。单调队列主要处理的是一个区间内的最大/小值，而单调栈处理的是寻找以某个值为最小/大值的最大区间。参考lucky52529的博客\nfor (遍历)\n&#123;\n\tif (栈空 || 栈顶元素大于等于当前比较元素)\n\t\t入栈;\n\telse&#123;\n\t\twhile (栈不为空 &amp;&amp; 栈顶元素小于当前元素)&#123;\n\t\t\t栈顶元素出栈;\n\t\t\t更新结果;\n\t\t&#125;\n\t\t当前数据入栈;\n\t&#125;\n&#125;\n\n\n\n其中需要注意的是：\n1.对于某些特殊题目，栈内元素出不完，遗留在栈里面的人还没有考虑，导致答案错误，这时候我们要添加结束标识符强制清空栈。比如：\nvec.push_back(INF);&#x2F;&#x2F;对于单调递增栈（栈顶最小），补充结束标识符，使最后清空栈\n\n2.我们进行栈的处理时，是在出栈操作时进行的。\n模板题练习：[洛谷P5788]\n\n\n\n\n\n\n\n\n","slug":"动态规划优化","date":"2021-08-06T14:40:33.683Z","categories_index":"算法进阶","tags_index":"dp","author_index":"Liul"},{"id":"b94fc74a26961727683d8eed12a779bd","title":"动态规划初步","content":"动态规划初步[toc]\n基本思路动态规划实际是“聪明地枚举”，会遍历所有可能的情况。对其中的“剪枝”（不丢失最优解）属于贪心的范畴，可能提高了“溯源”的难度。\n首先注意：动态规划不是说一上来就写状态转移方程（直接做“备忘录”），而是逐步分析，如下：\n分析最优子结构 -&gt; 递推公式 -&gt; 自底向上求解（初始化、状态转移）\n分析技巧： 递归树、状态转移图\n调试技巧：打印 dp 数组\n如果需要“溯源”，可以开一个新数组标记。\n由于需要状态转移，一般数组下标从1开始，对应的dp数组也开有“安全空间”。\n背包 dp####背包问题的基本状态转移方程\nf[j] 表示处理到当前物品 i 时背包容量为 j 的最大价值，得出以下方程：\n\n0-1背包问题注意：关于 j 的循环是逆向的。为了保证物品i只被放入一次！从后往前循环，每次取得状态不会和之前取得状态重合（也就是要求子问题之间互相独立），这样每种物品就只取一次了。\nfor (int i &#x3D; 0; i &lt; n; i++) &#123;\n        for (int j &#x3D; m; j &gt;&#x3D; w[i]; j--) &#123;\n            dp[j] &#x3D; max(dp[j], dp[j - w[i]] + v[i]);\n        &#125;\n    &#125;\n\n0-1背包问题打印方案对于滚动数组方法，由于少存储了很多数据，所以很难溯源。\n我们先来看二维情况下，背包问题的循环遍历顺序：\n1.当然，传统地（i++,j++）是可行的。并且可以边读边计算。\n2.先遍历容量，再遍历物品，也是可以的！虽然两个for循环遍历的次序不同，但是dp[i][j]所需要的状态来自左上角，不影响dp[i][j]的下标和状态转移。\n3.能否逆序遍历物品？需要经过小小地修改。此时，用dp[i,j]表示 把第 i, i＋1, i＋2,…, n 个物品装到容量为j的背包中的最大总重量。也就是说，“对称”了一下：\n由于下标的意义变化，其状态转移方程也要发生改变：\nfor(i = n; i >= 1; i--)\nfor(j = 0; j &lt;= C; j++) \nif(j >= V[i]) \n\td[i][j]=max(d[i+1][j],d[i＋1][j－V[i]]＋W[i]);//！\nelse  \n    d[i][j]= d[i+1][j]；\n\n当然，最后我们的输出的结果也就为最终的 dp[1][C]了。\n我们可以总结一下：循环的遍历顺序和状态转移的方向最好是对应的！这和我们提到过的子问题之间互相独立也是一致的。\n4.能否逆序遍历容量？类似于3的思路，但比较难理解，略。\n对于打印方案，可以按照（i++，j++）的方案结合标志数组记录回溯，如果有字典序最小的要求，最终需要reverse；另一种想法是上面的第3点，不需要reverse。以下是示例代码：\nint dp[MAX_N][MAX_N];\nint dp_d[MAX_N][MAX_N];\nint N, V;//n - 物品数，v - 容量（体积） w - 价值\nvector&lt;int> w(1, 0);\nvector&lt;int> v(1, 0);\n\nint main() &#123;\n    //INPUT\n    memset(dp, 0, sizeof dp);\n    memset(dp_d, 0, sizeof dp_d);\n\n\t//DP\n    for (int i = N; i > 0; i--) &#123;\n        for (int j = 0; j &lt;= V; j++) &#123;\n            int noti = dp[i + 1][j];\n            int geti = j >= v[i] ? dp[i + 1][j - v[i]] + w[i] : 0;\n            //for (int j = v[i]; j &lt;= V; j++)不可！why？遍历不完全！（dp本质）\n            if (noti > geti) &#123;//不能用>= 不然多解时会出错\n                dp[i][j] = noti;\n                dp_d[i][j] = 1;\n            &#125; else &#123;\n                dp[i][j] = geti;\n                dp_d[i][j] = 2;\n            &#125;\n        &#125;\n    &#125;\n    //DP_D\n    vector&lt;int> ans;\n    int i = 1 ,  j = V;\n    while (i &lt;= N &amp;&amp; j > 0) &#123;\n        switch (dp_d[i][j]) &#123;\n            case 1:\n                i++;\n                break;\n            case 2:\n                if (j >= v[i])//一个补丁，bug以后补坑\n                    ans.push_back(i);\n                j -= v[i];\n                i++;\n                break;\n        &#125;\n    &#125;\n    for (auto i : ans) &#123;\n        cout &lt;&lt; i &lt;&lt; \" \";\n    &#125;\n&#125;\n\n\n\n\n完全背包问题注意：关于 j 的循环是正向的。\nfor (int i &#x3D; 0; i &lt; m; i++) &#123;\n        for (int j &#x3D; t[i]; j &lt;&#x3D; T; j++) &#123;\n            dp[j] &#x3D; max(dp[j], dp[j - t[i]] + v[i]);\n        &#125;\n    &#125;\n\nTips：解题时，注意数据范围，选择合适的数据结构（eg.long long，_int128）。\n完全背包和 01 背包的区别就在于对容量限制枚举的顺序不同\n原因：0-1背包问题的状态转移利用的是“上一个状态”，完全背包利用的是“当前状态”。\n","slug":"动态规划初步","date":"2021-08-06T09:30:57.763Z","categories_index":"算法基础","tags_index":"dp","author_index":"Liul"},{"id":"13a5a999b8e73070fb636b69008b9fcc","title":"How to post?","content":"hexo clean\nhexo generate\nhexo deploy -g\nWelcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new \"My New Post\"\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n","slug":"hello-world","date":"2021-08-05T07:19:16.005Z","categories_index":"","tags_index":"","author_index":"Liul"}]