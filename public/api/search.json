[{"id":"f73a8e23e6f6f669cf99c7dba8fa0722","title":"","content":"","slug":"函数式编程导论","date":"2021-11-26T01:27:06.727Z","categories_index":"","tags_index":"","author_index":"Liul"},{"id":"f73a8e23e6f6f669cf99c7dba8fa0722","title":"","content":"[toc]\n实际考试中的数据结构题目会比平时代码常用的东西多一点。在此提纲掣领地做一复习。\n非常规队列顺序的环形实现顺序队列在数据不断地进队出队过程中，在顺序表中的位置不断后移。\n可以使用巧妙的方法将顺序表打造成一个环状表，如图 ：\n\n在真正的实现时，没必要真创建这样一种结构，可以通过增加取模、判断（到达队尾返回开头）的方式实现。\n循环队列队头指针front指向队头元素的前一位置，而队尾指针rear指向队尾元素。\n为解决如何判断队列的满与空问题，牺牲一个存储单元。\n栈浮动技术两个栈共享一组地址连续的存储单元。\n略。\n广义表稀疏矩阵的存储三元组存储及快速转置\n关键步骤：以 j 为序列，重新排列三元组表中存储各三元组的先后顺序。\n\n在普通算法的基础上增设两个数组（ array 和 copt）：\n\n\narray 数组负责记录原矩阵每一列非 0 元素的个数。例子对应的 array 数组：\n\n\ncopt 数组用于计算稀疏矩阵中每列第一个非 0 元素在新三元组表中存放的位置，示例对应的 copt 数组如图 ：\n\n\n\ncpot[1]&#x3D;1\ncpot[col]&#x3D;cpot[col-1] +array[col-1]\t(col &gt; 1)&#x2F;&#x2F;意思是，后一列首个非 0 元素存放的位置等于前一列首个非 0 元素的存放位置,加上该列非 0 元素的个数。由此可以看出，copt 数组才是最终想要的，而 array 数组的设立只是为了帮助我们得到 copt 数组。\n\n\n\n行逻辑链接顺序表当使用行逻辑链接的顺序表对其进行压缩存储时，需要做以下两个工作：\n1.将矩阵中的非 0 元素采用三元组的形式存储到一维数组 data 中，如图 ：\n\n2.使用数组 rpos 记录矩阵中每行第一个非 0 元素在一维数组中的存储位置。如图:\n\n此时，如果想从行逻辑链接的顺序表中提取元素，则可以借助 rpos 数组提高遍历数组的效率。\n例如，提取元素 2 的过程如下：\n由 rpos 数组可知，第一行首个非 0 元素位于data[1]，因此在遍历此行时，可以直接从第 data[1] 的位置开始，一直遍历到下一行首个非 0 元素所在的位置（data[3]）之前\n十字链表为克服三元组表在矩阵的非零元素位置或个数经常变动时的使用不便，矩阵中的各行各列都各用一链表存储，与此同时，所有行链表的表头存储到一个数组（rhead），所有列链表的表头存储到另一个数组（chead）中。各个链表中节点的结构如图:\n\n\n树线索化\n\n\n\n\n\n\n\n\n二叉链表对于无子树侧的指针域，能否利用这些空闲区存放有用的信息或线索？——可以用它来存放当前结点的直接前驱和后继等线索，以加快查找速度。按照某种方式对二叉树进行遍历，可以把二叉树中所有结点排序为一个线性序列，参考之，可以把一棵二叉树转变成了一个“双向链表“。\n在该序列中，除第一个结点外每个结点有且仅有一个直接前驱结点；除最后一个结点外每一个结点有且仅有一个直接后继结点，由此线索化。\nLTag=0, lchild域指向左孩子；LTag=1, lchild域指向其前驱RTag=0, rchild域指向右孩子；RTag=1, rchild域指向其后继 \n在线索二叉树的基础上，额外添加一个结点。此结点的作用类似于链表中的头指针，数据域不起作用，只利用两个指针域：左指针域指向二叉树的树根，确保可以正方向对二叉树进行遍历；同时右指针指向线索二叉树形成的线性序列中的最后一个结点。同时，该节点也可避免”悬空”的情形。\n补充结论深入理解二叉树遍历非递归中序遍历：\n\n入栈顺序：先序遍历；\n出栈顺序：中序遍历\n\n二叉树和森林的互化树和二叉树回忆我们从树抽象到二叉树的思路：\n将树用“长子 - 兄弟“ 表示法时，转化成对应二叉树的方式：\n\n从根开始，左子树连接“长子”；\n从根开始，右子树连接“兄弟”；\n\n由此便知二者互化的原理；\n二叉树和森林将森林中的每一棵树均用二叉树的方式抽象表述后，从最后一棵二叉树开始，每棵二叉树作为前一棵二叉树的根结点的右子树，得到森林对应的二叉树。\n所以，将二叉树根沿着右子树链方向的所有边去掉，得到若干棵孤立的二叉树，对应森林中的各棵树对应的二叉树集合。\n\n参考：\nhttps://www.jianshu.com/p/d7d5545012e2\n查找与排序分块查找n元素分块查找，记b为索引表长度，s为块中记录个数，则：\n当s取$\\sqrt{n}$时，$ASL_{bs}$取最小值$\\sqrt{n}+1$\n仅限考试用的结论\n树的高度是从1开始算的，也就是说，空树的高度是0。\n试卷中除非自己定义，请默认下标从“1”开始。\n并查集：与主流一致，根节点的值为-1.\n\n","slug":"数据结构笔记——考试中的非主流玩法","date":"2021-11-23T09:05:09.123Z","categories_index":"","tags_index":"","author_index":"Liul"},{"id":"02283cddd2f2c72dd0f98ea650045063","title":"C++ 特性","content":"从C进步到C++——特性[TOC]\n结构体初始化构造定义结构体时，加入以下语句，可以方便地进行初始化。\nstruct student&#123;\n\tint id;\n\tchar gender;\n\t\n\tstudent()&#123;&#125;  &#x2F;&#x2F;系统默认，用于未经初始化定义结构体\n\t\n\tstudent (int _id, char _gender )&#123;\n\t\tid &#x3D; _id;\n\t\tgender &#x3D; _gender;\n\t&#125;&#x2F;&#x2F;用于初始化id和gender。注意：减少参数 可以达到只使用部分元素构造的效果\n&#125;\n\n构造函数可以简化为一行，并且可以进行默认赋值，如此调用时可以省略对应参数。如：\nPoint (int x&#x3D;0 , int y &#x3D; 0):x(x),y(y) &#123;&#125;;\n&#x2F;&#x2F;Point();\n\n\n\n这是一个二叉树节点的定义示例：\nstruct TreeNode &#123;\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n    TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;\n&#125;;\n\n\n\nauto声明推断使用STL容器时的迭代器声明等等往往比较复杂，此时使用 auto 可简单很多：\nvector&lt;int&gt; vec;\nauto pvec &#x3D; vec.begin();&#x2F;&#x2F;vector&lt;int&gt;::iterator\n\n\n\n容器类for-range循环对数组或容器执行循环操作可写成：\ndouble prices[5] &#x3D; &#123;1.1 , 2.2 , 3.3 , 4.4 , 5.5&#125;\nfor ( double x : prices)&#123;&#x2F;&#x2F;只读\n\tcout&lt;&lt;x&lt;&lt;endl;\n&#125;\nfor ( double &amp;x : prices)&#123;&#x2F;&#x2F;写需要使用指针\n\tx &#x3D; x &#x2F; 2;\n&#125;\n\n\n\n结合上面的auto 部分循环可以写成：\nfor ( auto x : vec )\n\n\n\nstring类的类型转换函数int i &#x3D; 43;\nstring s &#x3D; to_string(i);\ndouble d &#x3D; stod(s);&#x2F;&#x2F;43.000000\n&#x2F;&#x2F;对应的有：stoi , stoll , stof\n\n注意不要传入空串！\nrotate/copy/fill函数rotate函数可以“平移”。直接看例子吧：\nvector&lt;int&gt; a&#123;1,2,3,4,5,6,7,8,9&#125;;\nrotate(a.begin() , a.begin()+2 , a.end());\n&#x2F;&#x2F;a:[3,4,5,6,7,8,9,1,2]\n\n相当于得到：[mid:end] + [begin:mid)\ncopy函数将一个目标（容器、数组）里面的元素复制至另一个目标。\n注：使用前 newvector.resize(7) 这行代码为newvector分配空间，防止程序崩溃。\n此外，通过vector&lt;int&gt;  dp ( 7 , 0 )也可以达到初始化dp为[0,0,0,0,0,0,0].\nfill函数可以为数组和vector赋初始值。头文件：&lt;algorithm&gt;\nint v[10];\nfill(v,v+10,-1);&#x2F;&#x2F;相当于 memset(v,-1,sizeof v);\nint s[10][10];\nfill(s[0],s[0]+10*10,-1);\n\n\n\nsort/lower_bound/upper_bound/unique函数sort函数可用于 vector 、 数组 和 deque 的排序。如：\nsort(b,b+n,greater&lt;int&gt;());&#x2F;&#x2F;将b降序排列\n\n在已排好升序的情况下：\n1.可使用lower_bound函数（startptr，endptr ，num）得到第一个不小于num的值的指针。（二分查找）。如下代码返回下标：\nint a[10];&#x2F;&#x2F;......\nint b &#x3D; upper_bound(a , a+10 , 3) - a;\n\n2.可使用unique函数返回最后一个非重复元素的指针，如下代码进行去重。\nvec.erase( unique(vec.begin(),vec.end()) , vec.end() );\n\n拓展排序：partial_sort 方法\n局部排序partiai_sort可以提供一定区间的排序获得。原理似乎是堆排序。\nfor(i&#x3D;10;i&gt;&#x3D;1;i--)\tvec.push_back(i);\npartial_sort(vec.begin(),vec.begin()+3,vec.end());\n&#x2F;&#x2F;[1,2,3,10,9,8,7,6,5,4]\n\nrep(i,1,10) a.push_back(i);\npartial_sort(vec.begin(),vec.begin()+3,vec.end(),greater&lt;int&gt;());\n&#x2F;&#x2F;[10,9,8,1,2,3,4,5,6,7]\n\n应用：班上有10个学生，我想知道分数最低的5名是哪些人。如果没有partial_sort，你就需要用sort把所有人排好序，然后再取前5个。现在你只需要对分数最低5名排序。\n一些可能有用的数学函数指对运算\n以下函数：接收x为float    double类型，返回传入类型。\nexp2(x)  - 快速返回2的x次幂。\nlog2(x) - 得到以2为底x的对数。\nlog10(x) - 得到以10为底x的对数。\nlog(x)  - 得到x的自然对数。\nexpm(x) - 返回e的x次幂-1。\nexp(x) - 得到e的x次幂。x支持complex类型。\n取整函数\n以下函数的传入传出同上。\nfloor(x) - 向下取整。\nceil(x) - 向上取整。 \nround(x) - 四舍五入，基本类似于floor(x+0.5)。但是中点情况下向远离0的方向舍入。\ntrunc(x) - 将x向0方向舍入。\n数组生成- iota/shuffle递增数组：与 golang 可对比：\niota(arr,arr+n,0);&#x2F;&#x2F;[0,1,2,3,4,...];\n\n随机打乱数组：\nsrand(time(NULL));\nrandom_shuffle(a+1,a+n+1);\n\nrandom_shuffle 自 C++14 起被弃用，C++17 起被移除。可以使用 shuffle 函数代替：\nshuffle(v.begin(),v.end(),rand)（最后一个参数传入的是使用的随机数生成器，一般情况下传入 rand 即可）。\n使用时需要设置随机数种子，配合iota可以实现类似于“洗牌”的效果。同时可进行随机的多次模拟，为了时间种子的不同，可能需要每次模拟间设置sleep间隔。\n参考资料：\n《C++ Primer》 目录\n《C++ Primer Plus》  18.1\n《算法竞赛入门经典习题解答》第一章\nhttp://www.cppblog.com/mzty/archive/2005/12/15/1770.aspx\n","slug":"从C进步到C++——特性","date":"2021-09-06T11:11:52.010Z","categories_index":"语言基础","tags_index":"C++,语法","author_index":"Liul"},{"id":"f73a8e23e6f6f669cf99c7dba8fa0722","title":"","content":"数学之美摘抄合理利用信息，而非玩弄什么公式和机器学习算法，是做好搜索的关键。\n先帮用户解决 80% 的问题，再慢慢解决剩下的 20% 问题。\n","slug":"数学之美摘抄","date":"2021-10-04T12:09:34.011Z","categories_index":"","tags_index":"","author_index":"Liul"},{"id":"6d71c2df7638169872fb8e397d99973c","title":"谈谈我对艺术的理解","content":"艺术[TOC]\n【内容产出中】\n近来身体良好，灵感迸发，借此良机，抒发笔者对艺术所感，同时借以小憩。\n艺术，听似很有逼格的词语，其实也可以很接地气。艺术，不仅仅是在798艺术中心里，用不同的理论和方法表现出富有冲击力的美感和画面，也可以是用各种形式对生活的记录。\n信息的记录身临其境之时，方是全身心投入环境的好时机。画作，是一种精湛的技术，由点到面，从细节到整体，一步步勾勒出自己的心灵想象；音乐，是一种共情的表达，用乐器和音符构筑开阔或是幽美的想象空间。摄影，是一种宝贵的记忆，每一张照片都是独一无二的，其角度和参数都涵盖摄影者的巧思。\n曾经我以为，在信息高速发展的浪潮下，我想去的地方，其景象能够由照片看见，其声音可以由midi生成，其氛围亦可由文字所构造，如果配以虚拟导游，我可能真的不必费心破财亲临其境，更不用拍摄下、记录下当时的所见所感。\n非也，以上的想法都是在接收信息，而信息的记录及后期处理、亲临其境的感受，那都是心灵的创造，是一种美的艺术。\n当下###个性化\n##信息的处理\n运用python爬取到想要的资料自然是增强了科技处理的信心，想到这里，大一时真的不够自信\n二创和个性变化###启发式处理\n","slug":"谈谈我对艺术的理解","date":"2021-09-27T11:50:43.875Z","categories_index":"","tags_index":"","author_index":"Liul"},{"id":"f4b1f6c62c51b83cc4ba3ecdcd8b9c52","title":"C/C++ 多维数组的处理","content":"笔者要用到多维数组的时候经常忘了多维数组怎么用，在此总结一下：\n【内容产出中】\n1.二维数组的函数调用实例\n&#x2F;&#x2F;声明\nvoid bubbleSort(float (*num)[40],int size);\n&#x2F;&#x2F;调用\nbubbleSort( stu , 40);\n&#x2F;&#x2F;思想：二维数组——数组的数组\n\n2.把二维数组当一维数组进行赋值：\nint *p&#x3D;&amp;a[0][0];&#x2F;&#x2F;获取二维数组首地址\nfor(int i&#x3D;0;i&lt;6;i++)\n&#123;\nscnaf(&quot;%d&quot;,p);\np++;\n&#125;\n\n3.使用 C++ 容器时，若可以使用at等方法获得对应元素，以缓解运算符[]的不稳定性问题。\n如： array（C++11）\n\n\n\n函数\n作用\n\n\n\nat\n访问指定的元素，同时进行越界检查at 若遇 pos &gt;= size() 的情况会抛出 std::out_of_range。\n\n\noperator[]\n访问指定的元素，不 进行越界检查\n\n\n4.多维vector的行列空间预留\nvector&lt;vector&lt;bool&gt; &gt; table(256);&#x2F;&#x2F;256行\ntable.resize(512);&#x2F;&#x2F;512列\n\n","slug":"C中多维数组的处理","date":"2021-09-19T13:17:35.450Z","categories_index":"","tags_index":"","author_index":"Liul"},{"id":"9e122bacf6c8b61a95cac22cf033e3e5","title":"算法模板","content":"回溯法[TOC]\n解决一个回溯问题，实际上就是一个决策树的遍历过程，使用 isValid 函数剪枝。回溯算法模板框架如下：\nvoid backtracking(参数) &#123;\n    if (结束遍历条件) &#123;\n        存放结果;\n        return;\n    &#125;\n\n    for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) &#123;\n        if (!isValid(..)) \tcontinue;&#x2F;&#x2F;&#x2F;&#x2F; 排除不合法选择\n        处理节点;\n        backtracking(路径，选择列表); &#x2F;&#x2F; 深入\n        撤销节点处理；\n    &#125;\n&#125;\n\n对于isValid函数及剪枝策略，回溯法求最值时，可以通过贪心思想找到一个“较优解”，减去差于其的枝。(分支限界法)\n回溯与 DFS 的思想很类似，区别主要在于解空间的表示和处理：\nfor 循环内：\nrecord[son] &#x3D; 1; &#x2F;&#x2F; 标记使用&#x2F;状态\ndfs(deep + 1); &#x2F;&#x2F; dfs 下一层\nrecord[son] &#x3D; 0; &#x2F;&#x2F; 取消标记&#x2F;状态\n\n在递归之前做出选择，在递归之后撤销刚才的选择。\n解空间的状态表示主要有： 排列树 和 组合树 两种。\n\n口诀：for循环，换子树；递归调用往深溯\n示例：生成全排列\nn-皇后问题的 位运算解法 及 bitset 包bitsetbitset 头文件中，有一种类似数组的结构，它的每一个元素只能是０或１，每个元素仅用１bit空间，名为 bitset 。构造方式：\nbitset&lt;4&gt; bitset1;　　&#x2F;&#x2F;无初始化下，默认每一位均为0\nbitset&lt;8&gt; bitset2(16);　&#x2F;&#x2F;保存长度为8的16的二进制表示：[00010000]\nstring s &#x3D; &quot;10010&quot;;\nbitset&lt;8&gt; bitset3(s);　　&#x2F;&#x2F;长度为10，前补0。[00010010]\n\n\n\nbitset 支持一些按位的位运算，且支持to_string类型转换。\n对于一个叫做bit的bitset：bit.size()       返回大小（位数）bit.count()     返回1的个数bit.any()       返回是否有1bit.none()      返回是否没有1bit.set()       全都变成1bit.set(p)      将第p + 1位变成1（bitset是从第0位开始的！）bit.set(p, x)   将第p + 1位变成xbit.reset()     全都变成0bit.reset(p)    将第p + 1位变成0bit.flip()      全都取反bit.flip(p)     将第p + 1位取反bit.to_ulong()  返回它转换为unsigned long的结果，如果超出范围则报错bit.to_ullong() 返回它转换为unsigned long long的结果，如果超出范围则报错\n","slug":"算法模板","date":"2021-09-09T12:13:56.975Z","categories_index":"","tags_index":"","author_index":"Liul"},{"id":"f73a8e23e6f6f669cf99c7dba8fa0722","title":"","content":"title:        C++ STL使用手册tags:        C++,语法categories:    语言基础feature: true\n#C++ STL的使用手册\n[toc]\n\n共有函数=：有赋值运算符以及复制构造函数。\nbegin()：返回指向开头元素的迭代器。\nend()：返回指向末尾的下一个元素的迭代器。end() 不指向某个元素，它是末尾元素的后继。\nsize()：返回容器内的元素个数。\nmax_size()：返回容器 理论上 能存储的最大元素个数。依容器类型和所存储变量的类型而变。\nempty()：返回容器是否为空的一个 bool 值，即 begin() == end()，true 为空，false 为非空。\nswap()：交换两个容器。\nclear()：清空容器。\n==/!=/&lt;/&gt;/&lt;=/&gt;=：按 字典序 比较两个容器的大小。（比较元素大小时 map 的每个元素相当于 set&lt;pair&lt;key, value&gt; &gt;，pair 按 first 到 second 的顺序比较。无序容器不支持 &lt;/&gt;/&lt;=/&gt;=\n序列式容器vector元素访问\n\nat()\nv.at(pos) 返回容器中下标为 pos 的引用。如果数组越界抛出 std::out_of_range 类型的异常。\n\noperator[]\nv[pos] 返回容器中下标为 pos 的引用。不执行越界检查。\n\nfront()\nv.front() 返回首元素的引用。\n\nback()\nv.back() 返回末尾元素的引用。\n\n\n迭代器\n\nbegin()/cbegin()\n返回指向首元素的迭代器，其中 *begin = front。\n\nend()/cend()\n返回指向数组尾端占位符的迭代器，注意是没有元素的。\n\n\n 可以认为，v[i]与*(v.begin()+i)等价。但，除vector string外，其他STL容器不支持后者的形式。\n\nsize() 返回容器长度（元素数量），即 std::distance(v.begin(), v.end())。\n\ninsert() 支持在某个迭代器位置插入元素、可以插入多个。复杂度与 pos 距离末尾长度成线性而非常数\n\nerase() 删除某个迭代器或者区间的元素，返回最后被删除的迭代器。复杂度与 insert 一致。\n\npush_back(x) 在末尾插入一个元素x，均摊复杂度：常数，最坏为线性复杂度。\n\npop_back() 删除末尾元素，常数复杂度。\n\n\ndeque能够提供线性复杂度的插入和删除，以及常数复杂度的随机访问。操作大同vector。\n\npush_front() 在头部插入一个元素。\n\npop_front() 删除头部元素。\n\npush_back() 在末尾插入一个元素。\n\npop_back() 删除末尾元素。\n\n\nlist与deque大致相同，但是由于 list 的实现是链表，因此不提供随机访问的接口。若需要访问中间元素，则需要使用迭代器。\n\nfront() 返回首元素的引用。\n\nback() 返回末尾元素的引用。\n\n\narray(C++11)\n\n\n成员函数\n作用\n示例\n\n\n\noperator=\narray2 的每个元素重写 array1 对应元素\n\n\n\nmax_size\n返回可容纳的最大元素数\n\n\n\nfill\n以指定值填充容器\narr.fill(1);\n\n\nswap\n交换，交换array的复杂度为：O(size)\n\n\n\n\n\n\n非成员函数\n作用\n\n\n\noperator==\n按照字典序比较 array 中的值\n\n\nstd::get\n访问 array 的一个元素\n\n\n关联式容器统一共有函数\nfind(x): 若容器内存在键为 x 的元素，会返回该元素的迭代器；否则返回 end()。\n\n\nerase(pos) 删除迭代器为 pos 的元素，可结合find函数使用。\n\nerase(first,last) 删除迭代器在 [first,last)范围内的所有元素。\n\ncount(x): 返回容器内键为 x 的元素数量。\n\nlower_bound(x): 返回指向首个不小于 给定键的元素的迭代器。\n\nupper_bound(x): 返回指向首个**大于 **给定键的元素的迭代器。若容器内所有元素均小于或等于给定键，返回 end()。\n\nsize(): 返回容器内元素个数。\n\n\nsetset 内部采用红黑树实现。平衡二叉树的特性使得 set 非常适合处理需要同时兼顾查找、插入与删除的情况。\n\ninsert(x) 将元素 x 插入到 set 中。自动排序和去重。\nerase(x) 删除值为 x 的 所有 元素，返回删除元素的个数。\nerase(first,last) 删除迭代器在 [first,last)范围内的所有元素。\n\nmapmap 重载了 operator[]，可以用任意定义了 operator &lt; 的类型作为下标（在 map 中叫做 key，也就是索引）。\n\n可以直接通过下标访问来进行查询或插入操作。例： mp[&quot;Alan&quot;]=100。利用下标访问 时，如果 map 中不存在相应键的元素，会自动在 map 中插入一个新元素，并将其值设置为默认值（对于整数，值为零；对于有默认构造函数的类型，会调用默认构造函数进行初始化）\n通过向 map 中插入一个类型为 pair&lt;Key, T&gt; 的值可以达到插入元素的目的，例如 mp.insert(pair&lt;string,int&gt;(&quot;Alan&quot;,100));\nerase(key) 函数会删除键为 key 的 所有 元素。返回值为删除元素的数量。\n\n哈希适配容器四种基于哈希实现的无序关联式容器：unordered_set，unordered_multiset，unordered_map，unordered_multimap。\n其操作与关联式容器类似。\n容器适配器为什么称为容器适配器呢，是因为其内部的实现是基于vector  deque  等等，其原理可以参考《STL源码剖析》。\n后进先出的stack仅支持查询或删除最后一个加入的元素（栈顶元素），不支持随机访问。\n\ntop() 访问栈顶元素（如果栈为空，此处会出错）\npush(x) 向栈中插入元素 x\npop() 删除栈顶元素\n\n先进先出的queue\nfront() 访问队首元素（如果队列为空，此处会出错）\npush(x) 向队列中插入元素 x\npop() 删除队首元素\n\n优先队列\ntop() 访问堆顶元素（此时优先队列不能为空）\n\npush(x) 插入元素，并对底层容器排序\n\npop() 删除堆顶元素（此时优先队列不能为空）\n\n\n以上pop方法，返回已删除元素的值。\n\n优先级的定义：\n对于数字，一般是值大者优先。即默认为：\npriority_queue&lt;int,vector&lt;int&gt;,less&lt;int&gt; &gt; pq;\n第二个参数是内部实现方式；第三个参数  less表示数字大的优先级越大。如果是greater&lt;int&gt;，则为数字小者优先级大。优先级大者，位于top。\n结构体也可以定义优先级，可以通过cmp函数或者重载&lt;运算符实现。这种思路也适用于其他关联式容器。\n\n\npair的常见用法头文件：&lt;utility&gt;\n按照正常的结构体访问（first，second…）。\nstring的常见用法string的实现形式类似于字符型vector，支持push_back、直接赋值（注意使用双引号）和下标访问。只支持cin cout，不支持printf等。\n\n可以通过加减运算符实现字符串拼接和删减、比较运算符进行字典序比较。\n\nsubstr(pos,len)方法截取子串。时间复杂度是O（len）。\n\nfind(x,pos)指定了开始寻找的位置为下标pos\n\n上面的共有函数（erase find等）也是支持的。复杂度都是O(n)\nstring s1 &#x3D; &quot;Hello&quot;;\nstring s2 &#x3D; &quot;world&quot;;\ns1.insert(3,s2);&#x2F;&#x2F;Helworldlo\n\nSTL算法在《特性》篇也介绍有一些用法。\n\nfind_end：逆序查找。find_end(v.begin(), v.end(), value)。\nnth_element：按指定范围进行分类，即找出序列中第 n 大的元素，使其左边均为小于它的数，右边均为大于它的数。nth_element(v.begin(), v.begin() + mid, v.end(), cmp) 或 nth_element(a + begin, a + begin + mid, a + end, cmp)\nnext_permutation：将当前排列更改为 全排列中的下一个排列。如果当前排列已经是 全排列中的最后一个排列（元素完全从大到小排列），函数返回 false 并将排列更改为 全排列中的第一个排列（元素完全从小到大排列）；否则，函数返回 true。next_permutation(v.begin(), v.end()) 或 next_permutation(v + begin, v + end)。\n\nbitset通过固定的优化，使得一个字节的八个比特能分别储存 8 位的 0/1。\n头文件：&lt;bitset&gt;\n\nbitset(): 每一位都是 false。\nbitset(int val): 设为 val 的二进制形式。\nbitset(const string&amp; str): 设为 01 串 str。\n\nbitset&lt;4&gt; bitset1;　　&#x2F;&#x2F;无初始化下，默认每一位均为0\nbitset&lt;8&gt; bitset2(16);　&#x2F;&#x2F;保存长度为8的16的二进制表示：[00010000]\nstring s &#x3D; &quot;10010&quot;;\nbitset&lt;8&gt; bitset3(s);　　&#x2F;&#x2F;长度为10，前补0。[00010010]\n\n\noperator []: 访问其特定的一位。\n\noperator ==/!=: 比较两个 bitset 内容是否完全一样。\n\noperator &amp;/&amp;=/|/| =/^/^=/~: 进行按位与/或/异或/取反操作。**bitset 只能与 bitset 进行位运算**，若要和整型进行位运算，要先将整型转换为 bitset。\n\noperator &lt;&gt;/&lt;&lt;=/&gt;&gt;=: 进行二进制左移/右移。\n\noperator &lt;&gt;: 流运算符，这意味着你可以通过 cin/cout 进行输入输出。\n\ncount(): 返回 true 的数量。\n\nsize(): 返回 bitset 的大小。\n\ntest(pos): 它和 vector 中的 at() 的作用是一样的，和 [] 运算符的区别就是越界检查。\n\nto_string(): 返回转换成的字符串表达。\n\nto_ulong(): 返回转换成的 unsigned long 表达 (long 在 NT 及 32 位 POSIX 系统下与 int 一样，在 64 位 POSIX 下与 long long 一样）。\n\nto_ullong():C++11，返回转换成的 unsigned long long 表达。\n\nany(): 若存在某一位是 true 则返回 true，否则返回 false。\n\nnone(): 若所有位都是 false 则返回 true，否则返回 false。\n\nall():C++11，若所有位都是 true 则返回 true，否则返回 false。\n\nset(): 将整个 bitset 设置成 true。\nset(pos, val = true): 将某一位设置成 true/false。\n\nreset(): 将整个 bitset 设置成 false。\nreset(pos): 将某一位设置成 false。相当于 set(pos, false)。\n\nflip(): 翻转每一位。（01互换，相当于异或一个全是1 的 bitset）\nflip(pos): 翻转某一位。\n\n_Find_first(): 返回 bitset 第一个 true 的下标，若没有 true 则返回 bitset 的大小。\n\n_Find_next(pos): 返回 pos 后面（下标严格大于 pos 的位置）第一个 true 的下标，若 pos 后面没有 true 则返回 bitset 的大小。\n\n\n参考资料：\nOI-wiki\n《算法笔记》\n","slug":"C++STL的使用","date":"2021-08-06T15:07:15.151Z","categories_index":"","tags_index":"","author_index":"Liul"},{"id":"138e79928c1a716384cb2dd1093bf72b","title":"动态规划的优化","content":"动态规划的优化策略单调队列/单调栈优化单调队列eg.[Poj2823 - 滑动窗口]给予一个长度为n的数组，输出每k个连续元素中的最大值和最小值。\n解：使用STL容器deque，维护一个单调的数列。以求最小值为例，操作包括：\n序列例：1 3 -1 -3 5 3 6 7。\n维护递增的队列，操作如下：\n\n\n\n操作\n队列状态\n\n\n\n1 入队\n&#123;1&#125;\n\n\n3 比 1 大，3 入队\n&#123;1 3&#125;\n\n\n-1 比队列中所有元素小，所以队列被清空， -1 入队\n&#123;-1&#125;\n\n\n-3 比队列中所有元素小，所以队列被清空， -3 入队\n&#123;-3&#125;\n\n\n5 比 -3 大，直接入队\n&#123;-3 5&#125;\n\n\n3 比 5 小，5 出队，3 入队\n&#123;-3 3&#125;\n\n\n-3 已经在窗体外(越界)，所以 -3 出队；6 比 3 大，6 入队\n&#123;3 6&#125;\n\n\n7 比 6 大，7 入队\n&#123;3 6 7&#125;\n\n\n即包括：\n1.当满足“若待入列数比先进列的数还要小”，可将其前面的数尽数 “弹出”，再将该数 push 进队尾。因此，前面的数先出列，不可能是最大值。\n2.需要 site 数组记录第 i 个队中的数在原数组中的位置，以弹出越界的队头。\n3.输出时只需输出队头即可。\nfor (int i &#x3D; 0; i &lt; m; i++) &#123;\n    if (i &gt;&#x3D; n - 1) &#123;\n        while (!que.empty() &amp;&amp; que.front().second &lt;&#x3D; i - n) &#123;\n            que.pop_front();\n        &#125;\n    &#125;\n    while (!que.empty() &amp;&amp; a[i] &lt; que.back().first) &#123;\n        que.pop_back();\n    &#125;\n    que.push_back(P(a[i], i));\n    if (i &gt;&#x3D; n - 1)\n        cout &lt;&lt; que.front().first &lt;&lt; &quot; &quot;;\n&#125;\n\n####单调栈\n与单调队列相比，其只在一端进行进出。单调队列主要处理的是一个区间内的最大/小值，而单调栈处理的是寻找以某个值为最小/大值的最大区间。参考lucky52529的博客\nfor (遍历)\n&#123;\n\tif (栈空 || 栈顶元素大于等于当前比较元素)\n\t\t入栈;\n\telse&#123;\n\t\twhile (栈不为空 &amp;&amp; 栈顶元素小于当前元素)&#123;\n\t\t\t栈顶元素出栈;\n\t\t\t更新结果;\n\t\t&#125;\n\t\t当前数据入栈;\n\t&#125;\n&#125;\n\n\n\n其中需要注意的是：\n1.对于某些特殊题目，栈内元素出不完，遗留在栈里面的人还没有考虑，导致答案错误，这时候我们要添加结束标识符强制清空栈。比如：\nvec.push_back(INF);&#x2F;&#x2F;对于单调递增栈（栈顶最小），补充结束标识符，使最后清空栈\n\n2.我们进行栈的处理时，是在出栈操作时进行的。\n模板题练习：[洛谷P5788]\n\n\n\n\n\n\n\n\n","slug":"动态规划优化","date":"2021-08-06T14:40:33.683Z","categories_index":"算法进阶","tags_index":"dp","author_index":"Liul"},{"id":"b94fc74a26961727683d8eed12a779bd","title":"动态规划初步","content":"动态规划初步[toc]\n基本思路动态规划实际是“聪明地枚举”，会遍历所有可能的情况。对其中的“剪枝”（不丢失最优解）属于贪心的范畴，可能提高了“溯源”的难度。\n首先注意：动态规划不是说一上来就写状态转移方程（直接做“备忘录”），而是逐步分析，如下：\n分析最优子结构 -&gt; 递推公式 -&gt; 自底向上求解（初始化、状态转移）\n分析技巧： 递归树、状态转移图\n调试技巧：打印 dp 数组\n如果需要“溯源”，可以开一个新数组标记。\n由于需要状态转移，一般数组下标从1开始，对应的dp数组也开有“安全空间”。\n背包 dp####背包问题的基本状态转移方程\nf[j] 表示处理到当前物品 i 时背包容量为 j 的最大价值，得出以下方程：\n\n0-1背包问题注意：关于 j 的循环是逆向的。为了保证物品i只被放入一次！从后往前循环，每次取得状态不会和之前取得状态重合（也就是要求子问题之间互相独立），这样每种物品就只取一次了。\nfor (int i &#x3D; 0; i &lt; n; i++) &#123;\n        for (int j &#x3D; m; j &gt;&#x3D; w[i]; j--) &#123;\n            dp[j] &#x3D; max(dp[j], dp[j - w[i]] + v[i]);\n        &#125;\n    &#125;\n\n0-1背包问题打印方案对于滚动数组方法，由于少存储了很多数据，所以很难溯源。\n我们先来看二维情况下，背包问题的循环遍历顺序：\n1.当然，传统地（i++,j++）是可行的。并且可以边读边计算。\n2.先遍历容量，再遍历物品，也是可以的！虽然两个for循环遍历的次序不同，但是dp[i][j]所需要的状态来自左上角，不影响dp[i][j]的下标和状态转移。\n3.能否逆序遍历物品？需要经过小小地修改。此时，用dp[i,j]表示 把第 i, i＋1, i＋2,…, n 个物品装到容量为j的背包中的最大总重量。也就是说，“对称”了一下：\n由于下标的意义变化，其状态转移方程也要发生改变：\nfor(i &#x3D; n; i &gt;&#x3D; 1; i--)\nfor(j &#x3D; 0; j &lt;&#x3D; C; j++) \nif(j &gt;&#x3D; V[i]) \n\td[i][j]&#x3D;max(d[i+1][j],d[i＋1][j－V[i]]＋W[i]);&#x2F;&#x2F;！\nelse  \n    d[i][j]&#x3D; d[i+1][j]；\n\n当然，最后我们的输出的结果也就为最终的 dp[1][C]了。\n我们可以总结一下：循环的遍历顺序和状态转移的方向最好是对应的！这和我们提到过的子问题之间互相独立也是一致的。\n4.能否逆序遍历容量？类似于3的思路，但比较难理解，略。\n对于打印方案，可以按照（i++，j++）的方案结合标志数组记录回溯，如果有字典序最小的要求，最终需要reverse；另一种想法是上面的第3点，不需要reverse。以下是示例代码：\nint dp[MAX_N][MAX_N];\nint dp_d[MAX_N][MAX_N];\nint N, V;&#x2F;&#x2F;n - 物品数，v - 容量（体积） w - 价值\nvector&lt;int&gt; w(1, 0);\nvector&lt;int&gt; v(1, 0);\n\nint main() &#123;\n    &#x2F;&#x2F;INPUT\n    memset(dp, 0, sizeof dp);\n    memset(dp_d, 0, sizeof dp_d);\n\n\t&#x2F;&#x2F;DP\n    for (int i &#x3D; N; i &gt; 0; i--) &#123;\n        for (int j &#x3D; 0; j &lt;&#x3D; V; j++) &#123;\n            int noti &#x3D; dp[i + 1][j];\n            int geti &#x3D; j &gt;&#x3D; v[i] ? dp[i + 1][j - v[i]] + w[i] : 0;\n            &#x2F;&#x2F;for (int j &#x3D; v[i]; j &lt;&#x3D; V; j++)不可！why？遍历不完全！（dp本质）\n            if (noti &gt; geti) &#123;&#x2F;&#x2F;不能用&gt;&#x3D; 不然多解时会出错\n                dp[i][j] &#x3D; noti;\n                dp_d[i][j] &#x3D; 1;\n            &#125; else &#123;\n                dp[i][j] &#x3D; geti;\n                dp_d[i][j] &#x3D; 2;\n            &#125;\n        &#125;\n    &#125;\n    &#x2F;&#x2F;DP_D\n    vector&lt;int&gt; ans;\n    int i &#x3D; 1 ,  j &#x3D; V;\n    while (i &lt;&#x3D; N &amp;&amp; j &gt; 0) &#123;\n        switch (dp_d[i][j]) &#123;\n            case 1:\n                i++;\n                break;\n            case 2:\n                if (j &gt;&#x3D; v[i])&#x2F;&#x2F;一个补丁，bug以后补坑\n                    ans.push_back(i);\n                j -&#x3D; v[i];\n                i++;\n                break;\n        &#125;\n    &#125;\n    for (auto i : ans) &#123;\n        cout &lt;&lt; i &lt;&lt; &quot; &quot;;\n    &#125;\n&#125;\n\n\n\n\n完全背包问题注意：关于 j 的循环是正向的。\nfor (int i &#x3D; 0; i &lt; m; i++) &#123;\n        for (int j &#x3D; t[i]; j &lt;&#x3D; T; j++) &#123;\n            dp[j] &#x3D; max(dp[j], dp[j - t[i]] + v[i]);\n        &#125;\n    &#125;\n\nTips：解题时，注意数据范围，选择合适的数据结构（eg.long long，_int128）。\n完全背包和 01 背包的区别就在于对容量限制枚举的顺序不同\n原因：0-1背包问题的状态转移利用的是“上一个状态”，完全背包利用的是“当前状态”。\n","slug":"动态规划初步","date":"2021-08-06T09:30:57.763Z","categories_index":"算法基础","tags_index":"dp","author_index":"Liul"}]