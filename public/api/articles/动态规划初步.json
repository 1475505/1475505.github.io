{"title":"动态规划初步","uid":"b94fc74a26961727683d8eed12a779bd","slug":"动态规划初步","date":"2021-08-06T09:30:57.763Z","updated":"2021-11-24T07:31:52.238Z","comments":true,"path":"api/articles/动态规划初步.json","keywords":null,"cover":[],"content":"<h1 id=\"动态规划初步\"><a href=\"#动态规划初步\" class=\"headerlink\" title=\"动态规划初步\"></a>动态规划初步</h1><p>[toc]</p>\n<h2 id=\"基本思路\"><a href=\"#基本思路\" class=\"headerlink\" title=\"基本思路\"></a>基本思路</h2><p>动态规划实际是“聪明地枚举”，会遍历所有可能的情况。对其中的“剪枝”（不丢失最优解）属于贪心的范畴，可能提高了“溯源”的难度。</p>\n<p>首先注意：动态规划不是说一上来就写状态转移方程（直接做“备忘录”），而是逐步分析，如下：</p>\n<p>分析最优子结构 -&gt; 递推公式 -&gt; 自底向上求解（初始化、状态转移）</p>\n<p>分析技巧： 递归树、状态转移图</p>\n<p>调试技巧：打印 dp 数组</p>\n<p>如果需要“溯源”，可以开一个新数组标记。</p>\n<p>由于需要状态转移，一般数组下标从1开始，对应的<code>dp</code>数组也开有“安全空间”。</p>\n<h3 id=\"背包-dp\"><a href=\"#背包-dp\" class=\"headerlink\" title=\"背包 dp\"></a>背包 dp</h3><p>####背包问题的基本状态转移方程</p>\n<p>f[j] 表示处理到当前物品 i 时背包容量为 j 的最大价值，得出以下方程：</p>\n<p><img src=\"C:\\Users\\ll\\blog\\source_posts\\贴图\\20210806dp1.png\" alt=\"image-20210806174605728\"></p>\n<h4 id=\"0-1背包问题\"><a href=\"#0-1背包问题\" class=\"headerlink\" title=\"0-1背包问题\"></a>0-1背包问题</h4><p>注意：关于 j 的循环是逆向的。<strong>为了保证物品i只被放入一次！</strong>从后往前循环，每次取得状态<strong>不会和之前取得状态重合</strong>（也就是要求子问题之间互相独立），这样每种物品就只取一次了。</p>\n<pre class=\"line-numbers language-C++\" data-language=\"C++\"><code class=\"language-C++\">for (int i &#x3D; 0; i &lt; n; i++) &#123;\n        for (int j &#x3D; m; j &gt;&#x3D; w[i]; j--) &#123;\n            dp[j] &#x3D; max(dp[j], dp[j - w[i]] + v[i]);\n        &#125;\n    &#125;</code></pre>\n\n<h4 id=\"0-1背包问题打印方案\"><a href=\"#0-1背包问题打印方案\" class=\"headerlink\" title=\"0-1背包问题打印方案\"></a>0-1背包问题打印方案</h4><p>对于滚动数组方法，由于少存储了很多数据，所以很难溯源。</p>\n<p>我们先来看二维情况下，背包问题的循环遍历顺序：</p>\n<p>1.当然，传统地（i++,j++）是可行的。并且可以边读边计算。</p>\n<p>2.<strong>先遍历容量，再遍历物品，也是可以的！</strong>虽然两个for循环遍历的次序不同，但是<code>dp[i][j]</code>所需要的状态来自左上角，不影响<code>dp[i][j]</code>的下标和状态转移。</p>\n<p>3.能否<strong>逆序遍历物品</strong>？需要经过小小地修改。此时，用dp[i,j]表示 把第 i, i＋1, i＋2,…, n 个物品装到容量为j的背包中的最大总重量。也就是说，“对称”了一下：</p>\n<p>由于下标的意义变化，其状态转移方程也要发生改变：</p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">for(i &#x3D; n; i &gt;&#x3D; 1; i--)\nfor(j &#x3D; 0; j &lt;&#x3D; C; j++) \nif(j &gt;&#x3D; V[i]) \n\td[i][j]&#x3D;max(d[i+1][j],d[i＋1][j－V[i]]＋W[i]);&#x2F;&#x2F;！\nelse  \n    d[i][j]&#x3D; d[i+1][j]；</code></pre>\n\n<p>当然，最后我们的输出的结果也就为最终的 <code>dp[1][C]</code>了。</p>\n<p>我们可以总结一下：循环的遍历顺序和状态转移的方向最好是对应的！这和我们提到过的子问题之间互相独立也是一致的。</p>\n<p>4.能否<strong>逆序遍历容量</strong>？类似于3的思路，但比较难理解，略。</p>\n<p>对于打印方案，可以按照（i++，j++）的方案结合标志数组记录回溯，如果有<strong>字典序最小</strong>的要求，最终需要<code>reverse</code>；另一种想法是上面的第3点，不需要<code>reverse</code>。以下是示例代码：</p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">int dp[MAX_N][MAX_N];\nint dp_d[MAX_N][MAX_N];\nint N, V;&#x2F;&#x2F;n - 物品数，v - 容量（体积） w - 价值\nvector&lt;int&gt; w(1, 0);\nvector&lt;int&gt; v(1, 0);\n\nint main() &#123;\n    &#x2F;&#x2F;INPUT\n    memset(dp, 0, sizeof dp);\n    memset(dp_d, 0, sizeof dp_d);\n\n\t&#x2F;&#x2F;DP\n    for (int i &#x3D; N; i &gt; 0; i--) &#123;\n        for (int j &#x3D; 0; j &lt;&#x3D; V; j++) &#123;\n            int noti &#x3D; dp[i + 1][j];\n            int geti &#x3D; j &gt;&#x3D; v[i] ? dp[i + 1][j - v[i]] + w[i] : 0;\n            &#x2F;&#x2F;for (int j &#x3D; v[i]; j &lt;&#x3D; V; j++)不可！why？遍历不完全！（dp本质）\n            if (noti &gt; geti) &#123;&#x2F;&#x2F;不能用&gt;&#x3D; 不然多解时会出错\n                dp[i][j] &#x3D; noti;\n                dp_d[i][j] &#x3D; 1;\n            &#125; else &#123;\n                dp[i][j] &#x3D; geti;\n                dp_d[i][j] &#x3D; 2;\n            &#125;\n        &#125;\n    &#125;\n    &#x2F;&#x2F;DP_D\n    vector&lt;int&gt; ans;\n    int i &#x3D; 1 ,  j &#x3D; V;\n    while (i &lt;&#x3D; N &amp;&amp; j &gt; 0) &#123;\n        switch (dp_d[i][j]) &#123;\n            case 1:\n                i++;\n                break;\n            case 2:\n                if (j &gt;&#x3D; v[i])&#x2F;&#x2F;一个补丁，bug以后补坑\n                    ans.push_back(i);\n                j -&#x3D; v[i];\n                i++;\n                break;\n        &#125;\n    &#125;\n    for (auto i : ans) &#123;\n        cout &lt;&lt; i &lt;&lt; &quot; &quot;;\n    &#125;\n&#125;\n</code></pre>\n\n\n\n<h4 id=\"完全背包问题\"><a href=\"#完全背包问题\" class=\"headerlink\" title=\"完全背包问题\"></a>完全背包问题</h4><p>注意：关于 j 的循环是正向的。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">for (int i &#x3D; 0; i &lt; m; i++) &#123;\n        for (int j &#x3D; t[i]; j &lt;&#x3D; T; j++) &#123;\n            dp[j] &#x3D; max(dp[j], dp[j - t[i]] + v[i]);\n        &#125;\n    &#125;</code></pre>\n\n<p>Tips：解题时，注意数据范围，选择合适的数据结构（eg.long long，_int128）。</p>\n<p><strong>完全背包和 01 背包的区别就在于对容量限制枚举的顺序不同</strong></p>\n<p>原因：0-1背包问题的状态转移利用的是“上一个状态”，完全背包利用的是“当前状态”。</p>\n","text":"动态规划初步[toc] 基本思路动态规划实际是“聪明地枚举”，会遍历所有可能的情况。对其中的“剪枝”（不丢失最优解）属于贪心的范畴，可能提高了“溯源”的难度。 首先注意：动态规划不是说一上来就写状态转移方程（直接做“备忘录”），而是逐步分析，如下： 分析最优子结构 -&gt; 递...","link":"","photos":[],"count_time":{"symbolsCount":"3.1k","symbolsTime":"3 mins."},"categories":[{"name":"算法基础","slug":"算法基础","count":1,"path":"api/categories/算法基础.json"}],"tags":[{"name":"dp","slug":"dp","count":2,"path":"api/tags/dp.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%88%9D%E6%AD%A5\"><span class=\"toc-text\">动态规划初步</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF\"><span class=\"toc-text\">基本思路</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%83%8C%E5%8C%85-dp\"><span class=\"toc-text\">背包 dp</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#0-1%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98\"><span class=\"toc-text\">0-1背包问题</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#0-1%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E6%89%93%E5%8D%B0%E6%96%B9%E6%A1%88\"><span class=\"toc-text\">0-1背包问题打印方案</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98\"><span class=\"toc-text\">完全背包问题</span></a></li></ol></li></ol></li></ol></li></ol>","author":{"name":"Liul","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"动态规划的优化","uid":"138e79928c1a716384cb2dd1093bf72b","slug":"动态规划优化","date":"2021-08-06T14:40:33.683Z","updated":"2021-08-07T07:47:49.093Z","comments":true,"path":"api/articles/动态规划优化.json","keywords":null,"cover":null,"text":"动态规划的优化策略单调队列/单调栈优化单调队列eg.[Poj2823 - 滑动窗口]给予一个长度为n的数组，输出每k个连续元素中的最大值和最小值。 解：使用STL容器deque，维护一个单调的数列。以求最小值为例，操作包括： 序列例：1 3 -1 -3 5 3 6 7。 维护递增...","link":"","photos":[],"count_time":{"symbolsCount":"1.5k","symbolsTime":"1 mins."},"categories":[{"name":"算法进阶","slug":"算法进阶","count":1,"path":"api/categories/算法进阶.json"}],"tags":[{"name":"dp","slug":"dp","count":2,"path":"api/tags/dp.json"}],"author":{"name":"Liul","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{}}