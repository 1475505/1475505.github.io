{"title":"","uid":"f73a8e23e6f6f669cf99c7dba8fa0722","slug":"数据结构笔记——考试中的非主流玩法","date":"2021-11-23T09:05:09.123Z","updated":"2021-12-27T14:56:21.539Z","comments":true,"path":"api/articles/数据结构笔记——考试中的非主流玩法.json","keywords":null,"cover":[],"content":"<p>[toc]</p>\n<p>实际考试中的数据结构题目会比平时代码常用的东西多一点。在此提纲掣领地做一复习。</p>\n<h1 id=\"非常规队列\"><a href=\"#非常规队列\" class=\"headerlink\" title=\"非常规队列\"></a>非常规队列</h1><h2 id=\"顺序的环形实现\"><a href=\"#顺序的环形实现\" class=\"headerlink\" title=\"顺序的环形实现\"></a>顺序的环形实现</h2><p>顺序队列在数据不断地进队出队过程中，在顺序表中的位置不断后移。</p>\n<p>可以使用巧妙的方法将顺序表打造成一个环状表，如图 ：</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/6567790-e5806e91d36f67b7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/300\" alt=\"img\"></p>\n<p>在真正的实现时，没必要真创建这样一种结构，可以通过增加取模、判断（到达队尾返回开头）的方式实现。</p>\n<h2 id=\"循环队列\"><a href=\"#循环队列\" class=\"headerlink\" title=\"循环队列\"></a>循环队列</h2><p>队头指针front指向队头元素的前一位置，而队尾指针rear指向队尾元素。</p>\n<p>为解决如何判断队列的满与空问题，牺牲一个存储单元。</p>\n<h2 id=\"栈浮动技术\"><a href=\"#栈浮动技术\" class=\"headerlink\" title=\"栈浮动技术\"></a>栈浮动技术</h2><p>两个栈共享一组地址连续的存储单元。</p>\n<p>略。</p>\n<h1 id=\"广义表\"><a href=\"#广义表\" class=\"headerlink\" title=\"广义表\"></a>广义表</h1><h2 id=\"稀疏矩阵的存储\"><a href=\"#稀疏矩阵的存储\" class=\"headerlink\" title=\"稀疏矩阵的存储\"></a>稀疏矩阵的存储</h2><h3 id=\"三元组存储及快速转置\"><a href=\"#三元组存储及快速转置\" class=\"headerlink\" title=\"三元组存储及快速转置\"></a>三元组存储及快速转置</h3><p><img src=\"C:\\Users\\ll\\blog\\source_posts\\贴图\\350.png\" alt=\"img\"></p>\n<p>关键步骤：以 j 为序列，重新排列三元组表中存储各三元组的先后顺序。</p>\n<ol>\n<li>在普通算法的基础上增设两个数组（ array 和 copt）：</li>\n</ol>\n<ul>\n<li><p>array 数组负责记录原矩阵每一列非 0 元素的个数。例子对应的 array 数组：</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/6567790-164e9998c2c3026d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200\" alt=\"img\"></p>\n</li>\n<li><p>copt 数组用于计算稀疏矩阵中每列第一个非 0 元素在<strong>新</strong>三元组表中存放的位置，示例对应的 copt 数组如图 ：</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/6567790-22df260c67063f1c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200\" alt=\"img\"></p>\n</li>\n</ul>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">cpot[1]&#x3D;1\ncpot[col]&#x3D;cpot[col-1] +array[col-1]\t(col &gt; 1)&#x2F;&#x2F;意思是，后一列首个非 0 元素存放的位置等于前一列首个非 0 元素的存放位置,加上该列非 0 元素的个数。由此可以看出，copt 数组才是最终想要的，而 array 数组的设立只是为了帮助我们得到 copt 数组。</code></pre>\n\n\n\n<h3 id=\"行逻辑链接顺序表\"><a href=\"#行逻辑链接顺序表\" class=\"headerlink\" title=\"行逻辑链接顺序表\"></a>行逻辑链接顺序表</h3><p>当使用行逻辑链接的顺序表对其进行压缩存储时，需要做以下两个工作：</p>\n<p>1.将矩阵中的非 0 元素采用三元组的形式存储到一维数组 data 中，如图 ：</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/6567790-d9807ee6236a2bd1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/450\" alt=\"img\"></p>\n<p>2.使用数组 rpos 记录矩阵中每行第一个非 0 元素在一维数组中的存储位置。如图:</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/6567790-230259eea2644095.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/300\" alt=\"img\"></p>\n<p><strong>此时，如果想从行逻辑链接的顺序表中提取元素，则可以借助 rpos 数组提高遍历数组的效率。</strong></p>\n<p>例如，提取元素 2 的过程如下：</p>\n<p>由 <code>rpos</code> 数组可知，第一行首个非 0 元素位于data[1]，因此在遍历此行时，可以直接从第 data[1] 的位置开始，一直遍历到下一行首个非 0 元素所在的位置（data[3]）之前</p>\n<h3 id=\"十字链表\"><a href=\"#十字链表\" class=\"headerlink\" title=\"十字链表\"></a>十字链表</h3><p>为克服三元组表在矩阵的非零元素位置或个数经常变动时的使用不便，矩阵中的各行各列都各用一链表存储，与此同时，所有行链表的表头存储到一个数组（<code>rhead</code>），所有列链表的表头存储到另一个数组（<code>chead</code>）中。各个链表中节点的结构如图:</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/6567790-81a62ea7f51afc57.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/230\" alt=\"img\"></p>\n<p><img src=\"C:\\Users\\ll\\blog\\source_posts\\贴图\\image-20211123171532586.png\" alt=\"image-20211123171532586\"></p>\n<h1 id=\"树\"><a href=\"#树\" class=\"headerlink\" title=\"树\"></a>树</h1><h2 id=\"线索化\"><a href=\"#线索化\" class=\"headerlink\" title=\"线索化\"></a>线索化</h2><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>二叉链表对于无子树侧的指针域，能否利用这些空闲区存放有用的信息或线索？<br>——可以用它来存放当前结点的直接前驱和后继等线索，以加快查找速度。按照某种方式对二叉树进行遍历，可以把二叉树中所有结点排序为一个线性序列，参考之，可以把一棵二叉树转变成了一个“双向链表“。</p>\n<p>在该序列中，除第一个结点外每个结点有且仅有一个直接前驱结点；除最后一个结点外每一个结点有且仅有一个直接后继结点，由此线索化。</p></blockquote>\n<p>LTag=0, lchild域指向左孩子；LTag=1, lchild域指向其前驱<br>RTag=0, rchild域指向右孩子；RTag=1, rchild域指向其后继 </p>\n<p>在线索二叉树的基础上，额外添加一个结点。此结点的作用类似于链表中的头指针，数据域不起作用，只利用两个指针域：左指针域指向二叉树的树根，确保可以正方向对二叉树进行遍历；同时右指针指向线索二叉树形成的线性序列中的最后一个结点。同时，该节点也可避免”悬空”的情形。</p>\n<h2 id=\"补充结论\"><a href=\"#补充结论\" class=\"headerlink\" title=\"补充结论\"></a>补充结论</h2><h3 id=\"深入理解二叉树遍历\"><a href=\"#深入理解二叉树遍历\" class=\"headerlink\" title=\"深入理解二叉树遍历\"></a>深入理解二叉树遍历</h3><p>非递归中序遍历：</p>\n<ul>\n<li>入栈顺序：先序遍历；</li>\n<li>出栈顺序：中序遍历</li>\n</ul>\n<h3 id=\"二叉树和森林的互化\"><a href=\"#二叉树和森林的互化\" class=\"headerlink\" title=\"二叉树和森林的互化\"></a>二叉树和森林的互化</h3><h4 id=\"树和二叉树\"><a href=\"#树和二叉树\" class=\"headerlink\" title=\"树和二叉树\"></a>树和二叉树</h4><p>回忆我们从树抽象到二叉树的思路：</p>\n<p>将树用“长子 - 兄弟“ 表示法时，转化成对应二叉树的方式：</p>\n<ul>\n<li>从根开始，左子树连接“长子”；</li>\n<li>从根开始，右子树连接“兄弟”；</li>\n</ul>\n<p>由此便知二者互化的原理；</p>\n<h4 id=\"二叉树和森林\"><a href=\"#二叉树和森林\" class=\"headerlink\" title=\"二叉树和森林\"></a>二叉树和森林</h4><p>将森林中的每一棵树均用二叉树的方式抽象表述后，从最后一棵二叉树开始，每棵二叉树作为前一棵二叉树的根结点的右子树，得到森林对应的二叉树。</p>\n<p>所以，将二叉树根沿着右子树链方向的所有边去掉，得到若干棵孤立的二叉树，对应森林中的各棵树对应的二叉树集合。</p>\n<p><img src=\"C:\\Users\\ll\\blog\\source_posts\\贴图\\webp.webp\" alt=\"img\"></p>\n<p>参考：</p>\n<p><a href=\"https://www.jianshu.com/p/d7d5545012e2\">https://www.jianshu.com/p/d7d5545012e2</a></p>\n<h1 id=\"查找与排序\"><a href=\"#查找与排序\" class=\"headerlink\" title=\"查找与排序\"></a>查找与排序</h1><h2 id=\"分块查找\"><a href=\"#分块查找\" class=\"headerlink\" title=\"分块查找\"></a>分块查找</h2><p>n元素分块查找，记b为索引表长度，s为块中记录个数，则：</p>\n<p>当s取$\\sqrt{n}$时，$ASL_{bs}$取最小值$\\sqrt{n}+1$</p>\n<h1 id=\"仅限考试用的结论\"><a href=\"#仅限考试用的结论\" class=\"headerlink\" title=\"仅限考试用的结论\"></a>仅限考试用的结论</h1><ol>\n<li>树的高度是从1开始算的，也就是说，空树的高度是0。</li>\n<li>试卷中除非自己定义，请默认下标从“1”开始。</li>\n<li>并查集：与主流一致，根节点的值为-1.</li>\n</ol>\n","feature":true,"text":"[toc] 实际考试中的数据结构题目会比平时代码常用的东西多一点。在此提纲掣领地做一复习。 非常规队列顺序的环形实现顺序队列在数据不断地进队出队过程中，在顺序表中的位置不断后移。 可以使用巧妙的方法将顺序表打造成一个环状表，如图 ： 在真正的实现时，没必要真创建这样一种结构，可以...","link":"","photos":[],"count_time":{"symbolsCount":"2k","symbolsTime":"2 mins."},"categories":[],"tags":[],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E9%9D%9E%E5%B8%B8%E8%A7%84%E9%98%9F%E5%88%97\"><span class=\"toc-text\">非常规队列</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%A1%BA%E5%BA%8F%E7%9A%84%E7%8E%AF%E5%BD%A2%E5%AE%9E%E7%8E%B0\"><span class=\"toc-text\">顺序的环形实现</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97\"><span class=\"toc-text\">循环队列</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%A0%88%E6%B5%AE%E5%8A%A8%E6%8A%80%E6%9C%AF\"><span class=\"toc-text\">栈浮动技术</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%B9%BF%E4%B9%89%E8%A1%A8\"><span class=\"toc-text\">广义表</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%A8%80%E7%96%8F%E7%9F%A9%E9%98%B5%E7%9A%84%E5%AD%98%E5%82%A8\"><span class=\"toc-text\">稀疏矩阵的存储</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%89%E5%85%83%E7%BB%84%E5%AD%98%E5%82%A8%E5%8F%8A%E5%BF%AB%E9%80%9F%E8%BD%AC%E7%BD%AE\"><span class=\"toc-text\">三元组存储及快速转置</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%A1%8C%E9%80%BB%E8%BE%91%E9%93%BE%E6%8E%A5%E9%A1%BA%E5%BA%8F%E8%A1%A8\"><span class=\"toc-text\">行逻辑链接顺序表</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%8D%81%E5%AD%97%E9%93%BE%E8%A1%A8\"><span class=\"toc-text\">十字链表</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E6%A0%91\"><span class=\"toc-text\">树</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%BA%BF%E7%B4%A2%E5%8C%96\"><span class=\"toc-text\">线索化</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%A1%A5%E5%85%85%E7%BB%93%E8%AE%BA\"><span class=\"toc-text\">补充结论</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86\"><span class=\"toc-text\">深入理解二叉树遍历</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BA%8C%E5%8F%89%E6%A0%91%E5%92%8C%E6%A3%AE%E6%9E%97%E7%9A%84%E4%BA%92%E5%8C%96\"><span class=\"toc-text\">二叉树和森林的互化</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91\"><span class=\"toc-text\">树和二叉树</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E4%BA%8C%E5%8F%89%E6%A0%91%E5%92%8C%E6%A3%AE%E6%9E%97\"><span class=\"toc-text\">二叉树和森林</span></a></li></ol></li></ol></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E6%9F%A5%E6%89%BE%E4%B8%8E%E6%8E%92%E5%BA%8F\"><span class=\"toc-text\">查找与排序</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%88%86%E5%9D%97%E6%9F%A5%E6%89%BE\"><span class=\"toc-text\">分块查找</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E4%BB%85%E9%99%90%E8%80%83%E8%AF%95%E7%94%A8%E7%9A%84%E7%BB%93%E8%AE%BA\"><span class=\"toc-text\">仅限考试用的结论</span></a></li></ol>","author":{"name":"Liul","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"","uid":"f73a8e23e6f6f669cf99c7dba8fa0722","slug":"函数式编程导论","date":"2021-11-26T01:27:06.727Z","updated":"2021-11-26T01:27:06.727Z","comments":true,"path":"api/articles/函数式编程导论.json","keywords":null,"cover":null,"text":"","link":"","photos":[],"count_time":{"symbolsCount":0,"symbolsTime":"1 mins."},"categories":[],"tags":[],"author":{"name":"Liul","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true},"next_post":{"title":"C++ 特性","uid":"02283cddd2f2c72dd0f98ea650045063","slug":"从C进步到C++——特性","date":"2021-09-06T11:11:52.010Z","updated":"2022-01-02T12:08:13.849Z","comments":true,"path":"api/articles/从C进步到C++——特性.json","keywords":null,"cover":null,"text":"从C进步到C++——特性[TOC] 结构体初始化构造定义结构体时，加入以下语句，可以方便地进行初始化。 struct student&#123; int id; char gender; student()&#123;&#125; &#x2F;&#x2F;系统默认，用于未经初始化...","link":"","photos":[],"count_time":{"symbolsCount":"3.3k","symbolsTime":"3 mins."},"categories":[{"name":"语言基础","slug":"语言基础","count":1,"path":"api/categories/语言基础.json"}],"tags":[{"name":"C++,语法","slug":"C-语法","count":1,"path":"api/tags/C-语法.json"}],"author":{"name":"Liul","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true}}