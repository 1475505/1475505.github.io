{"title":"","uid":"f73a8e23e6f6f669cf99c7dba8fa0722","slug":"C++STL的使用","date":"2021-08-06T15:07:15.151Z","updated":"2022-02-03T09:30:39.678Z","comments":true,"path":"api/articles/C++STL的使用.json","keywords":null,"cover":[],"content":"<p>title:        C++ STL使用手册<br>tags:        C++,语法<br>categories:    语言基础<br>feature: true</p>\n<p>#C++ STL的使用手册</p>\n<p>[toc]</p>\n<p><img src=\"https://oi-wiki.org/lang/csl/images/container1.png\" alt=\"img\"></p>\n<h3 id=\"共有函数\"><a href=\"#共有函数\" class=\"headerlink\" title=\"共有函数\"></a>共有函数</h3><p><code>=</code>：有赋值运算符以及复制构造函数。</p>\n<p><code>begin()</code>：返回指向开头元素的迭代器。</p>\n<p><code>end()</code>：返回指向末尾的下一个元素的迭代器。<code>end()</code> <strong>不指向某个元素</strong>，它是末尾元素的后继。</p>\n<p><code>size()</code>：返回容器内的元素个数。</p>\n<p><code>max_size()</code>：返回容器 <strong>理论上</strong> 能存储的最大元素个数。依容器类型和所存储变量的类型而变。</p>\n<p><code>empty()</code>：返回容器是否为空的一个 <code>bool</code> 值，即 <code>begin() == end()</code>，<code>true</code> 为空，<code>false</code> 为非空。</p>\n<p><code>swap()</code>：交换两个容器。</p>\n<p><code>clear()</code>：清空容器。</p>\n<p><code>==</code>/<code>!=</code>/<code>&lt;</code>/<code>&gt;</code>/<code>&lt;=</code>/<code>&gt;=</code>：按 <strong>字典序</strong> 比较两个容器的大小。（比较元素大小时 <code>map</code> 的每个元素相当于 <code>set&lt;pair&lt;key, value&gt; &gt;</code>，<code>pair</code> 按 first 到 second 的顺序比较。无序容器不支持 <code>&lt;</code>/<code>&gt;</code>/<code>&lt;=</code>/<code>&gt;=</code></p>\n<h2 id=\"序列式容器\"><a href=\"#序列式容器\" class=\"headerlink\" title=\"序列式容器\"></a>序列式容器</h2><h3 id=\"vector\"><a href=\"#vector\" class=\"headerlink\" title=\"vector\"></a>vector</h3><p><strong>元素访问</strong></p>\n<ol>\n<li><p><code>at()</code></p>\n<p><code>v.at(pos)</code> 返回容器中下标为 <code>pos</code> 的引用。如果数组越界抛出 <code>std::out_of_range</code> 类型的异常。</p>\n</li>\n<li><p><code>operator[]</code></p>\n<p><code>v[pos]</code> 返回容器中下标为 <code>pos</code> 的引用。不执行越界检查。</p>\n</li>\n<li><p><code>front()</code></p>\n<p><code>v.front()</code> 返回首元素的引用。</p>\n</li>\n<li><p><code>back()</code></p>\n<p><code>v.back()</code> 返回末尾元素的引用。</p>\n</li>\n</ol>\n<p><strong>迭代器</strong></p>\n<ol>\n<li><p><code>begin()/cbegin()</code></p>\n<p>返回指向首元素的迭代器，其中 <code>*begin = front</code>。</p>\n</li>\n<li><p><code>end()/cend()</code></p>\n<p>返回指向数组尾端占位符的迭代器，注意是没有元素的。</p>\n</li>\n</ol>\n<p> 可以认为，<code>v[i]</code>与<code>*(v.begin()+i)</code>等价。但，<strong>除<code>vector</code> <code>string</code>外</strong>，其他STL容器不支持后者的形式。</p>\n<ul>\n<li><p><code>size()</code> 返回容器长度（元素数量），即 <code>std::distance(v.begin(), v.end())</code>。</p>\n</li>\n<li><p><code>insert()</code> 支持在某个迭代器位置插入元素、可以插入多个。<strong>复杂度与 <code>pos</code> 距离末尾长度成线性而非常数</strong></p>\n</li>\n<li><p><code>erase()</code> 删除某个<strong>迭代器或者区间的元素</strong>，返回最后被删除的迭代器。复杂度与 <code>insert</code> 一致。</p>\n</li>\n<li><p><code>push_back(x)</code> 在末尾插入一个元素x，均摊复杂度：常数，最坏为线性复杂度。</p>\n</li>\n<li><p><code>pop_back()</code> 删除末尾元素，常数复杂度。</p>\n</li>\n</ul>\n<h3 id=\"deque\"><a href=\"#deque\" class=\"headerlink\" title=\"deque\"></a>deque</h3><p>能够提供线性复杂度的插入和删除，以及常数复杂度的随机访问。操作大同<code>vector</code>。</p>\n<ul>\n<li><p><code>push_front()</code> 在头部插入一个元素。</p>\n</li>\n<li><p><code>pop_front()</code> 删除头部元素。</p>\n</li>\n<li><p><code>push_back()</code> 在末尾插入一个元素。</p>\n</li>\n<li><p><code>pop_back()</code> 删除末尾元素。</p>\n</li>\n</ul>\n<h3 id=\"list\"><a href=\"#list\" class=\"headerlink\" title=\"list\"></a>list</h3><p>与<code>deque</code>大致相同，但是由于 <code>list</code> 的实现是链表，因此不提供随机访问的接口。若需要访问中间元素，则需要使用迭代器。</p>\n<ul>\n<li><p><code>front()</code> 返回首元素的引用。</p>\n</li>\n<li><p><code>back()</code> 返回末尾元素的引用。</p>\n</li>\n</ul>\n<h3 id=\"array-C-11\"><a href=\"#array-C-11\" class=\"headerlink\" title=\"array(C++11)\"></a>array(C++11)</h3><table>\n<thead>\n<tr>\n<th align=\"left\">成员函数</th>\n<th align=\"left\">作用</th>\n<th>示例</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><code>operator=</code></td>\n<td align=\"left\"><code>array2</code> 的每个元素重写 <code>array1</code> 对应元素</td>\n<td></td>\n</tr>\n<tr>\n<td align=\"left\"><code>max_size</code></td>\n<td align=\"left\">返回可容纳的最大元素数</td>\n<td></td>\n</tr>\n<tr>\n<td align=\"left\"><code>fill</code></td>\n<td align=\"left\">以指定值填充容器</td>\n<td>arr.fill(1);</td>\n</tr>\n<tr>\n<td align=\"left\"><code>swap</code></td>\n<td align=\"left\">交换，交换array的复杂度为：O(size)</td>\n<td></td>\n</tr>\n</tbody></table>\n<table>\n<thead>\n<tr>\n<th align=\"left\">非成员函数</th>\n<th align=\"left\">作用</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><code>operator==</code></td>\n<td align=\"left\">按照字典序比较 <code>array</code> 中的值</td>\n</tr>\n<tr>\n<td align=\"left\"><code>std::get</code></td>\n<td align=\"left\">访问 <code>array</code> 的一个元素</td>\n</tr>\n</tbody></table>\n<h2 id=\"关联式容器\"><a href=\"#关联式容器\" class=\"headerlink\" title=\"关联式容器\"></a>关联式容器</h2><h3 id=\"统一共有函数\"><a href=\"#统一共有函数\" class=\"headerlink\" title=\"统一共有函数\"></a>统一共有函数</h3><ul>\n<li><p><code>find(x)</code>: 若容器内存在键为 x 的元素，会返回该元素的迭代器；否则返回 <code>end()</code>。</p>\n<p><img src=\"C:\\Users\\ll\\AppData\\Roaming\\Typora\\typora-user-images\\image-20211015124758889.png\" alt=\"image-20211015124758889\"></p>\n</li>\n<li><p><code>erase(pos)</code> 删除迭代器为 pos 的元素，可结合<code>find</code>函数使用。</p>\n</li>\n<li><p><code>erase(first,last)</code> 删除迭代器在 [first,last)范围内的所有元素。</p>\n</li>\n<li><p><code>count(x)</code>: 返回容器内键为 x 的元素数量。</p>\n</li>\n<li><p><code>lower_bound(x)</code>: 返回指向首个<strong>不小于</strong> 给定<strong>键</strong>的元素的迭代器。</p>\n</li>\n<li><p><code>upper_bound(x)</code>: 返回指向首个**大于 **给定键的元素的迭代器。若容器内所有元素均小于或等于给定键，返回 <code>end()</code>。</p>\n</li>\n<li><p><code>size()</code>: 返回容器内元素个数。</p>\n</li>\n</ul>\n<h3 id=\"set\"><a href=\"#set\" class=\"headerlink\" title=\"set\"></a>set</h3><p><code>set</code> 内部采用红黑树实现。平衡二叉树的特性使得 <code>set</code> 非常适合处理需要同时兼顾查找、插入与删除的情况。</p>\n<ul>\n<li><code>insert(x)</code> 将元素 x 插入到 <code>set</code> 中。自动排序和去重。</li>\n<li><code>erase(x)</code> 删除值为 x 的 <strong>所有</strong> 元素，返回删除元素的个数。</li>\n<li><code>erase(first,last)</code> 删除迭代器在 [first,last)范围内的所有元素。</li>\n</ul>\n<h3 id=\"map\"><a href=\"#map\" class=\"headerlink\" title=\"map\"></a>map</h3><p><code>map</code> 重载了 <code>operator[]</code>，可以用任意定义了 <code>operator &lt;</code> 的类型作为下标（在 <code>map</code> 中叫做 <code>key</code>，也就是索引）。</p>\n<ul>\n<li>可以直接通过下标访问来进行查询或插入操作。例： <code>mp[&quot;Alan&quot;]=100</code>。利用下标访问 时，如果 <code>map</code> 中不存在相应键的元素，会自动在 <code>map</code> 中插入一个新元素，并将其值设置为默认值（对于整数，值为零；对于有默认构造函数的类型，会调用默认构造函数进行初始化）</li>\n<li>通过向 <code>map</code> 中插入一个类型为 <code>pair&lt;Key, T&gt;</code> 的值可以达到插入元素的目的，例如 <code>mp.insert(pair&lt;string,int&gt;(&quot;Alan&quot;,100));</code></li>\n<li><code>erase(key)</code> 函数会删除键为 <code>key</code> 的 <strong>所有</strong> 元素。返回值为删除元素的数量。</li>\n</ul>\n<h2 id=\"哈希适配容器\"><a href=\"#哈希适配容器\" class=\"headerlink\" title=\"哈希适配容器\"></a>哈希适配容器</h2><p>四种基于哈希实现的无序关联式容器：<code>unordered_set</code>，<code>unordered_multiset</code>，<code>unordered_map</code>，<code>unordered_multimap</code>。</p>\n<p>其操作与关联式容器类似。</p>\n<h2 id=\"容器适配器\"><a href=\"#容器适配器\" class=\"headerlink\" title=\"容器适配器\"></a>容器适配器</h2><p>为什么称为容器适配器呢，是因为其内部的实现是基于<code>vector</code>  <code>deque </code> 等等，其原理可以参考《STL源码剖析》。</p>\n<h3 id=\"后进先出的stack\"><a href=\"#后进先出的stack\" class=\"headerlink\" title=\"后进先出的stack\"></a>后进先出的stack</h3><p>仅支持查询或删除最后一个加入的元素（栈顶元素），不支持随机访问。</p>\n<ul>\n<li><code>top()</code> 访问栈顶元素（如果栈为空，此处会出错）</li>\n<li><code>push(x)</code> 向栈中插入元素 x</li>\n<li><code>pop()</code> 删除栈顶元素</li>\n</ul>\n<h3 id=\"先进先出的queue\"><a href=\"#先进先出的queue\" class=\"headerlink\" title=\"先进先出的queue\"></a>先进先出的queue</h3><ul>\n<li><code>front()</code> 访问队首元素（如果队列为空，此处会出错）</li>\n<li><code>push(x)</code> 向队列中插入元素 x</li>\n<li><code>pop()</code> 删除队首元素</li>\n</ul>\n<h3 id=\"优先队列\"><a href=\"#优先队列\" class=\"headerlink\" title=\"优先队列\"></a>优先队列</h3><ul>\n<li><p><code>top()</code> 访问堆顶元素（此时优先队列不能为空）</p>\n</li>\n<li><p><code>push(x)</code> 插入元素，并对底层容器排序</p>\n</li>\n<li><p><code>pop()</code> 删除堆顶元素（此时优先队列不能为空）</p>\n</li>\n</ul>\n<p>以上<code>pop</code>方法，返回已删除元素的值。</p>\n<ul>\n<li><p>优先级的定义：</p>\n<p>对于数字，一般是值大者优先。即默认为：</p>\n<p><code>priority_queue&lt;int,vector&lt;int&gt;,less&lt;int&gt; &gt; pq;</code></p>\n<p>第二个参数是内部实现方式；第三个参数  <strong>less表示数字大的优先级越大。如果是<code>greater&lt;int&gt;</code>，则为数字小者优先级大。</strong>优先级大者，位于<code>top</code>。</p>\n<p>结构体也可以定义优先级，可以通过<code>cmp</code>函数或者重载<code>&lt;</code>运算符实现。这种思路也适用于其他关联式容器。</p>\n</li>\n</ul>\n<h3 id=\"pair的常见用法\"><a href=\"#pair的常见用法\" class=\"headerlink\" title=\"pair的常见用法\"></a>pair的常见用法</h3><p>头文件：<code>&lt;utility&gt;</code></p>\n<p>按照正常的结构体访问（first，second…）。</p>\n<h3 id=\"string的常见用法\"><a href=\"#string的常见用法\" class=\"headerlink\" title=\"string的常见用法\"></a>string的常见用法</h3><p><code>string</code>的实现形式类似于字符型<code>vector</code>，支持<code>push_back</code>、直接赋值（注意使用<strong>双引号</strong>）和下标访问。只支持<code>cin</code> <code>cout</code>，不支持<code>printf</code>等。</p>\n<ul>\n<li><p>可以通过加减运算符实现字符串拼接和删减、比较运算符进行字典序比较。</p>\n</li>\n<li><p><code>substr(pos,len)</code>方法截取子串。时间复杂度是O（len）。</p>\n</li>\n<li><p><code>find(x,pos)</code>指定了开始寻找的位置为下标<code>pos</code></p>\n</li>\n<li><p>上面的共有函数（<code>erase</code> <code>find</code>等）也是支持的。复杂度都是O(n)</p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">string s1 &#x3D; &quot;Hello&quot;;\nstring s2 &#x3D; &quot;world&quot;;\ns1.insert(3,s2);&#x2F;&#x2F;Helworldlo</code></pre></li>\n</ul>\n<h3 id=\"STL算法\"><a href=\"#STL算法\" class=\"headerlink\" title=\"STL算法\"></a>STL算法</h3><p>在《特性》篇也介绍有一些用法。</p>\n<ul>\n<li><code>find_end</code>：逆序查找。<code>find_end(v.begin(), v.end(), value)</code>。</li>\n<li><code>nth_element</code>：按指定范围进行分类，即找出序列中第 <em>n</em> 大的元素，使其左边均为小于它的数，右边均为大于它的数。<code>nth_element(v.begin(), v.begin() + mid, v.end(), cmp)</code> 或 <code>nth_element(a + begin, a + begin + mid, a + end, cmp)</code></li>\n<li><code>next_permutation</code>：将当前排列更改为 <strong>全排列中的下一个排列</strong>。如果当前排列已经是 <strong>全排列中的最后一个排列</strong>（元素完全从大到小排列），函数返回 <code>false</code> 并将排列更改为 <strong>全排列中的第一个排列</strong>（元素完全从小到大排列）；否则，函数返回 <code>true</code>。<code>next_permutation(v.begin(), v.end())</code> 或 <code>next_permutation(v + begin, v + end)</code>。</li>\n</ul>\n<h3 id=\"bitset\"><a href=\"#bitset\" class=\"headerlink\" title=\"bitset\"></a>bitset</h3><p>通过固定的优化，使得一个字节的八个比特能分别储存 8 位的 <code>0/1</code>。</p>\n<p>头文件：<code>&lt;bitset&gt;</code></p>\n<ul>\n<li><code>bitset()</code>: 每一位都是 <code>false</code>。</li>\n<li><code>bitset(int val)</code>: 设为 <code>val</code> 的二进制形式。</li>\n<li><code>bitset(const string&amp; str)</code>: 设为 01 串 <code>str</code>。</li>\n</ul>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">bitset&lt;4&gt; bitset1;　　&#x2F;&#x2F;无初始化下，默认每一位均为0\nbitset&lt;8&gt; bitset2(16);　&#x2F;&#x2F;保存长度为8的16的二进制表示：[00010000]\nstring s &#x3D; &quot;10010&quot;;\nbitset&lt;8&gt; bitset3(s);　　&#x2F;&#x2F;长度为10，前补0。[00010010]</code></pre>\n\n<ul>\n<li><p><code>operator []</code>: 访问其特定的一位。</p>\n</li>\n<li><p><code>operator ==/!=</code>: 比较两个 <code>bitset</code> 内容是否完全一样。</p>\n</li>\n<li><p><code>operator &amp;/&amp;=/|/| =/^/^=/~</code>: 进行按位与/或/异或/取反操作。**<code>bitset</code> 只能与 <code>bitset</code> 进行位运算**，若要和整型进行位运算，要先将整型转换为 <code>bitset</code>。</p>\n</li>\n<li><p><code>operator &lt;&gt;/&lt;&lt;=/&gt;&gt;=</code>: 进行二进制左移/右移。</p>\n</li>\n<li><p><code>operator &lt;&gt;</code>: 流运算符，这意味着你可以通过 <code>cin/cout</code> 进行输入输出。</p>\n</li>\n<li><p><code>count()</code>: 返回 <code>true</code> 的数量。</p>\n</li>\n<li><p><code>size()</code>: 返回 <code>bitset</code> 的大小。</p>\n</li>\n<li><p><code>test(pos)</code>: 它和 <code>vector</code> 中的 <code>at()</code> 的作用是一样的，和 <code>[]</code> 运算符的区别就是越界检查。</p>\n</li>\n<li><p><code>to_string()</code>: 返回转换成的字符串表达。</p>\n</li>\n<li><p><code>to_ulong()</code>: 返回转换成的 <code>unsigned long</code> 表达 (<code>long</code> 在 NT 及 32 位 POSIX 系统下与 <code>int</code> 一样，在 64 位 POSIX 下与 <code>long long</code> 一样）。</p>\n</li>\n<li><p><code>to_ullong()</code>:<em>C++11</em>，返回转换成的 <code>unsigned long long</code> 表达。</p>\n</li>\n<li><p><code>any()</code>: 若存在某一位是 <code>true</code> 则返回 <code>true</code>，否则返回 <code>false</code>。</p>\n</li>\n<li><p><code>none()</code>: 若所有位都是 <code>false</code> 则返回 <code>true</code>，否则返回 <code>false</code>。</p>\n</li>\n<li><p><code>all()</code>:<em>C++11</em>，若所有位都是 <code>true</code> 则返回 <code>true</code>，否则返回 <code>false</code>。</p>\n</li>\n<li><p><code>set()</code>: 将整个 <code>bitset</code> 设置成 <code>true</code>。</p>\n<p><code>set(pos, val = true)</code>: 将某一位设置成 <code>true</code>/<code>false</code>。</p>\n</li>\n<li><p><code>reset()</code>: 将整个 <code>bitset</code> 设置成 <code>false</code>。</p>\n<p><code>reset(pos)</code>: 将某一位设置成 <code>false</code>。相当于 <code>set(pos, false)</code>。</p>\n</li>\n<li><p><code>flip()</code>: 翻转每一位。（01互换，相当于异或一个全是1 的 <code>bitset</code>）</p>\n<p><code>flip(pos)</code>: 翻转某一位。</p>\n</li>\n<li><p><code>_Find_first()</code>: 返回 <code>bitset</code> 第一个 <code>true</code> 的下标，若没有 <code>true</code> 则返回 <code>bitset</code> 的大小。</p>\n</li>\n<li><p><code>_Find_next(pos)</code>: 返回 <code>pos</code> 后面（下标严格大于 <code>pos</code> 的位置）第一个 <code>true</code> 的下标，若 <code>pos</code> 后面没有 <code>true</code> 则返回 <code>bitset</code> 的大小。</p>\n</li>\n</ul>\n<p>参考资料：</p>\n<p>OI-wiki</p>\n<p>《算法笔记》</p>\n","text":"title: C++ STL使用手册tags: C++,语法categories: 语言基础feature: true #C++ STL的使用手册 [toc] 共有函数=：有赋值运算符以及复制构造函数。 begin()：返回指向开头元素的迭代器。 end()：返回指向末尾的下一个...","link":"","photos":[],"count_time":{"symbolsCount":"5.4k","symbolsTime":"5 mins."},"categories":[],"tags":[],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%85%B1%E6%9C%89%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">共有函数</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%BA%8F%E5%88%97%E5%BC%8F%E5%AE%B9%E5%99%A8\"><span class=\"toc-text\">序列式容器</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#vector\"><span class=\"toc-text\">vector</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#deque\"><span class=\"toc-text\">deque</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#list\"><span class=\"toc-text\">list</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#array-C-11\"><span class=\"toc-text\">array(C++11)</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%85%B3%E8%81%94%E5%BC%8F%E5%AE%B9%E5%99%A8\"><span class=\"toc-text\">关联式容器</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%BB%9F%E4%B8%80%E5%85%B1%E6%9C%89%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">统一共有函数</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#set\"><span class=\"toc-text\">set</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#map\"><span class=\"toc-text\">map</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%93%88%E5%B8%8C%E9%80%82%E9%85%8D%E5%AE%B9%E5%99%A8\"><span class=\"toc-text\">哈希适配容器</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%AE%B9%E5%99%A8%E9%80%82%E9%85%8D%E5%99%A8\"><span class=\"toc-text\">容器适配器</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%90%8E%E8%BF%9B%E5%85%88%E5%87%BA%E7%9A%84stack\"><span class=\"toc-text\">后进先出的stack</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%85%88%E8%BF%9B%E5%85%88%E5%87%BA%E7%9A%84queue\"><span class=\"toc-text\">先进先出的queue</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97\"><span class=\"toc-text\">优先队列</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#pair%E7%9A%84%E5%B8%B8%E8%A7%81%E7%94%A8%E6%B3%95\"><span class=\"toc-text\">pair的常见用法</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#string%E7%9A%84%E5%B8%B8%E8%A7%81%E7%94%A8%E6%B3%95\"><span class=\"toc-text\">string的常见用法</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#STL%E7%AE%97%E6%B3%95\"><span class=\"toc-text\">STL算法</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#bitset\"><span class=\"toc-text\">bitset</span></a></li></ol>","author":{"name":"Liul","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"算法模板","uid":"9e122bacf6c8b61a95cac22cf033e3e5","slug":"算法模板","date":"2021-09-09T12:13:56.975Z","updated":"2021-11-24T07:37:15.894Z","comments":true,"path":"api/articles/算法模板.json","keywords":null,"cover":[],"text":"回溯法[TOC] 解决一个回溯问题，实际上就是一个决策树的遍历过程，使用 isValid 函数剪枝。回溯算法模板框架如下： void backtracking(参数) &#123; if (结束遍历条件) &#123; 存放结果; return; &#125; for (选择：本...","link":"","photos":[],"count_time":{"symbolsCount":"1.4k","symbolsTime":"1 mins."},"categories":[],"tags":[],"author":{"name":"Liul","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"动态规划的优化","uid":"138e79928c1a716384cb2dd1093bf72b","slug":"动态规划优化","date":"2021-08-06T14:40:33.683Z","updated":"2021-08-07T07:47:49.093Z","comments":true,"path":"api/articles/动态规划优化.json","keywords":null,"cover":null,"text":"动态规划的优化策略单调队列/单调栈优化单调队列eg.[Poj2823 - 滑动窗口]给予一个长度为n的数组，输出每k个连续元素中的最大值和最小值。 解：使用STL容器deque，维护一个单调的数列。以求最小值为例，操作包括： 序列例：1 3 -1 -3 5 3 6 7。 维护递增...","link":"","photos":[],"count_time":{"symbolsCount":"1.5k","symbolsTime":"1 mins."},"categories":[{"name":"算法进阶","slug":"算法进阶","count":1,"path":"api/categories/算法进阶.json"}],"tags":[{"name":"dp","slug":"dp","count":2,"path":"api/tags/dp.json"}],"author":{"name":"Liul","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}