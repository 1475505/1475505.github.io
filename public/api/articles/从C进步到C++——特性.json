{"title":"C++ 特性","uid":"02283cddd2f2c72dd0f98ea650045063","slug":"从C进步到C++——特性","date":"2021-09-06T11:11:52.010Z","updated":"2022-01-02T12:08:13.849Z","comments":true,"path":"api/articles/从C进步到C++——特性.json","keywords":null,"cover":null,"content":"<h1 id=\"从C进步到C-——特性\"><a href=\"#从C进步到C-——特性\" class=\"headerlink\" title=\"从C进步到C++——特性\"></a>从C进步到C++——特性</h1><p>[TOC]</p>\n<h2 id=\"结构体初始化构造\"><a href=\"#结构体初始化构造\" class=\"headerlink\" title=\"结构体初始化构造\"></a>结构体初始化构造</h2><p>定义结构体时，加入以下语句，可以方便地进行初始化。</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">struct student&#123;\n\tint id;\n\tchar gender;\n\t\n\tstudent()&#123;&#125;  &#x2F;&#x2F;系统默认，用于未经初始化定义结构体\n\t\n\tstudent (int _id, char _gender )&#123;\n\t\tid &#x3D; _id;\n\t\tgender &#x3D; _gender;\n\t&#125;&#x2F;&#x2F;用于初始化id和gender。注意：减少参数 可以达到只使用部分元素构造的效果\n&#125;</code></pre>\n\n<p>构造函数可以简化为一行，并且可以进行默认赋值，如此调用时可以省略对应参数。如：</p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">Point (int x&#x3D;0 , int y &#x3D; 0):x(x),y(y) &#123;&#125;;\n&#x2F;&#x2F;Point();</code></pre>\n\n\n\n<p>这是一个二叉树节点的定义示例：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">struct TreeNode &#123;\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n    TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;\n&#125;;</code></pre>\n\n\n\n<h2 id=\"auto声明推断\"><a href=\"#auto声明推断\" class=\"headerlink\" title=\"auto声明推断\"></a>auto声明推断</h2><p>使用STL容器时的迭代器声明等等往往比较复杂，此时使用 <code>auto</code> 可简单很多：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">vector&lt;int&gt; vec;\nauto pvec &#x3D; vec.begin();&#x2F;&#x2F;vector&lt;int&gt;::iterator</code></pre>\n\n\n\n<h2 id=\"容器类for-range循环\"><a href=\"#容器类for-range循环\" class=\"headerlink\" title=\"容器类for-range循环\"></a>容器类for-range循环</h2><p>对数组或容器执行循环操作可写成：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">double prices[5] &#x3D; &#123;1.1 , 2.2 , 3.3 , 4.4 , 5.5&#125;\nfor ( double x : prices)&#123;&#x2F;&#x2F;只读\n\tcout&lt;&lt;x&lt;&lt;endl;\n&#125;\nfor ( double &amp;x : prices)&#123;&#x2F;&#x2F;写需要使用指针\n\tx &#x3D; x &#x2F; 2;\n&#125;</code></pre>\n\n\n\n<p>结合上面的auto 部分循环可以写成：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">for ( auto x : vec )</code></pre>\n\n\n\n<h2 id=\"string类的类型转换函数\"><a href=\"#string类的类型转换函数\" class=\"headerlink\" title=\"string类的类型转换函数\"></a>string类的类型转换函数</h2><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">int i &#x3D; 43;\nstring s &#x3D; to_string(i);\ndouble d &#x3D; stod(s);&#x2F;&#x2F;43.000000\n&#x2F;&#x2F;对应的有：stoi , stoll , stof</code></pre>\n\n<p><strong>注意不要传入空串！</strong></p>\n<h2 id=\"rotate-copy-fill函数\"><a href=\"#rotate-copy-fill函数\" class=\"headerlink\" title=\"rotate/copy/fill函数\"></a>rotate/copy/fill函数</h2><p>rotate函数可以“平移”。直接看例子吧：</p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">vector&lt;int&gt; a&#123;1,2,3,4,5,6,7,8,9&#125;;\nrotate(a.begin() , a.begin()+2 , a.end());\n&#x2F;&#x2F;a:[3,4,5,6,7,8,9,1,2]</code></pre>\n\n<p>相当于得到：[mid:end] + [begin:mid)</p>\n<p>copy函数将一个目标（容器、数组）里面的元素复制至另一个目标。</p>\n<p><strong>注：使用前 <code>newvector.resize(7) </code>这行代码为<code>newvector</code>分配空间，防止程序崩溃</strong>。</p>\n<p>此外，通过<code>vector&lt;int&gt;  dp ( 7 , 0 )</code>也可以达到初始化<code>dp</code>为[0,0,0,0,0,0,0].</p>\n<p>fill函数可以为数组和vector赋初始值。头文件：<code>&lt;algorithm&gt;</code></p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">int v[10];\nfill(v,v+10,-1);&#x2F;&#x2F;相当于 memset(v,-1,sizeof v);\nint s[10][10];\nfill(s[0],s[0]+10*10,-1);</code></pre>\n\n\n\n<h2 id=\"sort-lower-bound-upper-bound-unique函数\"><a href=\"#sort-lower-bound-upper-bound-unique函数\" class=\"headerlink\" title=\"sort/lower_bound/upper_bound/unique函数\"></a>sort/lower_bound/upper_bound/unique函数</h2><p>sort函数可用于 <code>vector </code>、 数组 和 <code>deque</code> 的排序。如：</p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">sort(b,b+n,greater&lt;int&gt;());&#x2F;&#x2F;将b降序排列</code></pre>\n\n<p>在<strong>已排好升序</strong>的情况下：</p>\n<p>1.可使用lower_bound函数（<code>startptr</code>，<code>endptr</code> ，<code>num</code>）得到第一个不小于<code>num</code>的值的指针。（二分查找）。如下代码返回下标：</p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">int a[10];&#x2F;&#x2F;......\nint b &#x3D; upper_bound(a , a+10 , 3) - a;</code></pre>\n\n<p>2.可使用unique函数返回最后一个非重复元素的指针，如下代码进行<strong>去重</strong>。</p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">vec.erase( unique(vec.begin(),vec.end()) , vec.end() );</code></pre>\n\n<p>拓展排序：partial_sort 方法</p>\n<h2 id=\"局部排序partiai-sort\"><a href=\"#局部排序partiai-sort\" class=\"headerlink\" title=\"局部排序partiai_sort\"></a>局部排序<code>partiai_sort</code></h2><p>可以提供一定区间的排序获得。原理似乎是堆排序。</p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">for(i&#x3D;10;i&gt;&#x3D;1;i--)\tvec.push_back(i);\npartial_sort(vec.begin(),vec.begin()+3,vec.end());\n&#x2F;&#x2F;[1,2,3,10,9,8,7,6,5,4]\n\nrep(i,1,10) a.push_back(i);\npartial_sort(vec.begin(),vec.begin()+3,vec.end(),greater&lt;int&gt;());\n&#x2F;&#x2F;[10,9,8,1,2,3,4,5,6,7]</code></pre>\n\n<p>应用：班上有10个学生，我想知道分数最低的5名是哪些人。如果没有partial_sort，你就需要用sort把所有人排好序，然后再取前5个。现在你只需要对分数最低5名排序。</p>\n<h2 id=\"一些可能有用的数学函数\"><a href=\"#一些可能有用的数学函数\" class=\"headerlink\" title=\"一些可能有用的数学函数\"></a>一些可能有用的数学函数</h2><p><strong>指对运算</strong></p>\n<p>以下函数：接收x为<code>float</code>    <code>double</code>类型，返回传入类型。</p>\n<p><code>exp2(x)</code>  - 快速返回2的x次幂。</p>\n<p><code>log2(x)</code> - 得到以2为底x的对数。</p>\n<p><code>log10(x)</code> - 得到以10为底x的对数。</p>\n<p><code>log(x)</code>  - 得到x的自然对数。</p>\n<p><code>expm(x)</code> - 返回e的x次幂-1。</p>\n<p><code>exp(x)</code> - 得到e的x次幂。x支持complex类型。</p>\n<p><strong>取整函数</strong></p>\n<p>以下函数的传入传出同上。</p>\n<p><code>floor(x)</code> - 向下取整。</p>\n<p><code>ceil(x)</code> - 向上取整。 </p>\n<p><code>round(x)</code> - 四舍五入，基本类似于<code>floor(x+0.5)</code>。<strong>但是中点情况下向远离0的方向舍入</strong>。</p>\n<p><code>trunc(x)</code> - 将x向0方向舍入。</p>\n<h2 id=\"数组生成-iota-shuffle\"><a href=\"#数组生成-iota-shuffle\" class=\"headerlink\" title=\"数组生成- iota/shuffle\"></a>数组生成- iota/shuffle</h2><p>递增数组：与 <code>golang </code>可对比：</p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">iota(arr,arr+n,0);&#x2F;&#x2F;[0,1,2,3,4,...];</code></pre>\n\n<p>随机打乱数组：</p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">srand(time(NULL));\nrandom_shuffle(a+1,a+n+1);</code></pre>\n\n<p><code>random_shuffle</code> 自 C++14 起被弃用，C++17 起被移除。可以使用 <code>shuffle</code> 函数代替：</p>\n<p><code>shuffle(v.begin(),v.end(),rand)</code>（最后一个参数传入的是使用的随机数生成器，一般情况下传入 <code>rand</code> 即可）。</p>\n<p>使用时需要设置随机数种子，配合<code>iota</code>可以实现类似于“洗牌”的效果。同时可进行随机的多次模拟，为了时间种子的不同，可能需要每次模拟间设置<code>sleep</code>间隔。</p>\n<p>参考资料：</p>\n<p>《C++ Primer》 目录</p>\n<p>《C++ Primer Plus》  18.1</p>\n<p>《算法竞赛入门经典习题解答》第一章</p>\n<p><a href=\"http://www.cppblog.com/mzty/archive/2005/12/15/1770.aspx\">http://www.cppblog.com/mzty/archive/2005/12/15/1770.aspx</a></p>\n","feature":true,"text":"从C进步到C++——特性[TOC] 结构体初始化构造定义结构体时，加入以下语句，可以方便地进行初始化。 struct student&#123; int id; char gender; student()&#123;&#125; &#x2F;&#x2F;系统默认，用于未经初始化...","link":"","photos":[],"count_time":{"symbolsCount":"3.3k","symbolsTime":"3 mins."},"categories":[{"name":"语言基础","slug":"语言基础","count":1,"path":"api/categories/语言基础.json"}],"tags":[{"name":"C++,语法","slug":"C-语法","count":1,"path":"api/tags/C-语法.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E4%BB%8EC%E8%BF%9B%E6%AD%A5%E5%88%B0C-%E2%80%94%E2%80%94%E7%89%B9%E6%80%A7\"><span class=\"toc-text\">从C进步到C++——特性</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%BB%93%E6%9E%84%E4%BD%93%E5%88%9D%E5%A7%8B%E5%8C%96%E6%9E%84%E9%80%A0\"><span class=\"toc-text\">结构体初始化构造</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#auto%E5%A3%B0%E6%98%8E%E6%8E%A8%E6%96%AD\"><span class=\"toc-text\">auto声明推断</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%AE%B9%E5%99%A8%E7%B1%BBfor-range%E5%BE%AA%E7%8E%AF\"><span class=\"toc-text\">容器类for-range循环</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#string%E7%B1%BB%E7%9A%84%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">string类的类型转换函数</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#rotate-copy-fill%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">rotate&#x2F;copy&#x2F;fill函数</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#sort-lower-bound-upper-bound-unique%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">sort&#x2F;lower_bound&#x2F;upper_bound&#x2F;unique函数</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%B1%80%E9%83%A8%E6%8E%92%E5%BA%8Fpartiai-sort\"><span class=\"toc-text\">局部排序partiai_sort</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B8%80%E4%BA%9B%E5%8F%AF%E8%83%BD%E6%9C%89%E7%94%A8%E7%9A%84%E6%95%B0%E5%AD%A6%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">一些可能有用的数学函数</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%95%B0%E7%BB%84%E7%94%9F%E6%88%90-iota-shuffle\"><span class=\"toc-text\">数组生成- iota&#x2F;shuffle</span></a></li></ol></li></ol>","author":{"name":"Liul","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"","uid":"f73a8e23e6f6f669cf99c7dba8fa0722","slug":"数据结构笔记——考试中的非主流玩法","date":"2021-11-23T09:05:09.123Z","updated":"2021-12-27T14:56:21.539Z","comments":true,"path":"api/articles/数据结构笔记——考试中的非主流玩法.json","keywords":null,"cover":[],"text":"[toc] 实际考试中的数据结构题目会比平时代码常用的东西多一点。在此提纲掣领地做一复习。 非常规队列顺序的环形实现顺序队列在数据不断地进队出队过程中，在顺序表中的位置不断后移。 可以使用巧妙的方法将顺序表打造成一个环状表，如图 ： 在真正的实现时，没必要真创建这样一种结构，可以...","link":"","photos":[],"count_time":{"symbolsCount":"2k","symbolsTime":"2 mins."},"categories":[],"tags":[],"author":{"name":"Liul","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true},"next_post":{"title":"","uid":"f73a8e23e6f6f669cf99c7dba8fa0722","slug":"数学之美摘抄","date":"2021-10-04T12:09:34.011Z","updated":"2021-10-04T12:09:34.453Z","comments":true,"path":"api/articles/数学之美摘抄.json","keywords":null,"cover":null,"text":"数学之美摘抄合理利用信息，而非玩弄什么公式和机器学习算法，是做好搜索的关键。 先帮用户解决 80% 的问题，再慢慢解决剩下的 20% 问题。 ","link":"","photos":[],"count_time":{"symbolsCount":71,"symbolsTime":"1 mins."},"categories":[],"tags":[],"author":{"name":"Liul","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}