{"title":"算法模板","uid":"9e122bacf6c8b61a95cac22cf033e3e5","slug":"算法模板","date":"2021-09-09T12:13:56.975Z","updated":"2021-11-24T07:37:15.894Z","comments":true,"path":"api/articles/算法模板.json","keywords":null,"cover":[],"content":"<h1 id=\"回溯法\"><a href=\"#回溯法\" class=\"headerlink\" title=\"回溯法\"></a>回溯法</h1><p>[TOC]</p>\n<p>解决一个回溯问题，实际上就是一个决策树的遍历过程，使用 <code>isValid</code> 函数剪枝。回溯算法模板框架如下：</p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">void backtracking(参数) &#123;\n    if (结束遍历条件) &#123;\n        存放结果;\n        return;\n    &#125;\n\n    for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) &#123;\n        if (!isValid(..)) \tcontinue;&#x2F;&#x2F;&#x2F;&#x2F; 排除不合法选择\n        处理节点;\n        backtracking(路径，选择列表); &#x2F;&#x2F; 深入\n        撤销节点处理；\n    &#125;\n&#125;</code></pre>\n\n<p>对于<code>isValid</code>函数及剪枝策略，回溯法求最值时，可以通过贪心思想找到一个“较优解”，减去差于其的枝。(分支限界法)</p>\n<p>回溯与 DFS 的思想很类似，区别主要在于解空间的表示和处理：</p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">for 循环内：\nrecord[son] &#x3D; 1; &#x2F;&#x2F; 标记使用&#x2F;状态\ndfs(deep + 1); &#x2F;&#x2F; dfs 下一层\nrecord[son] &#x3D; 0; &#x2F;&#x2F; 取消标记&#x2F;状态</code></pre>\n\n<p><strong>在递归之前做出选择，在递归之后撤销刚才的选择</strong>。</p>\n<p>解空间的状态表示主要有： 排列树 和 组合树 两种。</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20210130173631174.png\" alt=\"回溯算法理论基础\"></p>\n<p>口诀：for循环，换子树；递归调用往深溯</p>\n<h2 id=\"示例：生成全排列\"><a href=\"#示例：生成全排列\" class=\"headerlink\" title=\"示例：生成全排列\"></a>示例：生成全排列</h2><p><img src=\"https://github.com/labuladong/fucking-algorithm/raw/master/pictures/backtracking/3.jpg\" alt=\"img\"></p>\n<h2 id=\"n-皇后问题的-位运算解法-及-bitset-包\"><a href=\"#n-皇后问题的-位运算解法-及-bitset-包\" class=\"headerlink\" title=\"n-皇后问题的 位运算解法 及 bitset 包\"></a>n-皇后问题的 位运算解法 及 bitset 包</h2><h3 id=\"bitset\"><a href=\"#bitset\" class=\"headerlink\" title=\"bitset\"></a>bitset</h3><p>bitset 头文件中，有一种类似数组的结构，它的每一个元素只能是０或１，每个元素仅用１bit空间，名为 bitset 。构造方式：</p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">bitset&lt;4&gt; bitset1;　　&#x2F;&#x2F;无初始化下，默认每一位均为0\nbitset&lt;8&gt; bitset2(16);　&#x2F;&#x2F;保存长度为8的16的二进制表示：[00010000]\nstring s &#x3D; &quot;10010&quot;;\nbitset&lt;8&gt; bitset3(s);　　&#x2F;&#x2F;长度为10，前补0。[00010010]</code></pre>\n\n\n\n<p>bitset 支持一些按位的位运算，且支持to_string类型转换。</p>\n<p>对于一个叫做bit的bitset：<br>bit.size()       返回大小（位数）<br>bit.count()     返回1的个数<br>bit.any()       返回是否有1<br>bit.none()      返回是否没有1<br>bit.set()       全都变成1<br>bit.set(p)      将第p + 1位变成1（bitset是从第0位开始的！）<br>bit.set(p, x)   将第p + 1位变成x<br>bit.reset()     全都变成0<br>bit.reset(p)    将第p + 1位变成0<br>bit.flip()      全都取反<br>bit.flip(p)     将第p + 1位取反<br>bit.to_ulong()  返回它转换为unsigned long的结果，如果超出范围则报错<br>bit.to_ullong() 返回它转换为unsigned long long的结果，如果超出范围则报错</p>\n","text":"回溯法[TOC] 解决一个回溯问题，实际上就是一个决策树的遍历过程，使用 isValid 函数剪枝。回溯算法模板框架如下： void backtracking(参数) &#123; if (结束遍历条件) &#123; 存放结果; return; &#125; for (选择：本...","link":"","photos":[],"count_time":{"symbolsCount":"1.4k","symbolsTime":"1 mins."},"categories":[],"tags":[],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%9B%9E%E6%BA%AF%E6%B3%95\"><span class=\"toc-text\">回溯法</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%A4%BA%E4%BE%8B%EF%BC%9A%E7%94%9F%E6%88%90%E5%85%A8%E6%8E%92%E5%88%97\"><span class=\"toc-text\">示例：生成全排列</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#n-%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98%E7%9A%84-%E4%BD%8D%E8%BF%90%E7%AE%97%E8%A7%A3%E6%B3%95-%E5%8F%8A-bitset-%E5%8C%85\"><span class=\"toc-text\">n-皇后问题的 位运算解法 及 bitset 包</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#bitset\"><span class=\"toc-text\">bitset</span></a></li></ol></li></ol></li></ol>","author":{"name":"Liul","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"C/C++ 多维数组的处理","uid":"f4b1f6c62c51b83cc4ba3ecdcd8b9c52","slug":"C中多维数组的处理","date":"2021-09-19T13:17:35.450Z","updated":"2021-11-29T15:08:17.177Z","comments":true,"path":"api/articles/C中多维数组的处理.json","keywords":null,"cover":null,"text":"笔者要用到多维数组的时候经常忘了多维数组怎么用，在此总结一下： 【内容产出中】 1.二维数组的函数调用实例 &#x2F;&#x2F;声明 void bubbleSort(float (*num)[40],int size); &#x2F;&#x2F;调用 bubbleSort( ...","link":"","photos":[],"count_time":{"symbolsCount":609,"symbolsTime":"1 mins."},"categories":[],"tags":[],"author":{"name":"Liul","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"","uid":"f73a8e23e6f6f669cf99c7dba8fa0722","slug":"C++STL的使用","date":"2021-08-06T15:07:15.151Z","updated":"2022-02-03T09:30:39.678Z","comments":true,"path":"api/articles/C++STL的使用.json","keywords":null,"cover":[],"text":"title: C++ STL使用手册tags: C++,语法categories: 语言基础feature: true #C++ STL的使用手册 [toc] 共有函数=：有赋值运算符以及复制构造函数。 begin()：返回指向开头元素的迭代器。 end()：返回指向末尾的下一个...","link":"","photos":[],"count_time":{"symbolsCount":"5.4k","symbolsTime":"5 mins."},"categories":[],"tags":[],"author":{"name":"Liul","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}